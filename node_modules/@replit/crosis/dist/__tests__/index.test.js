"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("..");
var helpers_1 = require("../util/helpers");
var EIOCompat_1 = require("../util/EIOCompat");
var protocol_1 = require("@replit/protocol");
var genConnectionMetadata = require('../../debug/genConnectionMetadata');
var WebSocket = require('ws');
jest.setTimeout(30 * 1000);
var testingClients = [];
function getClient(done) {
    var c = new __1.Client();
    c.setUnrecoverableErrorHandler(done);
    testingClients.push(c);
    return c;
}
afterAll(function () {
    testingClients.forEach(function (c) { return c.destroy(); });
});
function wrapWithDone(done, fn) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        try {
            var res = fn.apply(void 0, args);
            if (typeof res === 'object' &&
                res &&
                'catch' in res &&
                typeof res.catch === 'function') {
                return res.catch(function (err) {
                    done(err);
                });
            }
            return res;
        }
        catch (e) {
            done(e);
            return undefined;
        }
    };
}
function getWebsocketClassThatNeverConnects() {
    var _WebsocketThatNeverConnects = (function () {
        function _WebsocketThatNeverConnects() {
            var _this = this;
            this.send = function () { };
            this.close = function (code, reason) {
                if (code === void 0) { code = 1000; }
                setTimeout(function () { var _a; return (_a = _this.onclose) === null || _a === void 0 ? void 0 : _a.call(_this, (0, EIOCompat_1.createCloseEvent)({ code: code, reason: reason })); });
            };
        }
        _WebsocketThatNeverConnects.OPEN = 1;
        return _WebsocketThatNeverConnects;
    }());
    var WebsocketThatNeverConnects = _WebsocketThatNeverConnects;
    expect(function () { return (0, helpers_1.getWebSocketClass)(WebsocketThatNeverConnects); }).not.toThrow();
    expect((0, helpers_1.getWebSocketClass)(WebsocketThatNeverConnects)).toEqual(WebsocketThatNeverConnects);
    return WebsocketThatNeverConnects;
}
test('client connect', function (done) {
    var client = getClient(done);
    var ctx = { username: 'zyzz' };
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: ctx,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error, context = _a.context;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(context).toBe(ctx);
        expect(error).toEqual(null);
        client.close();
        return function () {
            done();
        };
    }));
});
test('client connect with connection metadata retry', function (done) {
    var client = getClient(done);
    var ctx = { username: 'zyzz' };
    var tryCount = 0;
    client.open({
        fetchConnectionMetadata: function () {
            tryCount += 1;
            if (tryCount === 1) {
                return Promise.resolve({
                    error: __1.FetchConnectionMetadataError.Retriable,
                });
            }
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: ctx,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error, context = _a.context;
        expect(tryCount).toBe(2);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(context).toBe(ctx);
        expect(error).toEqual(null);
        client.close();
        return function () {
            done();
        };
    }));
});
test('client retries', function (done) {
    var client = getClient(done);
    var tryCount = 0;
    client.open({
        fetchConnectionMetadata: function () {
            tryCount += 1;
            if (tryCount === 1) {
                return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null, token: 'test - bad connection metadata retries' }));
            }
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(tryCount).toBe(2);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(error).toEqual(null);
        client.close();
        return function () {
            done();
        };
    }));
});
test('client retries and caches tokens', function (done) {
    var client = getClient(done);
    var fetchConnectionMetadata = jest.fn();
    var reconnectCount = 0;
    client.onDebugLog(function (log) {
        if (log.type !== 'breadcrumb' || log.message !== 'retrying') {
            return;
        }
        reconnectCount += 1;
        if (reconnectCount >= 2) {
            setTimeout(function () {
                client.close();
            });
        }
    });
    client.open({
        timeout: 1,
        reuseConnectionMetadata: true,
        fetchConnectionMetadata: function () {
            fetchConnectionMetadata();
            return Promise.resolve({
                token: 'test - bad connection metadata retries',
                gurl: 'ws://invalid.example.com',
                conmanURL: 'http://invalid.example.com',
                error: null,
            });
        },
        WebSocketClass: WebSocket,
        context: null,
    }, function (_a) {
        var error = _a.error;
        expect(fetchConnectionMetadata).toHaveBeenCalledTimes(1);
        expect(error).toBeTruthy();
        expect(error === null || error === void 0 ? void 0 : error.message).toBe('Failed to open');
        done();
        return function () { };
    });
});
test('client retries but does not cache tokens', function (done) {
    var client = getClient(done);
    var fetchConnectionMetadata = jest.fn();
    var reconnectCount = 0;
    client.onDebugLog(function (log) {
        if (log.type !== 'breadcrumb' || log.message !== 'retrying') {
            return;
        }
        reconnectCount += 1;
        if (reconnectCount >= 2) {
            setTimeout(function () {
                client.close();
            });
        }
    });
    client.open({
        timeout: 1,
        fetchConnectionMetadata: function () {
            fetchConnectionMetadata();
            return Promise.resolve({
                token: 'test - bad connection metadata retries',
                gurl: 'ws://invalid.example.com',
                conmanURL: 'http://invalid.example.com',
                error: null,
            });
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var error = _a.error;
        expect(fetchConnectionMetadata.mock.calls.length).toBeGreaterThan(1);
        expect(error).toBeTruthy();
        expect(error === null || error === void 0 ? void 0 : error.message).toBe('Failed to open');
        done();
        return function () { };
    }));
});
test('client requests new connection metadata after intentional close', function (done) {
    var client = getClient(done);
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(error).toEqual(null);
        client.close();
        return function () {
            setTimeout(function () {
                var didCallFetchConnectionMetadata = false;
                client.open({
                    fetchConnectionMetadata: function () {
                        didCallFetchConnectionMetadata = true;
                        return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
                    },
                    WebSocketClass: WebSocket,
                    context: null,
                }, function (_a) {
                    var c2 = _a.channel, e2 = _a.error;
                    expect(c2 === null || c2 === void 0 ? void 0 : c2.status).toBe('open');
                    expect(e2).toEqual(null);
                    expect(didCallFetchConnectionMetadata).toBeTruthy();
                    client.close();
                    return function () {
                        done();
                    };
                });
            });
        };
    }));
});
test('channel closing itself when client willReconnect', function (done) {
    var disconnectTriggered = false;
    var clientOpenCount = 0;
    var channelOpenCount = 0;
    var connectionMetadataCount = 0;
    var client = getClient(done);
    client.open({
        fetchConnectionMetadata: function () {
            connectionMetadataCount += 1;
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        clientOpenCount += 1;
        expect(error).toEqual(null);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        if (!disconnectTriggered) {
            setTimeout(function () {
                disconnectTriggered = true;
                client.ws.close();
            }, 1000);
        }
        else {
            client.close();
        }
        return wrapWithDone(done, function (_a) {
            var willReconnect = _a.willReconnect;
            if (willReconnect) {
                return;
            }
            expect(connectionMetadataCount).toEqual(2);
            expect(clientOpenCount).toEqual(2);
            expect(channelOpenCount).toEqual(1);
            done();
        });
    }));
    var close = client.openChannel({ service: 'shell' }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        channelOpenCount += 1;
        expect(error).toBe(null);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        return wrapWithDone(done, function (_a) {
            var willReconnect = _a.willReconnect;
            expect(willReconnect).toBeTruthy();
            close();
        });
    }));
});
test('channel open and close', function (done) {
    var client = getClient(done);
    var channelClose = jest.fn();
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(error).toEqual(null);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        return wrapWithDone(done, function () {
            expect(channelClose).toHaveBeenCalled();
            done();
        });
    }));
    var close = client.openChannel({ service: 'shell' }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(error).toBe(null);
        setTimeout(function () {
            close();
            expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closing');
        });
        return wrapWithDone(done, function (_a) {
            var willReconnect = _a.willReconnect;
            expect(willReconnect).toBeFalsy();
            expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closed');
            channelClose();
            client.close();
        });
    }));
});
test('channel accepts a thunk for service', function (done) {
    var context = { username: 'aghanim' };
    var client = getClient(done);
    var channelClose = jest.fn();
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: context,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(error).toEqual(null);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        return wrapWithDone(done, function () {
            expect(channelClose).toHaveBeenCalled();
            done();
        });
    }));
    var close = client.openChannel({
        service: wrapWithDone(done, function (ctx) {
            expect(ctx.username).toEqual('aghanim');
            return 'exec';
        }),
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(error).toBe(null);
        setTimeout(wrapWithDone(done, function () {
            close();
            expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closing');
        }));
        return wrapWithDone(done, function (_a) {
            var willReconnect = _a.willReconnect;
            expect(willReconnect).toBeFalsy();
            expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closed');
            channelClose();
            client.close();
        });
    }));
});
test('channel open and close from within openChannelCb synchronously', function (done) {
    var client = getClient(done);
    var channelClose = jest.fn();
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(error).toEqual(null);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        return wrapWithDone(done, function () {
            expect(channelClose).toHaveBeenCalled();
            done();
        });
    }));
    var close = client.openChannel({ service: 'shell' }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(error).toBe(null);
        close();
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closing');
        return wrapWithDone(done, function (_a) {
            var willReconnect = _a.willReconnect;
            expect(willReconnect).toBeFalsy();
            expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closed');
            channelClose();
            client.close();
        });
    }));
});
test('channel open and close from within openChannelCb synchronously', function (done) {
    var client = getClient(done);
    var channelClose = jest.fn();
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(error).toEqual(null);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        return function () {
            expect(channelClose).toHaveBeenCalled();
            done();
        };
    }));
    var close = client.openChannel({ service: 'shell' }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(error).toBe(null);
        close();
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closing');
        return wrapWithDone(done, function (_a) {
            var willReconnect = _a.willReconnect;
            expect(willReconnect).toBeFalsy();
            expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('closed');
            channelClose();
            client.close();
        });
    }));
});
test('channel skips opening', function (done) {
    var client = getClient(done);
    var service = 'shell';
    var ctx = { username: 'midas' };
    var skipfn = jest.fn().mockImplementation(function () { return true; });
    var opencb = jest.fn();
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: ctx,
    }, wrapWithDone(done, function (_a) {
        var error = _a.error;
        expect(error).toBeNull();
        setTimeout(function () {
            expect(skipfn).toHaveBeenCalledTimes(1);
            expect(skipfn).toHaveBeenCalledWith(ctx);
            expect(opencb).not.toHaveBeenCalled();
            client.close();
        }, 0);
        return function () {
            done();
        };
    }));
    client.openChannel({
        service: service,
        skip: skipfn,
    }, opencb);
});
test('channel skips opening conditionally', function (done) {
    var unexpectedDisconnectTriggered = false;
    var clientOpenCount = 0;
    var channelOpenCount = 0;
    var client = getClient(done);
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        clientOpenCount += 1;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(error).toEqual(null);
        if (unexpectedDisconnectTriggered) {
            client.close();
        }
        return wrapWithDone(done, function (_a) {
            var willReconnect = _a.willReconnect;
            if (willReconnect) {
                return;
            }
            expect(clientOpenCount).toEqual(2);
            expect(channelOpenCount).toEqual(1);
            done();
        });
    }));
    client.openChannel({
        skip: function () { return channelOpenCount > 0; },
        service: 'shell',
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        if (!unexpectedDisconnectTriggered) {
            setTimeout(function () {
                client.ws.close();
                unexpectedDisconnectTriggered = true;
            });
            expect(error).toBe(null);
            expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
            channelOpenCount += 1;
            return;
        }
        expect(error).toBeTruthy();
        expect(error === null || error === void 0 ? void 0 : error.message).toBe('Failed to open');
    }));
});
test('openChannel before open', function (done) {
    var client = getClient(done);
    client.openChannel({ service: 'exec' }, wrapWithDone(done, function (_a) {
        var channel = _a.channel;
        expect(channel).toBeTruthy();
        client.close();
    }));
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel;
        expect(channel).toBeTruthy();
        return function () {
            done();
        };
    }));
});
test('closing client maintains openChannel requests', function (done) {
    var client = getClient(done);
    var first = true;
    client.openChannel({ service: 'exec' }, wrapWithDone(done, function (_a) {
        var channel = _a.channel;
        expect(channel).toBeTruthy();
        if (first) {
            client.close();
            first = false;
            setTimeout(function () {
                client.open({
                    fetchConnectionMetadata: function () {
                        return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
                    },
                    WebSocketClass: WebSocket,
                    context: null,
                }, function () { return function () {
                    done();
                }; });
            }, 200);
        }
        else {
            client.close();
        }
    }));
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel;
        expect(channel).toBeTruthy();
        return function () { };
    }));
});
test('client rejects opening same channel twice', function (done) {
    var client = getClient(done);
    client.setUnrecoverableErrorHandler(function () { });
    var name = Math.random().toString();
    client.openChannel({ name: name, service: 'exec' }, function () { });
    expect(function () {
        client.openChannel({ name: name, service: 'exec' }, function () { });
    }).toThrow();
    done();
});
test('allows opening channel with the same name after closing others and client is disconnected', function (done) {
    var client = getClient(done);
    var name = Math.random().toString();
    var calledFirstWithError = false;
    var close = client.openChannel({ name: name, service: 'exec' }, function (_a) {
        var error = _a.error;
        calledFirstWithError = Boolean(error);
    });
    close();
    client.openChannel({ name: name, service: 'exec' }, wrapWithDone(done, function (_a) {
        var channel = _a.channel;
        expect(channel).toBeTruthy();
        expect(calledFirstWithError).toBeTruthy();
        client.close();
        done();
    }));
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, function () { });
});
test('allows opening channel with the same name after others are closing others and client is connected', function (done) {
    var client = getClient(done);
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var error = _a.error;
        if (error) {
            done(error);
            return function () { };
        }
        var name = Math.random().toString();
        var firstChannel;
        var close = client.openChannel({ name: name, service: 'exec' }, wrapWithDone(done, function (_a) {
            var channel = _a.channel;
            expect(channel).toBeTruthy();
            if (!channel) {
                throw new Error('apease typescript');
            }
            firstChannel = channel;
            expect(firstChannel.status).toEqual('closing');
        }));
        close();
        var close2 = client.openChannel({ name: name, service: 'exec' }, wrapWithDone(done, function (_a) {
            var secondChannel = _a.channel;
            expect(firstChannel).toBeTruthy();
            expect(secondChannel).toBeTruthy();
            expect(secondChannel === null || secondChannel === void 0 ? void 0 : secondChannel.status).toEqual('open');
            expect(secondChannel).not.toEqual(firstChannel);
            close2();
            expect(secondChannel === null || secondChannel === void 0 ? void 0 : secondChannel.status).toEqual('closing');
            var close3 = client.openChannel({ name: name, service: 'exec' }, wrapWithDone(done, function (_a) {
                var finalChannel = _a.channel;
                expect(finalChannel).toBeTruthy();
                expect(finalChannel === null || finalChannel === void 0 ? void 0 : finalChannel.status).toEqual('open');
                expect(finalChannel).not.toEqual(firstChannel);
                expect(finalChannel).not.toEqual(secondChannel);
                close3();
                client.close();
                done();
            }));
        }));
        return function () { };
    }));
});
test('opens multiple anonymous channels while client is connected', function (done) {
    var client = getClient(done);
    var didDone = false;
    var doneOnce = function (e) {
        if (didDone) {
            return;
        }
        didDone = true;
        client.close();
        done(e);
    };
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var chan0 = _a.channel;
        expect(chan0).toBeTruthy();
        var firstOpened = false;
        var secondOpened = false;
        client.openChannel({ service: 'exec' }, wrapWithDone(done, function (_a) {
            var channel = _a.channel;
            if (firstOpened) {
                doneOnce(new Error('exepected channel to open only once'));
                return;
            }
            expect(channel).toBeTruthy();
            firstOpened = true;
            if (secondOpened) {
                doneOnce();
            }
        }));
        client.openChannel({ service: 'exec' }, wrapWithDone(done, function (_a) {
            var channel = _a.channel;
            if (secondOpened) {
                doneOnce(new Error('exepected channel to open only once'));
                return;
            }
            expect(channel).toBeTruthy();
            secondOpened = true;
            if (firstOpened) {
                doneOnce();
            }
        }));
        return function () { };
    }));
});
test('client reconnects unexpected disconnects', function (done) {
    var client = getClient(done);
    var disconnectTriggered = false;
    var timesConnected = 0;
    var timesClosedUnintentionally = 0;
    var timesClosedIntentionally = 0;
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(error).toEqual(null);
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toEqual('open');
        timesConnected += 1;
        if (!disconnectTriggered) {
            setTimeout(function () {
                var _a;
                (_a = client.ws) === null || _a === void 0 ? void 0 : _a.close();
                disconnectTriggered = true;
            });
        }
        else {
            client.close();
        }
        return function (closeReason) {
            if (closeReason.initiator !== 'client') {
                throw new Error('Expected "client" initiator');
            }
            if (closeReason.willReconnect) {
                timesClosedUnintentionally += 1;
            }
            else if (closeReason.willReconnect === false) {
                timesClosedIntentionally += 1;
            }
            if (timesConnected === 2) {
                expect(timesClosedUnintentionally).toEqual(1);
                expect(timesClosedIntentionally).toEqual(1);
                done();
            }
        };
    }));
});
test('client is closed while reconnecting', function (done) {
    var onOpen = jest.fn();
    var client = getClient(done);
    client.onDebugLog(function (log) {
        if (log.type === 'breadcrumb' && log.message === 'reconnecting') {
            setTimeout(function () {
                client.close();
            });
        }
    });
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel;
        if (channel) {
            onOpen();
            setTimeout(function () {
                var _a;
                (_a = client.ws) === null || _a === void 0 ? void 0 : _a.close();
            });
        }
        return wrapWithDone(done, function () {
            expect(onOpen).toHaveBeenCalledTimes(1);
            done();
        });
    }));
});
test('closing before ever connecting', function (done) {
    var client = getClient(done);
    client.onDebugLog(function (log) {
        if (log.type === 'breadcrumb' && log.message === 'connecting') {
            setTimeout(function () {
                client.close();
            });
        }
    });
    var open = jest.fn();
    var openError = jest.fn();
    var close = jest.fn();
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var error = _a.error;
        if (error) {
            openError();
            expect(open).not.toHaveBeenCalled();
            expect(openError).toHaveBeenCalledTimes(1);
            expect(close).not.toHaveBeenCalled();
            done();
        }
        else {
            open();
        }
        return function () {
            close();
        };
    }));
});
test('fallback to polling', function (done) {
    var client = getClient(done);
    var WebsocketThatNeverConnects = getWebsocketClassThatNeverConnects();
    var didLogFallback = false;
    client.onDebugLog(function (log) {
        if (log.type === 'breadcrumb' && log.message === 'polling fallback') {
            didLogFallback = true;
        }
    });
    client.open({
        timeout: 2000,
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebsocketThatNeverConnects,
        context: null,
        pollingHost: 'gp-v2.replit.com',
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(error).toBeNull();
        expect(channel).not.toBeNull();
        expect(didLogFallback).toBe(true);
        client.close();
        return function () {
            done();
        };
    }));
}, 40000);
test('does not fallback to polling if host is unset', function (done) {
    var client = getClient(done);
    client.setUnrecoverableErrorHandler(function () { });
    var WebsocketThatNeverConnects = getWebsocketClassThatNeverConnects();
    var didLogFallback = false;
    client.onDebugLog(function (log) {
        var _a;
        if (log.type === 'breadcrumb' &&
            log.message === 'connecting' &&
            ((_a = log.data) === null || _a === void 0 ? void 0 : _a.connectTries) === 4) {
            setTimeout(function () {
                client.destroy();
            });
        }
        if (log.type === 'breadcrumb' && log.message === 'polling fallback') {
            didLogFallback = true;
        }
    });
    client.open({
        timeout: 500,
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebsocketThatNeverConnects,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(didLogFallback).toBe(false);
        expect(channel).toBeNull();
        expect(error).not.toBeNull();
        done();
    }));
}, 40000);
test('cancels connection timeout when closing', function (done) {
    var client = getClient(done);
    var WebsocketThatNeverConnects = getWebsocketClassThatNeverConnects();
    var timeout = 2000;
    client.onDebugLog(function (log) {
        if (log.type === 'breadcrumb' && log.message === 'connecting') {
            setTimeout(function () {
                client.close();
                setTimeout(function () {
                    done();
                }, timeout + 100);
            });
        }
    });
    client.open({
        timeout: timeout,
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebsocketThatNeverConnects,
        context: null,
    }, function () { });
}, 20000);
test('fetch token fail', function (done) {
    var chan0Cb = jest.fn();
    var client = getClient(done);
    client.setUnrecoverableErrorHandler(wrapWithDone(done, function (e) {
        expect(chan0Cb).toHaveBeenCalledTimes(1);
        expect(e.message).toContain('fail');
        done();
    }));
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve({
                error: new Error('fail'),
            });
        },
        WebSocketClass: WebSocket,
        context: null,
    }, chan0Cb);
});
test('fetch abort signal works as expected', function (done) {
    var client = getClient(done);
    var onAbort = jest.fn();
    client.open({
        fetchConnectionMetadata: function (abortSignal) {
            return new Promise(function (r) {
                abortSignal.onabort = function () {
                    onAbort();
                    r({
                        error: __1.FetchConnectionMetadataError.Aborted,
                    });
                };
                setTimeout(function () {
                    client.close();
                }, 0);
            });
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(channel).toBe(null);
        expect(error).toBeTruthy();
        expect(error === null || error === void 0 ? void 0 : error.message).toBe('Failed to open');
        expect(onAbort).toHaveBeenCalledTimes(1);
        done();
        return function () { };
    }));
});
test('can close and open in synchronously without aborting fetch token', function (done) {
    var client = getClient(done);
    var onAbort = jest.fn();
    var firstChan0Cb = jest.fn();
    var resolveFetchToken = null;
    client.open({
        fetchConnectionMetadata: function (abortSignal) {
            return new Promise(function (r) {
                resolveFetchToken = r;
                abortSignal.onabort = function () {
                    onAbort();
                };
            });
        },
        WebSocketClass: WebSocket,
        context: null,
    }, firstChan0Cb);
    client.close();
    expect(resolveFetchToken).toBeTruthy();
    resolveFetchToken({ error: __1.FetchConnectionMetadataError.Aborted });
    expect(onAbort).toHaveBeenCalledTimes(1);
    expect(firstChan0Cb).toHaveBeenCalledTimes(1);
    expect(firstChan0Cb).toHaveBeenLastCalledWith(expect.objectContaining({
        channel: null,
        context: null,
        error: expect.any(Error),
    }));
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: null,
    }, wrapWithDone(done, function (_a) {
        var channel = _a.channel, error = _a.error;
        expect(channel === null || channel === void 0 ? void 0 : channel.status).toBe('open');
        expect(error).toEqual(null);
        client.close();
        return wrapWithDone(done, function () {
            expect(firstChan0Cb).toHaveBeenCalledTimes(1);
            done();
        });
    }));
});
test('emits boot status messages', function (done) {
    var client = getClient(done);
    var ctx = { username: 'zyzz' };
    var count = 0;
    client.onBootStatus(wrapWithDone(done, function (bootStatus) {
        count++;
        if (count === 1) {
            expect(bootStatus).toEqual(expect.objectContaining({
                stage: protocol_1.api.BootStatus.Stage.HANDSHAKE,
            }));
        }
        else if (count === 2) {
            expect(bootStatus).toEqual(expect.objectContaining({
                stage: protocol_1.api.BootStatus.Stage.ACQUIRING,
            }));
        }
        else if (count === 3) {
            expect(bootStatus).toEqual(expect.objectContaining({
                stage: protocol_1.api.BootStatus.Stage.COMPLETE,
            }));
            client.destroy();
            done();
        }
    }));
    client.open({
        fetchConnectionMetadata: function () {
            return Promise.resolve(__assign(__assign({}, genConnectionMetadata()), { error: null }));
        },
        WebSocketClass: WebSocket,
        context: ctx,
    }, function () { });
});
//# sourceMappingURL=index.test.js.map