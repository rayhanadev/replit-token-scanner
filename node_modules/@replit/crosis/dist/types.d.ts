import type { api } from '@replit/protocol';
import type { Channel } from './channel';
export declare enum ConnectionState {
    CONNECTING = 0,
    CONNECTED = 1,
    DISCONNECTED = 2
}
export declare enum FetchConnectionMetadataError {
    Aborted = "Aborted",
    Retriable = "Retriable"
}
export interface GovalMetadata {
    token: string;
    gurl: string;
    conmanURL: string;
}
export declare type Result<Res, Err = Error> = (Res & {
    error: null;
}) | {
    error: Err;
};
export declare type FetchConnectionMetadataResult = Result<GovalMetadata, Error | FetchConnectionMetadataError>;
export interface ConnectOptions<Ctx> {
    fetchConnectionMetadata: (abortSignal: AbortSignal) => Promise<FetchConnectionMetadataResult>;
    timeout: number | null;
    WebSocketClass?: typeof WebSocket;
    context: Ctx;
    reuseConnectionMetadata: boolean;
    pollingHost?: string;
}
export interface UrlOptions {
    secure: boolean;
    host: string;
    port: string;
}
export interface OpenOptions<Ctx> extends Partial<ConnectOptions<Ctx>> {
    fetchConnectionMetadata: (abortSignal: AbortSignal) => Promise<FetchConnectionMetadataResult>;
    urlOptions?: UrlOptions;
    context: Ctx;
}
export declare type DebugLog = {
    type: 'breadcrumb';
    message: string;
    data?: unknown;
} | {
    type: 'log';
    log: {
        direction: 'in' | 'out';
        channel: {
            id: number;
            name?: string;
            service?: string;
        };
        cmd: api.Command;
    };
};
export declare type ChannelCloseReason = {
    initiator: 'client';
    willReconnect: boolean;
} | {
    initiator: 'channel';
    willReconnect: false;
};
interface ServiceThunk<Ctx> {
    (context: Ctx): string;
}
export interface ChannelOptions<Ctx> {
    name?: string;
    service: string | ServiceThunk<Ctx>;
    action?: api.OpenChannel.Action;
    skip?: (context: Ctx) => boolean;
}
export declare type OpenChannelCb<Ctx> = (res: {
    error: null;
    channel: Channel;
    context: Ctx;
} | {
    error: Error;
    channel: null;
    context: Ctx | null;
}) => void | ((reason: ChannelCloseReason) => void);
export interface RequestResult extends api.Command {
    channelClosed?: ChannelCloseReason;
}
export {};
