"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EIOCompat = exports.createCloseEvent = exports.splitHref = void 0;
var eio = require("engine.io-client");
var urllib = require("url");
function splitHref(href) {
    var parsed = urllib.parse(href);
    var protocol = parsed.protocol, slashes = parsed.slashes, auth = parsed.auth, host = parsed.host, pathname = parsed.pathname;
    var uri = urllib.format({
        protocol: protocol,
        slashes: slashes,
        auth: auth,
        host: host,
        query: { ordered: '1' },
    });
    var path = pathname != null ? pathname : '/';
    return { uri: uri, path: path };
}
exports.splitHref = splitHref;
var sequenceBytesCount = 4;
var readyStateStringToValue = new Map([
    ['opening', 0],
    ['open', 1],
    ['closing', 2],
    ['closed', 3],
]);
function createMessageEvent(data) {
    if (typeof window !== 'undefined') {
        return new MessageEvent('message', { data: data });
    }
    return {
        type: 'message',
        data: data,
    };
}
function createCloseEvent(info) {
    if (typeof window !== 'undefined') {
        return new CloseEvent('close', info);
    }
    return __assign({ type: 'close' }, info);
}
exports.createCloseEvent = createCloseEvent;
function createEvent(type, info) {
    if (typeof window !== 'undefined') {
        return new Event(type, info);
    }
    return __assign({ type: type }, info);
}
var EIOCompat = (function () {
    function EIOCompat(url, protocols) {
        var _this = this;
        this.CLOSED = 3;
        this.CLOSING = 2;
        this.OPEN = 1;
        this.CONNECTING = 0;
        if (protocols) {
            throw new Error('Passing protocols is not implemented');
        }
        var _a = splitHref(url), uri = _a.uri, path = _a.path;
        this.onopen = null;
        this.onclose = null;
        this.onmessage = null;
        this.onerror = null;
        this.eioSocket = eio(uri, { path: path, transports: ['polling'] });
        this.url = url;
        this.extensions = '';
        this.protocol = '';
        this.bufferedAmount = 0;
        this.readyState = 0;
        this.incomingSequence = 0;
        this.outOfOrderQueue = {};
        this.outgoingSequence = 0;
        this.setReadyState();
        this.eioSocket.on('open', function () {
            _this.setReadyState();
            if (_this.onopen != null) {
                var event_1 = createEvent('open');
                _this.onopen.call(_this, event_1);
            }
        });
        this.eioSocket.on('close', function (reason) {
            _this.setReadyState();
            if (_this.onclose != null) {
                var event_2 = createCloseEvent({
                    reason: reason,
                    code: 1001,
                    wasClean: false,
                });
                _this.onclose.call(_this, event_2);
            }
        });
        this.eioSocket.on('message', function (data) {
            _this.setReadyState();
            if (_this.onmessage == null) {
                return;
            }
            if (typeof data === 'string') {
                throw new Error('expected data to be ArrayBuffer not string');
            }
            var view = new DataView(data);
            var sequence = view.getUint32(0);
            var commandData = data.slice(sequenceBytesCount);
            if (_this.incomingSequence !== sequence) {
                _this.outOfOrderQueue[sequence] = commandData;
                return;
            }
            _this.incomingSequence = sequence + 1;
            var message = createMessageEvent(commandData);
            var onmessage = _this.onmessage.bind(_this);
            onmessage(message);
            var queuedSequences = Object.keys(_this.outOfOrderQueue);
            if (queuedSequences.length > 0) {
                queuedSequences.sort().forEach(function (seq) {
                    onmessage(createMessageEvent(_this.outOfOrderQueue[+seq]));
                    _this.incomingSequence = +seq + 1;
                });
                _this.outOfOrderQueue = {};
            }
        });
        this.eioSocket.on('error', function () {
            _this.setReadyState();
            if (_this.onerror != null) {
                var event_3 = createEvent('error');
                _this.onerror.call(_this, event_3);
            }
        });
    }
    EIOCompat.prototype.setReadyState = function () {
        this.readyState = readyStateStringToValue.get(this.eioSocket.readyState);
    };
    EIOCompat.prototype.send = function (buffer) {
        var sequencedBuffer = new ArrayBuffer(sequenceBytesCount + buffer.byteLength);
        new Uint8Array(sequencedBuffer).set(new Uint8Array(buffer), sequenceBytesCount);
        var view = new DataView(sequencedBuffer);
        view.setUint32(0, this.outgoingSequence);
        this.outgoingSequence += 1;
        this.eioSocket.send(sequencedBuffer);
        this.setReadyState();
    };
    EIOCompat.prototype.close = function () {
        this.onmessage = null;
        this.eioSocket.close();
        this.setReadyState();
    };
    EIOCompat.prototype.addEventListener = function () {
        throw new Error('Not Implemented, please use onmessage, onopen, onerror, or onclose');
    };
    EIOCompat.prototype.removeEventListener = function () {
        throw new Error('Not Implemented');
    };
    EIOCompat.prototype.dispatchEvent = function () {
        throw new Error('Not Implemented');
    };
    Object.defineProperty(EIOCompat.prototype, "binaryType", {
        get: function () {
            return this.eioSocket.binaryType || 'blob';
        },
        set: function (value) {
            this.eioSocket.binaryType = value;
        },
        enumerable: false,
        configurable: true
    });
    EIOCompat.CLOSED = 3;
    EIOCompat.CLOSING = 2;
    EIOCompat.OPEN = 1;
    EIOCompat.CONNECTING = 0;
    return EIOCompat;
}());
exports.EIOCompat = EIOCompat;
//# sourceMappingURL=EIOCompat.js.map