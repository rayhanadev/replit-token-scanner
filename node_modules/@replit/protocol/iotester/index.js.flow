/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.20.0
 * @flow
 */

import * as $protobuf from "protobufjs";
export var api = npm$namespace$api;

declare var npm$namespace$api: {|
  Status: typeof api$Status,
  IPayload: Class<api$IPayload>,
  ISysCommand: Class<api$ISysCommand>,
  IRunInfo: Class<api$IRunInfo>,
  ITest: Class<api$ITest>,
  IInstruction: Class<api$IInstruction>,
  IInputInstruction: Class<api$IInputInstruction>,
  IOutputInstruction: Class<api$IOutputInstruction>,
  IRegexMatchOptions: Class<api$IRegexMatchOptions>,
  IExactMatchOptions: Class<api$IExactMatchOptions>,
  IMatchMatchOptions: Class<api$IMatchMatchOptions>,
  ICompatibilityMatchOptions: Class<api$ICompatibilityMatchOptions>,
  IResponse: Class<api$IResponse>,
  ITestResult: Class<api$ITestResult>,
  IInstructionResult: Class<api$IInstructionResult>,
  IError: Class<api$IError>,
  Payload: typeof api$Payload,
  SysCommand: typeof api$SysCommand,
  RunInfo: typeof api$RunInfo,
  Test: typeof api$Test,
  Instruction: typeof api$Instruction,
  InputInstruction: typeof api$InputInstruction,
  OutputInstruction: typeof api$OutputInstruction,
  RegexMatchOptions: typeof api$RegexMatchOptions,
  ExactMatchOptions: typeof api$ExactMatchOptions,
  MatchMatchOptions: typeof api$MatchMatchOptions,
  CompatibilityMatchOptions: typeof api$CompatibilityMatchOptions,
  Response: typeof api$Response,
  TestResult: typeof api$TestResult,
  InstructionResult: typeof api$InstructionResult,
  Error: typeof api$Error,
|};

/**
 * Properties of a Payload.
 */
declare type api$IPayload = {|
  /**
   * Payload runInfo
   */
  runInfo?: api$RunInfo | api$IRunInfo | null,

  /**
   * Payload tests
   */
  tests?: (api$Test | api$ITest)[] | null,
|};

/**
 * Represents a Payload.
 */
declare class api$Payload {
  /**
   * Constructs a new Payload.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPayload): this;

  /**
   * Payload runInfo.
   */
  runInfo?: api$RunInfo | null;

  /**
   * Payload tests.
   */
  tests: api$Test[];

  /**
   * Creates a new Payload instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Payload instance
   */
  static create(properties?: api$IPayload): api$Payload;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Payload message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Payload,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Payload message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Payload,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Payload message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Payload
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Payload;

  /**
   * Decodes a Payload message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Payload
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Payload;

  /**
   * Verifies a Payload message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Payload message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Payload
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Payload;

  /**
   * Creates a plain object from a Payload message. Also converts values to other types if specified.
   * @param message Payload
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Payload,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Payload to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a SysCommand.
 */
declare type api$ISysCommand = {|
  /**
   * SysCommand args
   */
  args?: string[] | null,

  /**
   * SysCommand env
   */
  env?: {|
    [k: string]: string,
  |} | null,
|};

/**
 * Represents a SysCommand.
 */
declare class api$SysCommand {
  /**
   * Constructs a new SysCommand.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ISysCommand): this;

  /**
   * SysCommand args.
   */
  args: string[];

  /**
   * SysCommand env.
   */
  env: {|
    [k: string]: string,
  |};

  /**
   * Creates a new SysCommand instance using the specified properties.
   * @param [properties] Properties to set
   * @returns SysCommand instance
   */
  static create(properties?: api$ISysCommand): api$SysCommand;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SysCommand message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$SysCommand,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SysCommand message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$SysCommand,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a SysCommand message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns SysCommand
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$SysCommand;

  /**
   * Decodes a SysCommand message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns SysCommand
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$SysCommand;

  /**
   * Verifies a SysCommand message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a SysCommand message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns SysCommand
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$SysCommand;

  /**
   * Creates a plain object from a SysCommand message. Also converts values to other types if specified.
   * @param message SysCommand
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$SysCommand,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this SysCommand to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a RunInfo.
 */
declare type api$IRunInfo = {|
  /**
   * RunInfo buildCommand
   */
  buildCommand?: api$SysCommand | api$ISysCommand | null,

  /**
   * RunInfo execCommand
   */
  execCommand?: api$SysCommand | api$ISysCommand | null,
|};

/**
 * Represents a RunInfo.
 */
declare class api$RunInfo {
  /**
   * Constructs a new RunInfo.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IRunInfo): this;

  /**
   * RunInfo buildCommand.
   */
  buildCommand?: api$SysCommand | null;

  /**
   * RunInfo execCommand.
   */
  execCommand?: api$SysCommand | null;

  /**
   * Creates a new RunInfo instance using the specified properties.
   * @param [properties] Properties to set
   * @returns RunInfo instance
   */
  static create(properties?: api$IRunInfo): api$RunInfo;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RunInfo message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$RunInfo,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RunInfo message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$RunInfo,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a RunInfo message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns RunInfo
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$RunInfo;

  /**
   * Decodes a RunInfo message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns RunInfo
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$RunInfo;

  /**
   * Verifies a RunInfo message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a RunInfo message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns RunInfo
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$RunInfo;

  /**
   * Creates a plain object from a RunInfo message. Also converts values to other types if specified.
   * @param message RunInfo
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$RunInfo,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this RunInfo to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Test.
 */
declare type api$ITest = {|
  /**
   * Test id
   */
  id?: number | null,

  /**
   * Test instructions
   */
  instructions?: (api$Instruction | api$IInstruction)[] | null,
|};

/**
 * Represents a Test.
 */
declare class api$Test {
  /**
   * Constructs a new Test.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ITest): this;

  /**
   * Test id.
   */
  id: number;

  /**
   * Test instructions.
   */
  instructions: api$Instruction[];

  /**
   * Creates a new Test instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Test instance
   */
  static create(properties?: api$ITest): api$Test;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Test message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(message: api$Test, writer?: $protobuf.Writer): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Test message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Test,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Test message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Test
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Test;

  /**
   * Decodes a Test message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Test
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Test;

  /**
   * Verifies a Test message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Test message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Test
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Test;

  /**
   * Creates a plain object from a Test message. Also converts values to other types if specified.
   * @param message Test
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Test,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Test to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an Instruction.
 */
declare type api$IInstruction = {|
  /**
   * Instruction id
   */
  id?: number | null,

  /**
   * Instruction input
   */
  input?: api$InputInstruction | api$IInputInstruction | null,

  /**
   * Instruction output
   */
  output?: api$OutputInstruction | api$IOutputInstruction | null,
|};

/**
 * Represents an Instruction.
 */
declare class api$Instruction {
  /**
   * Constructs a new Instruction.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IInstruction): this;

  /**
   * Instruction id.
   */
  id: number;

  /**
   * Instruction input.
   */
  input?: api$InputInstruction | null;

  /**
   * Instruction output.
   */
  output?: api$OutputInstruction | null;

  /**
   * Instruction body.
   */
  body?: "input" | "output";

  /**
   * Creates a new Instruction instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Instruction instance
   */
  static create(properties?: api$IInstruction): api$Instruction;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Instruction message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Instruction,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Instruction message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Instruction,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an Instruction message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Instruction
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Instruction;

  /**
   * Decodes an Instruction message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Instruction
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$Instruction;

  /**
   * Verifies an Instruction message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an Instruction message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Instruction
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Instruction;

  /**
   * Creates a plain object from an Instruction message. Also converts values to other types if specified.
   * @param message Instruction
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Instruction,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Instruction to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an InputInstruction.
 */
declare type api$IInputInstruction = {|
  /**
   * InputInstruction input
   */
  input?: string | null,
|};

/**
 * Represents an InputInstruction.
 */
declare class api$InputInstruction {
  /**
   * Constructs a new InputInstruction.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IInputInstruction): this;

  /**
   * InputInstruction input.
   */
  input: string;

  /**
   * Creates a new InputInstruction instance using the specified properties.
   * @param [properties] Properties to set
   * @returns InputInstruction instance
   */
  static create(properties?: api$IInputInstruction): api$InputInstruction;

  /**
   * [object Object],[object Object],[object Object]
   * @param message InputInstruction message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$InputInstruction,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message InputInstruction message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$InputInstruction,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an InputInstruction message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns InputInstruction
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$InputInstruction;

  /**
   * Decodes an InputInstruction message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns InputInstruction
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$InputInstruction;

  /**
   * Verifies an InputInstruction message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an InputInstruction message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns InputInstruction
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$InputInstruction;

  /**
   * Creates a plain object from an InputInstruction message. Also converts values to other types if specified.
   * @param message InputInstruction
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$InputInstruction,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this InputInstruction to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an OutputInstruction.
 */
declare type api$IOutputInstruction = {|
  /**
   * OutputInstruction timeout
   */
  timeout?: google$protobuf$Duration | google$protobuf$IDuration | null,

  /**
   * OutputInstruction regex
   */
  regex?: api$RegexMatchOptions | api$IRegexMatchOptions | null,

  /**
   * OutputInstruction exact
   */
  exact?: api$ExactMatchOptions | api$IExactMatchOptions | null,

  /**
   * OutputInstruction match
   */
  match?: api$MatchMatchOptions | api$IMatchMatchOptions | null,

  /**
   * OutputInstruction compatibility
   */
  compatibility?:
    | api$CompatibilityMatchOptions
    | api$ICompatibilityMatchOptions
    | null,
|};

/**
 * Represents an OutputInstruction.
 */
declare class api$OutputInstruction {
  /**
   * Constructs a new OutputInstruction.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IOutputInstruction): this;

  /**
   * OutputInstruction timeout.
   */
  timeout?: google$protobuf$Duration | null;

  /**
   * OutputInstruction regex.
   */
  regex?: api$RegexMatchOptions | null;

  /**
   * OutputInstruction exact.
   */
  exact?: api$ExactMatchOptions | null;

  /**
   * OutputInstruction match.
   */
  match?: api$MatchMatchOptions | null;

  /**
   * OutputInstruction compatibility.
   */
  compatibility?: api$CompatibilityMatchOptions | null;

  /**
   * OutputInstruction matchOptions.
   */
  matchOptions?: "regex" | "exact" | "match" | "compatibility";

  /**
   * Creates a new OutputInstruction instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OutputInstruction instance
   */
  static create(properties?: api$IOutputInstruction): api$OutputInstruction;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OutputInstruction message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$OutputInstruction,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OutputInstruction message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$OutputInstruction,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an OutputInstruction message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OutputInstruction
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$OutputInstruction;

  /**
   * Decodes an OutputInstruction message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OutputInstruction
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$OutputInstruction;

  /**
   * Verifies an OutputInstruction message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an OutputInstruction message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OutputInstruction
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$OutputInstruction;

  /**
   * Creates a plain object from an OutputInstruction message. Also converts values to other types if specified.
   * @param message OutputInstruction
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$OutputInstruction,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OutputInstruction to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a RegexMatchOptions.
 */
declare type api$IRegexMatchOptions = {|
  /**
   * RegexMatchOptions expression
   */
  expression?: string | null,
|};

/**
 * Represents a RegexMatchOptions.
 */
declare class api$RegexMatchOptions {
  /**
   * Constructs a new RegexMatchOptions.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IRegexMatchOptions): this;

  /**
   * RegexMatchOptions expression.
   */
  expression: string;

  /**
   * Creates a new RegexMatchOptions instance using the specified properties.
   * @param [properties] Properties to set
   * @returns RegexMatchOptions instance
   */
  static create(properties?: api$IRegexMatchOptions): api$RegexMatchOptions;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RegexMatchOptions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$RegexMatchOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RegexMatchOptions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$RegexMatchOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a RegexMatchOptions message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns RegexMatchOptions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$RegexMatchOptions;

  /**
   * Decodes a RegexMatchOptions message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns RegexMatchOptions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$RegexMatchOptions;

  /**
   * Verifies a RegexMatchOptions message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a RegexMatchOptions message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns RegexMatchOptions
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$RegexMatchOptions;

  /**
   * Creates a plain object from a RegexMatchOptions message. Also converts values to other types if specified.
   * @param message RegexMatchOptions
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$RegexMatchOptions,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this RegexMatchOptions to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an ExactMatchOptions.
 */
declare type api$IExactMatchOptions = {|
  /**
   * ExactMatchOptions expected
   */
  expected?: string | null,

  /**
   * ExactMatchOptions allowTrailingNewline
   */
  allowTrailingNewline?: boolean | null,
|};

/**
 * Represents an ExactMatchOptions.
 */
declare class api$ExactMatchOptions {
  /**
   * Constructs a new ExactMatchOptions.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IExactMatchOptions): this;

  /**
   * ExactMatchOptions expected.
   */
  expected: string;

  /**
   * ExactMatchOptions allowTrailingNewline.
   */
  allowTrailingNewline: boolean;

  /**
   * Creates a new ExactMatchOptions instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ExactMatchOptions instance
   */
  static create(properties?: api$IExactMatchOptions): api$ExactMatchOptions;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ExactMatchOptions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ExactMatchOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ExactMatchOptions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ExactMatchOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an ExactMatchOptions message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ExactMatchOptions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ExactMatchOptions;

  /**
   * Decodes an ExactMatchOptions message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ExactMatchOptions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ExactMatchOptions;

  /**
   * Verifies an ExactMatchOptions message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an ExactMatchOptions message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ExactMatchOptions
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ExactMatchOptions;

  /**
   * Creates a plain object from an ExactMatchOptions message. Also converts values to other types if specified.
   * @param message ExactMatchOptions
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ExactMatchOptions,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ExactMatchOptions to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a MatchMatchOptions.
 */
declare type api$IMatchMatchOptions = {|
  /**
   * MatchMatchOptions expected
   */
  expected?: string | null,

  /**
   * MatchMatchOptions ignoreTrailingWhitespace
   */
  ignoreTrailingWhitespace?: boolean | null,
|};

/**
 * Represents a MatchMatchOptions.
 */
declare class api$MatchMatchOptions {
  /**
   * Constructs a new MatchMatchOptions.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IMatchMatchOptions): this;

  /**
   * MatchMatchOptions expected.
   */
  expected: string;

  /**
   * MatchMatchOptions ignoreTrailingWhitespace.
   */
  ignoreTrailingWhitespace: boolean;

  /**
   * Creates a new MatchMatchOptions instance using the specified properties.
   * @param [properties] Properties to set
   * @returns MatchMatchOptions instance
   */
  static create(properties?: api$IMatchMatchOptions): api$MatchMatchOptions;

  /**
   * [object Object],[object Object],[object Object]
   * @param message MatchMatchOptions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$MatchMatchOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message MatchMatchOptions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$MatchMatchOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a MatchMatchOptions message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns MatchMatchOptions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$MatchMatchOptions;

  /**
   * Decodes a MatchMatchOptions message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns MatchMatchOptions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$MatchMatchOptions;

  /**
   * Verifies a MatchMatchOptions message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a MatchMatchOptions message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns MatchMatchOptions
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$MatchMatchOptions;

  /**
   * Creates a plain object from a MatchMatchOptions message. Also converts values to other types if specified.
   * @param message MatchMatchOptions
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$MatchMatchOptions,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this MatchMatchOptions to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a CompatibilityMatchOptions.
 */
declare type api$ICompatibilityMatchOptions = {|
  /**
   * CompatibilityMatchOptions expected
   */
  expected?: string | null,
|};

/**
 * Represents a CompatibilityMatchOptions.
 */
declare class api$CompatibilityMatchOptions {
  /**
   * Constructs a new CompatibilityMatchOptions.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ICompatibilityMatchOptions): this;

  /**
   * CompatibilityMatchOptions expected.
   */
  expected: string;

  /**
   * Creates a new CompatibilityMatchOptions instance using the specified properties.
   * @param [properties] Properties to set
   * @returns CompatibilityMatchOptions instance
   */
  static create(
    properties?: api$ICompatibilityMatchOptions
  ): api$CompatibilityMatchOptions;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CompatibilityMatchOptions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$CompatibilityMatchOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CompatibilityMatchOptions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$CompatibilityMatchOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a CompatibilityMatchOptions message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns CompatibilityMatchOptions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$CompatibilityMatchOptions;

  /**
   * Decodes a CompatibilityMatchOptions message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns CompatibilityMatchOptions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$CompatibilityMatchOptions;

  /**
   * Verifies a CompatibilityMatchOptions message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a CompatibilityMatchOptions message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns CompatibilityMatchOptions
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$CompatibilityMatchOptions;

  /**
   * Creates a plain object from a CompatibilityMatchOptions message. Also converts values to other types if specified.
   * @param message CompatibilityMatchOptions
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$CompatibilityMatchOptions,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this CompatibilityMatchOptions to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Status enum.
 */

declare var api$Status: {|
  +Ready: 0, // 0
  +Building: 1, // 1
  +Running: 2, // 2
|};

/**
 * Properties of a Response.
 */
declare type api$IResponse = {|
  /**
   * Response error
   */
  error?: api$Error | api$IError | null,

  /**
   * Response testResult
   */
  testResult?: api$TestResult | api$ITestResult | null,

  /**
   * Response instructionResult
   */
  instructionResult?: api$InstructionResult | api$IInstructionResult | null,

  /**
   * Response status
   */
  status?: $Values<typeof api$Status> | null,
|};

/**
 * Represents a Response.
 */
declare class api$Response {
  /**
   * Constructs a new Response.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IResponse): this;

  /**
   * Response error.
   */
  error?: api$Error | null;

  /**
   * Response testResult.
   */
  testResult?: api$TestResult | null;

  /**
   * Response instructionResult.
   */
  instructionResult?: api$InstructionResult | null;

  /**
   * Response status.
   */
  status?: $Values<typeof api$Status> | null;

  /**
   * Response body.
   */
  body?: "error" | "testResult" | "instructionResult" | "status";

  /**
   * Creates a new Response instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Response instance
   */
  static create(properties?: api$IResponse): api$Response;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Response message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Response,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Response message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Response,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Response message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Response
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Response;

  /**
   * Decodes a Response message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Response
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Response;

  /**
   * Verifies a Response message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Response message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Response
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Response;

  /**
   * Creates a plain object from a Response message. Also converts values to other types if specified.
   * @param message Response
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Response,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Response to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a TestResult.
 */
declare type api$ITestResult = {|
  /**
   * TestResult testId
   */
  testId?: number | null,

  /**
   * TestResult passed
   */
  passed?: api$TestResult$Passed | api$TestResult$IPassed | null,

  /**
   * TestResult failed
   */
  failed?: api$TestResult$Failed | api$TestResult$IFailed | null,

  /**
   * TestResult error
   */
  error?: api$Error | api$IError | null,
|};

/**
 * Represents a TestResult.
 */
declare class api$TestResult {
  /**
   * Constructs a new TestResult.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ITestResult): this;

  /**
   * TestResult testId.
   */
  testId: number;

  /**
   * TestResult passed.
   */
  passed?: api$TestResult$Passed | null;

  /**
   * TestResult failed.
   */
  failed?: api$TestResult$Failed | null;

  /**
   * TestResult error.
   */
  error?: api$Error | null;

  /**
   * TestResult body.
   */
  body?: "passed" | "failed" | "error";

  /**
   * Creates a new TestResult instance using the specified properties.
   * @param [properties] Properties to set
   * @returns TestResult instance
   */
  static create(properties?: api$ITestResult): api$TestResult;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TestResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$TestResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TestResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$TestResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a TestResult message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns TestResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$TestResult;

  /**
   * Decodes a TestResult message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns TestResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$TestResult;

  /**
   * Verifies a TestResult message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a TestResult message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns TestResult
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$TestResult;

  /**
   * Creates a plain object from a TestResult message. Also converts values to other types if specified.
   * @param message TestResult
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$TestResult,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this TestResult to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static IPassed: Class<api$TestResult$IPassed>;
  static IFailed: Class<api$TestResult$IFailed>;
  static Passed: typeof api$TestResult$Passed;
  static Failed: typeof api$TestResult$Failed;
}

/**
 * Properties of a Passed.
 */
declare type api$TestResult$IPassed = {||};

/**
 * Represents a Passed.
 */
declare class api$TestResult$Passed {
  /**
   * Constructs a new Passed.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$TestResult$IPassed): this;

  /**
   * Creates a new Passed instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Passed instance
   */
  static create(properties?: api$TestResult$IPassed): api$TestResult$Passed;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Passed message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$TestResult$Passed,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Passed message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$TestResult$Passed,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Passed message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Passed
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$TestResult$Passed;

  /**
   * Decodes a Passed message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Passed
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$TestResult$Passed;

  /**
   * Verifies a Passed message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Passed message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Passed
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$TestResult$Passed;

  /**
   * Creates a plain object from a Passed message. Also converts values to other types if specified.
   * @param message Passed
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$TestResult$Passed,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Passed to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Failed.
 */
declare type api$TestResult$IFailed = {||};

/**
 * Represents a Failed.
 */
declare class api$TestResult$Failed {
  /**
   * Constructs a new Failed.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$TestResult$IFailed): this;

  /**
   * Creates a new Failed instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Failed instance
   */
  static create(properties?: api$TestResult$IFailed): api$TestResult$Failed;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Failed message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$TestResult$Failed,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Failed message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$TestResult$Failed,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Failed message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Failed
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$TestResult$Failed;

  /**
   * Decodes a Failed message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Failed
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$TestResult$Failed;

  /**
   * Verifies a Failed message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Failed message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Failed
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$TestResult$Failed;

  /**
   * Creates a plain object from a Failed message. Also converts values to other types if specified.
   * @param message Failed
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$TestResult$Failed,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Failed to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an InstructionResult.
 */
declare type api$IInstructionResult = {|
  /**
   * InstructionResult instructionId
   */
  instructionId?: number | null,

  /**
   * InstructionResult passed
   */
  passed?: api$InstructionResult$Passed | api$InstructionResult$IPassed | null,

  /**
   * InstructionResult failed
   */
  failed?: api$InstructionResult$Failed | api$InstructionResult$IFailed | null,

  /**
   * InstructionResult timeout
   */
  timeout?:
    | api$InstructionResult$Timeout
    | api$InstructionResult$ITimeout
    | null,

  /**
   * InstructionResult error
   */
  error?: api$Error | api$IError | null,
|};

/**
 * Represents an InstructionResult.
 */
declare class api$InstructionResult {
  /**
   * Constructs a new InstructionResult.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IInstructionResult): this;

  /**
   * InstructionResult instructionId.
   */
  instructionId: number;

  /**
   * InstructionResult passed.
   */
  passed?: api$InstructionResult$Passed | null;

  /**
   * InstructionResult failed.
   */
  failed?: api$InstructionResult$Failed | null;

  /**
   * InstructionResult timeout.
   */
  timeout?: api$InstructionResult$Timeout | null;

  /**
   * InstructionResult error.
   */
  error?: api$Error | null;

  /**
   * InstructionResult body.
   */
  body?: "passed" | "failed" | "timeout" | "error";

  /**
   * Creates a new InstructionResult instance using the specified properties.
   * @param [properties] Properties to set
   * @returns InstructionResult instance
   */
  static create(properties?: api$IInstructionResult): api$InstructionResult;

  /**
   * [object Object],[object Object],[object Object]
   * @param message InstructionResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$InstructionResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message InstructionResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$InstructionResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an InstructionResult message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns InstructionResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$InstructionResult;

  /**
   * Decodes an InstructionResult message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns InstructionResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$InstructionResult;

  /**
   * Verifies an InstructionResult message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an InstructionResult message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns InstructionResult
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$InstructionResult;

  /**
   * Creates a plain object from an InstructionResult message. Also converts values to other types if specified.
   * @param message InstructionResult
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$InstructionResult,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this InstructionResult to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static IPassed: Class<api$InstructionResult$IPassed>;
  static IFailed: Class<api$InstructionResult$IFailed>;
  static ITimeout: Class<api$InstructionResult$ITimeout>;
  static Passed: typeof api$InstructionResult$Passed;
  static Failed: typeof api$InstructionResult$Failed;
  static Timeout: typeof api$InstructionResult$Timeout;
}

/**
 * Properties of a Passed.
 */
declare type api$InstructionResult$IPassed = {|
  /**
   * Passed output
   */
  output?: string | null,
|};

/**
 * Represents a Passed.
 */
declare class api$InstructionResult$Passed {
  /**
   * Constructs a new Passed.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$InstructionResult$IPassed): this;

  /**
   * Passed output.
   */
  output: string;

  /**
   * Creates a new Passed instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Passed instance
   */
  static create(
    properties?: api$InstructionResult$IPassed
  ): api$InstructionResult$Passed;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Passed message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$InstructionResult$Passed,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Passed message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$InstructionResult$Passed,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Passed message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Passed
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$InstructionResult$Passed;

  /**
   * Decodes a Passed message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Passed
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$InstructionResult$Passed;

  /**
   * Verifies a Passed message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Passed message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Passed
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$InstructionResult$Passed;

  /**
   * Creates a plain object from a Passed message. Also converts values to other types if specified.
   * @param message Passed
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$InstructionResult$Passed,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Passed to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Failed.
 */
declare type api$InstructionResult$IFailed = {|
  /**
   * Failed output
   */
  output?: string | null,
|};

/**
 * Represents a Failed.
 */
declare class api$InstructionResult$Failed {
  /**
   * Constructs a new Failed.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$InstructionResult$IFailed): this;

  /**
   * Failed output.
   */
  output: string;

  /**
   * Creates a new Failed instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Failed instance
   */
  static create(
    properties?: api$InstructionResult$IFailed
  ): api$InstructionResult$Failed;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Failed message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$InstructionResult$Failed,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Failed message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$InstructionResult$Failed,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Failed message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Failed
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$InstructionResult$Failed;

  /**
   * Decodes a Failed message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Failed
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$InstructionResult$Failed;

  /**
   * Verifies a Failed message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Failed message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Failed
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$InstructionResult$Failed;

  /**
   * Creates a plain object from a Failed message. Also converts values to other types if specified.
   * @param message Failed
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$InstructionResult$Failed,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Failed to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Timeout.
 */
declare type api$InstructionResult$ITimeout = {|
  /**
   * Timeout output
   */
  output?: string | null,
|};

/**
 * Represents a Timeout.
 */
declare class api$InstructionResult$Timeout {
  /**
   * Constructs a new Timeout.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$InstructionResult$ITimeout): this;

  /**
   * Timeout output.
   */
  output: string;

  /**
   * Creates a new Timeout instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Timeout instance
   */
  static create(
    properties?: api$InstructionResult$ITimeout
  ): api$InstructionResult$Timeout;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Timeout message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$InstructionResult$Timeout,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Timeout message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$InstructionResult$Timeout,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Timeout message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Timeout
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$InstructionResult$Timeout;

  /**
   * Decodes a Timeout message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Timeout
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$InstructionResult$Timeout;

  /**
   * Verifies a Timeout message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Timeout message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Timeout
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$InstructionResult$Timeout;

  /**
   * Creates a plain object from a Timeout message. Also converts values to other types if specified.
   * @param message Timeout
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$InstructionResult$Timeout,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Timeout to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an Error.
 */
declare type api$IError = {|
  /**
   * Error message
   */
  message?: string | null,

  /**
   * Error stderr
   */
  stderr?: string | null,
|};

/**
 * Represents an Error.
 */
declare class api$Error {
  /**
   * Constructs a new Error.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IError): this;

  /**
   * Error message.
   */
  message: string;

  /**
   * Error stderr.
   */
  stderr: string;

  /**
   * Creates a new Error instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Error instance
   */
  static create(properties?: api$IError): api$Error;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Error message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Error,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Error message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Error,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an Error message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Error
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Error;

  /**
   * Decodes an Error message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Error
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Error;

  /**
   * Verifies an Error message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an Error message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Error
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Error;

  /**
   * Creates a plain object from an Error message. Also converts values to other types if specified.
   * @param message Error
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Error,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Error to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}
declare var google: typeof npm$namespace$google;

declare var npm$namespace$google: {|
  protobuf: typeof npm$namespace$google$protobuf,
|};

declare var npm$namespace$google$protobuf: {|
  IDuration: Class<google$protobuf$IDuration>,
  Duration: typeof google$protobuf$Duration,
|};

/**
 * Properties of a Duration.
 */
declare type google$protobuf$IDuration = {|
  /**
   * Duration seconds
   */
  seconds?: number | null,

  /**
   * Duration nanos
   */
  nanos?: number | null,
|};

/**
 * Represents a Duration.
 */
declare class google$protobuf$Duration {
  /**
   * Constructs a new Duration.
   * @param [properties] Properties to set
   */
  constructor(properties?: google$protobuf$IDuration): this;

  /**
   * Duration seconds.
   */
  seconds: number;

  /**
   * Duration nanos.
   */
  nanos: number;

  /**
   * Creates a new Duration instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Duration instance
   */
  static create(
    properties?: google$protobuf$IDuration
  ): google$protobuf$Duration;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Duration message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: google$protobuf$Duration,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Duration message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: google$protobuf$Duration,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Duration message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Duration
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$Duration;

  /**
   * Decodes a Duration message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Duration
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$Duration;

  /**
   * Verifies a Duration message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Duration message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Duration
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): google$protobuf$Duration;

  /**
   * Creates a plain object from a Duration message. Also converts values to other types if specified.
   * @param message Duration
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: google$protobuf$Duration,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Duration to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}
