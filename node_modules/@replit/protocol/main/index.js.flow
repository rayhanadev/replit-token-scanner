/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.20.0
 * @flow
 */

import * as $protobuf from "protobufjs";
export var api = npm$namespace$api;

declare var npm$namespace$api: {|
  FileAuthMethod: typeof api$FileAuthMethod,
  State: typeof api$State,
  TokenVersion: typeof api$TokenVersion,
  FlagClaim: typeof api$FlagClaim,
  ICommand: Class<api$ICommand>,
  IStartLSP: Class<api$IStartLSP>,
  IAudio: Class<api$IAudio>,
  IAudio2: Class<api$IAudio2>,
  IPreconditions: Class<api$IPreconditions>,
  IReadMetaRequest: Class<api$IReadMetaRequest>,
  IReadMetaResponse: Class<api$IReadMetaResponse>,
  IWriteMetaRequest: Class<api$IWriteMetaRequest>,
  IWriteMetaResponse: Class<api$IWriteMetaResponse>,
  IAppendMetaRequest: Class<api$IAppendMetaRequest>,
  IAppendMetaResponse: Class<api$IAppendMetaResponse>,
  IBootStatus: Class<api$IBootStatus>,
  IPid1Config: Class<api$IPid1Config>,
  IFSLock: Class<api$IFSLock>,
  IFSSnapshot: Class<api$IFSSnapshot>,
  IFSSnapshotEvent: Class<api$IFSSnapshotEvent>,
  ISnapshotEvent: Class<api$ISnapshotEvent>,
  ISubscribeFile: Class<api$ISubscribeFile>,
  IFileEvent: Class<api$IFileEvent>,
  IFlush: Class<api$IFlush>,
  IOTLinkFile: Class<api$IOTLinkFile>,
  IOTLinkFileResponse: Class<api$IOTLinkFileResponse>,
  IAuth: Class<api$IAuth>,
  IVCREntry: Class<api$IVCREntry>,
  IStartVCR: Class<api$IStartVCR>,
  IReadVCR: Class<api$IReadVCR>,
  IVCRLog: Class<api$IVCRLog>,
  IExecInfo: Class<api$IExecInfo>,
  IDebug: Class<api$IDebug>,
  IFileAuthReq: Class<api$IFileAuthReq>,
  IMultiFileAuthRes: Class<api$IMultiFileAuthRes>,
  IFileAuthRes: Class<api$IFileAuthRes>,
  IListObjects: Class<api$IListObjects>,
  IListObjectsResp: Class<api$IListObjectsResp>,
  IDisconnect: Class<api$IDisconnect>,
  ISend: Class<api$ISend>,
  IRecv: Class<api$IRecv>,
  IConnect: Class<api$IConnect>,
  IHint: Class<api$IHint>,
  IPing: Class<api$IPing>,
  IPong: Class<api$IPong>,
  IHello: Class<api$IHello>,
  IGoodbye: Class<api$IGoodbye>,
  ICheckChanges: Class<api$ICheckChanges>,
  IEnsurePackages: Class<api$IEnsurePackages>,
  IStart: Class<api$IStart>,
  IDebugStatus: Class<api$IDebugStatus>,
  IStackFrame: Class<api$IStackFrame>,
  IContainedTest: Class<api$IContainedTest>,
  ITestResult: Class<api$ITestResult>,
  ITestFailure: Class<api$ITestFailure>,
  IResizeTerm: Class<api$IResizeTerm>,
  ISaneTerm: Class<api$ISaneTerm>,
  ILintResults: Class<api$ILintResults>,
  ILintResult: Class<api$ILintResult>,
  IOK: Class<api$IOK>,
  IMove: Class<api$IMove>,
  IFiles: Class<api$IFiles>,
  IStatResult: Class<api$IStatResult>,
  IFile: Class<api$IFile>,
  ITransfer: Class<api$ITransfer>,
  ITransferStart: Class<api$ITransferStart>,
  ITransferChunk: Class<api$ITransferChunk>,
  ITransferComplete: Class<api$ITransferComplete>,
  IClear: Class<api$IClear>,
  IToast: Class<api$IToast>,
  IProtocolError: Class<api$IProtocolError>,
  IRedirect: Class<api$IRedirect>,
  IAlwaysOn: Class<api$IAlwaysOn>,
  IRunMain: Class<api$IRunMain>,
  IOpenChannel: Class<api$IOpenChannel>,
  IOpenChannelRes: Class<api$IOpenChannelRes>,
  ICloseChannel: Class<api$ICloseChannel>,
  ICloseChannelRes: Class<api$ICloseChannelRes>,
  IContainerState: Class<api$IContainerState>,
  IPortOpen: Class<api$IPortOpen>,
  IPortClose: Class<api$IPortClose>,
  IOTFetchRequest: Class<api$IOTFetchRequest>,
  IOTFetchResponse: Class<api$IOTFetchResponse>,
  IOTTransformSelectionRequest: Class<api$IOTTransformSelectionRequest>,
  IOTTransformSelectionResponse: Class<api$IOTTransformSelectionResponse>,
  IOTPacket: Class<api$IOTPacket>,
  IOTRuneTransformOp: Class<api$IOTRuneTransformOp>,
  IOTStatus: Class<api$IOTStatus>,
  IOTCursor: Class<api$IOTCursor>,
  IChatMessage: Class<api$IChatMessage>,
  IChatTyping: Class<api$IChatTyping>,
  IUser: Class<api$IUser>,
  IRoster: Class<api$IRoster>,
  IOpenFile: Class<api$IOpenFile>,
  IFileOpened: Class<api$IFileOpened>,
  IUpdateSessionTimestamp: Class<api$IUpdateSessionTimestamp>,
  ISessionTimestampUpdated: Class<api$ISessionTimestampUpdated>,
  IFollowUser: Class<api$IFollowUser>,
  IUnfollowUser: Class<api$IUnfollowUser>,
  IExec: Class<api$IExec>,
  IPackage: Class<api$IPackage>,
  IPackageSearch: Class<api$IPackageSearch>,
  IPackageSearchResp: Class<api$IPackageSearchResp>,
  IPackageInfo: Class<api$IPackageInfo>,
  IPackageInfoResp: Class<api$IPackageInfoResp>,
  IPackageAdd: Class<api$IPackageAdd>,
  IPackageRemove: Class<api$IPackageRemove>,
  IPackageInstall: Class<api$IPackageInstall>,
  IPackageListSpecfile: Class<api$IPackageListSpecfile>,
  IPackageListSpecfileResp: Class<api$IPackageListSpecfileResp>,
  IPackageCacheSave: Class<api$IPackageCacheSave>,
  IChatScrollback: Class<api$IChatScrollback>,
  IMetrics: Class<api$IMetrics>,
  IPprofRequest: Class<api$IPprofRequest>,
  IPprofAllocsProfileRequest: Class<api$IPprofAllocsProfileRequest>,
  IPprofBlockProfileRequest: Class<api$IPprofBlockProfileRequest>,
  IPprofCpuProfileRequest: Class<api$IPprofCpuProfileRequest>,
  IPprofHeapProfileRequest: Class<api$IPprofHeapProfileRequest>,
  IPprofMutexProfileRequest: Class<api$IPprofMutexProfileRequest>,
  IPprofResponse: Class<api$IPprofResponse>,
  IPTYConfig: Class<api$IPTYConfig>,
  IDebugMain: Class<api$IDebugMain>,
  IDebugMainReply: Class<api$IDebugMainReply>,
  IDebugState: Class<api$IDebugState>,
  IDebugInput: Class<api$IDebugInput>,
  IDebugOutput: Class<api$IDebugOutput>,
  IDebugStop: Class<api$IDebugStop>,
  IDebugLeave: Class<api$IDebugLeave>,
  IDebugSessions: Class<api$IDebugSessions>,
  IDotReplitGetRequest: Class<api$IDotReplitGetRequest>,
  IDotReplitGetResponse: Class<api$IDotReplitGetResponse>,
  IRunConfigGetRequest: Class<api$IRunConfigGetRequest>,
  IRunConfigGetResponse: Class<api$IRunConfigGetResponse>,
  IDotReplitUpdateOp: Class<api$IDotReplitUpdateOp>,
  IDotReplitUpdateRequest: Class<api$IDotReplitUpdateRequest>,
  IDotReplitUpdateResponse: Class<api$IDotReplitUpdateResponse>,
  IDebugAddBreakpointRequest: Class<api$IDebugAddBreakpointRequest>,
  IDebugUpdateBreakpointRequest: Class<api$IDebugUpdateBreakpointRequest>,
  IDebugRemoveBreakpointRequest: Class<api$IDebugRemoveBreakpointRequest>,
  IDebugBreakpointEvent: Class<api$IDebugBreakpointEvent>,
  IDebugBreakpoint: Class<api$IDebugBreakpoint>,
  IDotReplit: Class<api$IDotReplit>,
  IDotReplitInterp: Class<api$IDotReplitInterp>,
  IDotReplitLanguage: Class<api$IDotReplitLanguage>,
  ILanguageServerConfig: Class<api$ILanguageServerConfig>,
  IDotReplitPackager: Class<api$IDotReplitPackager>,
  IDotReplitPackagerFeatures: Class<api$IDotReplitPackagerFeatures>,
  IDotReplitUnitTest: Class<api$IDotReplitUnitTest>,
  IDebuggerConfig: Class<api$IDebuggerConfig>,
  IProxyGoingAway: Class<api$IProxyGoingAway>,
  IFirewallDenied: Class<api$IFirewallDenied>,
  IRepl: Class<api$IRepl>,
  IResourceLimits: Class<api$IResourceLimits>,
  IPermissions: Class<api$IPermissions>,
  IReplToken: Class<api$IReplToken>,
  ITLSCertificate: Class<api$ITLSCertificate>,
  IReplTransfer: Class<api$IReplTransfer>,
  IAllowReplRequest: Class<api$IAllowReplRequest>,
  IClusterMetadata: Class<api$IClusterMetadata>,
  IEvictReplRequest: Class<api$IEvictReplRequest>,
  IEvictReplResponse: Class<api$IEvictReplResponse>,
  IGovalSigningAuthority: Class<api$IGovalSigningAuthority>,
  ICertificateClaim: Class<api$ICertificateClaim>,
  IGovalCert: Class<api$IGovalCert>,
  IGovalToken: Class<api$IGovalToken>,
  Command: typeof api$Command,
  StartLSP: typeof api$StartLSP,
  Audio: typeof api$Audio,
  Audio2: typeof api$Audio2,
  Preconditions: typeof api$Preconditions,
  ReadMetaRequest: typeof api$ReadMetaRequest,
  ReadMetaResponse: typeof api$ReadMetaResponse,
  WriteMetaRequest: typeof api$WriteMetaRequest,
  WriteMetaResponse: typeof api$WriteMetaResponse,
  AppendMetaRequest: typeof api$AppendMetaRequest,
  AppendMetaResponse: typeof api$AppendMetaResponse,
  BootStatus: typeof api$BootStatus,
  Pid1Config: typeof api$Pid1Config,
  FSLock: typeof api$FSLock,
  FSSnapshot: typeof api$FSSnapshot,
  FSSnapshotEvent: typeof api$FSSnapshotEvent,
  SnapshotEvent: typeof api$SnapshotEvent,
  SubscribeFile: typeof api$SubscribeFile,
  FileEvent: typeof api$FileEvent,
  Flush: typeof api$Flush,
  OTLinkFile: typeof api$OTLinkFile,
  OTLinkFileResponse: typeof api$OTLinkFileResponse,
  Auth: typeof api$Auth,
  VCREntry: typeof api$VCREntry,
  StartVCR: typeof api$StartVCR,
  ReadVCR: typeof api$ReadVCR,
  VCRLog: typeof api$VCRLog,
  ExecInfo: typeof api$ExecInfo,
  Debug: typeof api$Debug,
  FileAuthReq: typeof api$FileAuthReq,
  MultiFileAuthRes: typeof api$MultiFileAuthRes,
  FileAuthRes: typeof api$FileAuthRes,
  ListObjects: typeof api$ListObjects,
  ListObjectsResp: typeof api$ListObjectsResp,
  Disconnect: typeof api$Disconnect,
  Send: typeof api$Send,
  Recv: typeof api$Recv,
  Connect: typeof api$Connect,
  Hint: typeof api$Hint,
  Ping: typeof api$Ping,
  Pong: typeof api$Pong,
  Hello: typeof api$Hello,
  Goodbye: typeof api$Goodbye,
  CheckChanges: typeof api$CheckChanges,
  EnsurePackages: typeof api$EnsurePackages,
  Start: typeof api$Start,
  DebugStatus: typeof api$DebugStatus,
  StackFrame: typeof api$StackFrame,
  ContainedTest: typeof api$ContainedTest,
  TestResult: typeof api$TestResult,
  TestFailure: typeof api$TestFailure,
  ResizeTerm: typeof api$ResizeTerm,
  SaneTerm: typeof api$SaneTerm,
  LintResults: typeof api$LintResults,
  LintResult: typeof api$LintResult,
  OK: typeof api$OK,
  Move: typeof api$Move,
  Files: typeof api$Files,
  StatResult: typeof api$StatResult,
  File: typeof api$File,
  Transfer: typeof api$Transfer,
  TransferStart: typeof api$TransferStart,
  TransferChunk: typeof api$TransferChunk,
  TransferComplete: typeof api$TransferComplete,
  Clear: typeof api$Clear,
  Toast: typeof api$Toast,
  ProtocolError: typeof api$ProtocolError,
  Redirect: typeof api$Redirect,
  AlwaysOn: typeof api$AlwaysOn,
  RunMain: typeof api$RunMain,
  OpenChannel: typeof api$OpenChannel,
  OpenChannelRes: typeof api$OpenChannelRes,
  CloseChannel: typeof api$CloseChannel,
  CloseChannelRes: typeof api$CloseChannelRes,
  ContainerState: typeof api$ContainerState,
  PortOpen: typeof api$PortOpen,
  PortClose: typeof api$PortClose,
  OTFetchRequest: typeof api$OTFetchRequest,
  OTFetchResponse: typeof api$OTFetchResponse,
  OTTransformSelectionRequest: typeof api$OTTransformSelectionRequest,
  OTTransformSelectionResponse: typeof api$OTTransformSelectionResponse,
  OTPacket: typeof api$OTPacket,
  OTRuneTransformOp: typeof api$OTRuneTransformOp,
  OTStatus: typeof api$OTStatus,
  OTCursor: typeof api$OTCursor,
  ChatMessage: typeof api$ChatMessage,
  ChatTyping: typeof api$ChatTyping,
  User: typeof api$User,
  Roster: typeof api$Roster,
  OpenFile: typeof api$OpenFile,
  FileOpened: typeof api$FileOpened,
  UpdateSessionTimestamp: typeof api$UpdateSessionTimestamp,
  SessionTimestampUpdated: typeof api$SessionTimestampUpdated,
  FollowUser: typeof api$FollowUser,
  UnfollowUser: typeof api$UnfollowUser,
  Exec: typeof api$Exec,
  Package: typeof api$Package,
  PackageSearch: typeof api$PackageSearch,
  PackageSearchResp: typeof api$PackageSearchResp,
  PackageInfo: typeof api$PackageInfo,
  PackageInfoResp: typeof api$PackageInfoResp,
  PackageAdd: typeof api$PackageAdd,
  PackageRemove: typeof api$PackageRemove,
  PackageInstall: typeof api$PackageInstall,
  PackageListSpecfile: typeof api$PackageListSpecfile,
  PackageListSpecfileResp: typeof api$PackageListSpecfileResp,
  PackageCacheSave: typeof api$PackageCacheSave,
  ChatScrollback: typeof api$ChatScrollback,
  Metrics: typeof api$Metrics,
  PprofRequest: typeof api$PprofRequest,
  PprofAllocsProfileRequest: typeof api$PprofAllocsProfileRequest,
  PprofBlockProfileRequest: typeof api$PprofBlockProfileRequest,
  PprofCpuProfileRequest: typeof api$PprofCpuProfileRequest,
  PprofHeapProfileRequest: typeof api$PprofHeapProfileRequest,
  PprofMutexProfileRequest: typeof api$PprofMutexProfileRequest,
  PprofResponse: typeof api$PprofResponse,
  PTYConfig: typeof api$PTYConfig,
  DebugMain: typeof api$DebugMain,
  DebugMainReply: typeof api$DebugMainReply,
  DebugState: typeof api$DebugState,
  DebugInput: typeof api$DebugInput,
  DebugOutput: typeof api$DebugOutput,
  DebugStop: typeof api$DebugStop,
  DebugLeave: typeof api$DebugLeave,
  DebugSessions: typeof api$DebugSessions,
  DotReplitGetRequest: typeof api$DotReplitGetRequest,
  DotReplitGetResponse: typeof api$DotReplitGetResponse,
  RunConfigGetRequest: typeof api$RunConfigGetRequest,
  RunConfigGetResponse: typeof api$RunConfigGetResponse,
  DotReplitUpdateOp: typeof api$DotReplitUpdateOp,
  DotReplitUpdateRequest: typeof api$DotReplitUpdateRequest,
  DotReplitUpdateResponse: typeof api$DotReplitUpdateResponse,
  DebugAddBreakpointRequest: typeof api$DebugAddBreakpointRequest,
  DebugUpdateBreakpointRequest: typeof api$DebugUpdateBreakpointRequest,
  DebugRemoveBreakpointRequest: typeof api$DebugRemoveBreakpointRequest,
  DebugBreakpointEvent: typeof api$DebugBreakpointEvent,
  DebugBreakpoint: typeof api$DebugBreakpoint,
  DotReplit: typeof api$DotReplit,
  DotReplitInterp: typeof api$DotReplitInterp,
  DotReplitLanguage: typeof api$DotReplitLanguage,
  LanguageServerConfig: typeof api$LanguageServerConfig,
  DotReplitPackager: typeof api$DotReplitPackager,
  DotReplitPackagerFeatures: typeof api$DotReplitPackagerFeatures,
  DotReplitUnitTest: typeof api$DotReplitUnitTest,
  DebuggerConfig: typeof api$DebuggerConfig,
  ProxyGoingAway: typeof api$ProxyGoingAway,
  FirewallDenied: typeof api$FirewallDenied,
  Repl: typeof api$Repl,
  ResourceLimits: typeof api$ResourceLimits,
  Permissions: typeof api$Permissions,
  ReplToken: typeof api$ReplToken,
  TLSCertificate: typeof api$TLSCertificate,
  ReplTransfer: typeof api$ReplTransfer,
  AllowReplRequest: typeof api$AllowReplRequest,
  ClusterMetadata: typeof api$ClusterMetadata,
  EvictReplRequest: typeof api$EvictReplRequest,
  EvictReplResponse: typeof api$EvictReplResponse,
  GovalSigningAuthority: typeof api$GovalSigningAuthority,
  CertificateClaim: typeof api$CertificateClaim,
  GovalCert: typeof api$GovalCert,
  GovalToken: typeof api$GovalToken,
|};

/**
 * Properties of a Command.
 */
declare type api$ICommand = {|
  /**
   * Command channel
   */
  channel?: number | null,

  /**
   * Command session
   */
  session?: number | null,

  /**
   * Command openChan
   */
  openChan?: api$OpenChannel | api$IOpenChannel | null,

  /**
   * Command openChanRes
   */
  openChanRes?: api$OpenChannelRes | api$IOpenChannelRes | null,

  /**
   * Command closeChan
   */
  closeChan?: api$CloseChannel | api$ICloseChannel | null,

  /**
   * Command closeChanRes
   */
  closeChanRes?: api$CloseChannelRes | api$ICloseChannelRes | null,

  /**
   * Command containerState
   */
  containerState?: api$ContainerState | api$IContainerState | null,

  /**
   * Command portOpen
   */
  portOpen?: api$PortOpen | api$IPortOpen | null,

  /**
   * Command portClose
   */
  portClose?: api$PortClose | api$IPortClose | null,

  /**
   * Command toast
   */
  toast?: api$Toast | api$IToast | null,

  /**
   * Command protocolError
   */
  protocolError?: api$ProtocolError | api$IProtocolError | null,

  /**
   * Command redirect
   */
  redirect?: api$Redirect | api$IRedirect | null,

  /**
   * Command alwaysOn
   */
  alwaysOn?: api$AlwaysOn | api$IAlwaysOn | null,

  /**
   * Command runMain
   */
  runMain?: api$RunMain | api$IRunMain | null,

  /**
   * Command clear
   */
  clear?: api$Clear | api$IClear | null,

  /**
   * Command eval
   */
  eval?: string | null,

  /**
   * Command result
   */
  result?: string | null,

  /**
   * Command input
   */
  input?: string | null,

  /**
   * Command output
   */
  output?: string | null,

  /**
   * Command error
   */
  error?: string | null,

  /**
   * Command stderr
   */
  stderr?: string | null,

  /**
   * Command log
   */
  log?: string | null,

  /**
   * Command saneTerm
   */
  saneTerm?: api$SaneTerm | api$ISaneTerm | null,

  /**
   * Command resizeTerm
   */
  resizeTerm?: api$ResizeTerm | api$IResizeTerm | null,

  /**
   * Command state
   */
  state?: $Values<typeof api$State> | null,

  /**
   * Command ok
   */
  ok?: api$OK | api$IOK | null,

  /**
   * Command persist
   */
  persist?: api$File | api$IFile | null,

  /**
   * Command persistMirror
   */
  persistMirror?: api$File | api$IFile | null,

  /**
   * Command write
   */
  write?: api$File | api$IFile | null,

  /**
   * Command remove
   */
  remove?: api$File | api$IFile | null,

  /**
   * Command move
   */
  move?: api$Move | api$IMove | null,

  /**
   * Command tryRemove
   */
  tryRemove?: api$File | api$IFile | null,

  /**
   * Command mkdir
   */
  mkdir?: api$File | api$IFile | null,

  /**
   * Command stat
   */
  stat?: api$File | api$IFile | null,

  /**
   * Command statRes
   */
  statRes?: api$StatResult | api$IStatResult | null,

  /**
   * Command transferStart
   */
  transferStart?: api$TransferStart | api$ITransferStart | null,

  /**
   * Command transferChunk
   */
  transferChunk?: api$TransferChunk | api$ITransferChunk | null,

  /**
   * Command transferComplete
   */
  transferComplete?: api$TransferComplete | api$ITransferComplete | null,

  /**
   * Command transferCancel
   */
  transferCancel?: api$Transfer | api$ITransfer | null,

  /**
   * Command transfer
   */
  transfer?: api$Transfer | api$ITransfer | null,

  /**
   * Command read
   */
  read?: api$File | api$IFile | null,

  /**
   * Command readdir
   */
  readdir?: api$File | api$IFile | null,

  /**
   * Command files
   */
  files?: api$Files | api$IFiles | null,

  /**
   * Command file
   */
  file?: api$File | api$IFile | null,

  /**
   * Command checkChanges
   */
  checkChanges?: api$CheckChanges | api$ICheckChanges | null,

  /**
   * Command changedFiles
   */
  changedFiles?: api$Files | api$IFiles | null,

  /**
   * Command lintResults
   */
  lintResults?: api$LintResults | api$ILintResults | null,

  /**
   * Command runContainedTest
   */
  runContainedTest?: api$ContainedTest | api$IContainedTest | null,

  /**
   * Command testResult
   */
  testResult?: api$TestResult | api$ITestResult | null,

  /**
   * Command debuggerStart
   */
  debuggerStart?: string | null,

  /**
   * Command debuggerStep
   */
  debuggerStep?: api$RunMain | api$IRunMain | null,

  /**
   * Command debuggerStatus
   */
  debuggerStatus?: api$DebugStatus | api$IDebugStatus | null,

  /**
   * Command ensurePackages
   */
  ensurePackages?: api$EnsurePackages | api$IEnsurePackages | null,

  /**
   * Command ping
   */
  ping?: api$Ping | api$IPing | null,

  /**
   * Command pong
   */
  pong?: api$Pong | api$IPong | null,

  /**
   * Command hello
   */
  hello?: api$Hello | api$IHello | null,

  /**
   * Command goodbye
   */
  goodbye?: api$Goodbye | api$IGoodbye | null,

  /**
   * Command proxyGoingAway
   */
  proxyGoingAway?: api$ProxyGoingAway | api$IProxyGoingAway | null,

  /**
   * Command hint
   */
  hint?: api$Hint | api$IHint | null,

  /**
   * Command connect
   */
  connect?: api$Connect | api$IConnect | null,

  /**
   * Command send
   */
  send?: api$Send | api$ISend | null,

  /**
   * Command recv
   */
  recv?: api$Recv | api$IRecv | null,

  /**
   * Command disconnect
   */
  disconnect?: api$Disconnect | api$IDisconnect | null,

  /**
   * Command fileAuthReq
   */
  fileAuthReq?: api$FileAuthReq | api$IFileAuthReq | null,

  /**
   * Command fileAuthRes
   */
  fileAuthRes?: api$FileAuthRes | api$IFileAuthRes | null,

  /**
   * Command mutliFileAuthRes
   */
  mutliFileAuthRes?: api$MultiFileAuthRes | api$IMultiFileAuthRes | null,

  /**
   * Command listObjects
   */
  listObjects?: api$ListObjects | api$IListObjects | null,

  /**
   * Command listObjectsResp
   */
  listObjectsResp?: api$ListObjectsResp | api$IListObjectsResp | null,

  /**
   * Command ot
   */
  ot?: api$OTPacket | api$IOTPacket | null,

  /**
   * Command otstatus
   */
  otstatus?: api$OTStatus | api$IOTStatus | null,

  /**
   * Command otLinkFile
   */
  otLinkFile?: api$OTLinkFile | api$IOTLinkFile | null,

  /**
   * Command otLinkFileResponse
   */
  otLinkFileResponse?: api$OTLinkFileResponse | api$IOTLinkFileResponse | null,

  /**
   * Command otNewCursor
   */
  otNewCursor?: api$OTCursor | api$IOTCursor | null,

  /**
   * Command otDeleteCursor
   */
  otDeleteCursor?: api$OTCursor | api$IOTCursor | null,

  /**
   * Command otFetchRequest
   */
  otFetchRequest?: api$OTFetchRequest | api$IOTFetchRequest | null,

  /**
   * Command otFetchResponse
   */
  otFetchResponse?: api$OTFetchResponse | api$IOTFetchResponse | null,

  /**
   * Command otTransformSelectionRequest
   */
  otTransformSelectionRequest?:
    | api$OTTransformSelectionRequest
    | api$IOTTransformSelectionRequest
    | null,

  /**
   * Command otTransformSelectionResponse
   */
  otTransformSelectionResponse?:
    | api$OTTransformSelectionResponse
    | api$IOTTransformSelectionResponse
    | null,

  /**
   * Command flush
   */
  flush?: api$Flush | api$IFlush | null,

  /**
   * Command debug
   */
  debug?: api$Debug | api$IDebug | null,

  /**
   * Command startVCR
   */
  startVCR?: api$StartVCR | api$IStartVCR | null,

  /**
   * Command readVCR
   */
  readVCR?: api$ReadVCR | api$IReadVCR | null,

  /**
   * Command VCRLog
   */
  VCRLog?: api$VCRLog | api$IVCRLog | null,

  /**
   * Command auth
   */
  auth?: api$Auth | api$IAuth | null,

  /**
   * Command execInfo
   */
  execInfo?: api$ExecInfo | api$IExecInfo | null,

  /**
   * Command subscribeFile
   */
  subscribeFile?: api$SubscribeFile | api$ISubscribeFile | null,

  /**
   * Command fileEvent
   */
  fileEvent?: api$FileEvent | api$IFileEvent | null,

  /**
   * Command roster
   */
  roster?: api$Roster | api$IRoster | null,

  /**
   * Command join
   */
  join?: api$User | api$IUser | null,

  /**
   * Command part
   */
  part?: api$User | api$IUser | null,

  /**
   * Command openFile
   */
  openFile?: api$OpenFile | api$IOpenFile | null,

  /**
   * Command fileOpened
   */
  fileOpened?: api$FileOpened | api$IFileOpened | null,

  /**
   * Command followUser
   */
  followUser?: api$FollowUser | api$IFollowUser | null,

  /**
   * Command unfollowUser
   */
  unfollowUser?: api$UnfollowUser | api$IUnfollowUser | null,

  /**
   * Command updateSessionTimestamp
   */
  updateSessionTimestamp?:
    | api$UpdateSessionTimestamp
    | api$IUpdateSessionTimestamp
    | null,

  /**
   * Command sessionTimestampUpdated
   */
  sessionTimestampUpdated?:
    | api$SessionTimestampUpdated
    | api$ISessionTimestampUpdated
    | null,

  /**
   * Command exec
   */
  exec?: api$Exec | api$IExec | null,

  /**
   * Command packageSearch
   */
  packageSearch?: api$PackageSearch | api$IPackageSearch | null,

  /**
   * Command packageSearchResp
   */
  packageSearchResp?: api$PackageSearchResp | api$IPackageSearchResp | null,

  /**
   * Command packageInfo
   */
  packageInfo?: api$PackageInfo | api$IPackageInfo | null,

  /**
   * Command packageInfoResp
   */
  packageInfoResp?: api$PackageInfoResp | api$IPackageInfoResp | null,

  /**
   * Command packageAdd
   */
  packageAdd?: api$PackageAdd | api$IPackageAdd | null,

  /**
   * Command packageRemove
   */
  packageRemove?: api$PackageRemove | api$IPackageRemove | null,

  /**
   * Command packageInstall
   */
  packageInstall?: api$PackageInstall | api$IPackageInstall | null,

  /**
   * Command packageListSpecfile
   */
  packageListSpecfile?:
    | api$PackageListSpecfile
    | api$IPackageListSpecfile
    | null,

  /**
   * Command packageListSpecfileResp
   */
  packageListSpecfileResp?:
    | api$PackageListSpecfileResp
    | api$IPackageListSpecfileResp
    | null,

  /**
   * Command packageCacheSave
   */
  packageCacheSave?: api$PackageCacheSave | api$IPackageCacheSave | null,

  /**
   * Command chatMessage
   */
  chatMessage?: api$ChatMessage | api$IChatMessage | null,

  /**
   * Command chatTyping
   */
  chatTyping?: api$ChatTyping | api$IChatTyping | null,

  /**
   * Command chatScrollback
   */
  chatScrollback?: api$ChatScrollback | api$IChatScrollback | null,

  /**
   * Command fsSnapshot
   */
  fsSnapshot?: api$FSSnapshot | api$IFSSnapshot | null,

  /**
   * Command fsSnapshotEvent
   */
  fsSnapshotEvent?: api$FSSnapshotEvent | api$IFSSnapshotEvent | null,

  /**
   * Command fsTakeLock
   */
  fsTakeLock?: api$FSLock | api$IFSLock | null,

  /**
   * Command fsReleaseLock
   */
  fsReleaseLock?: api$FSLock | api$IFSLock | null,

  /**
   * Command hasCap
   */
  hasCap?: boolean | null,

  /**
   * Command snapshotEvent
   */
  snapshotEvent?: api$SnapshotEvent | api$ISnapshotEvent | null,

  /**
   * Command NoninteractiveFSChangeEvent
   */
  NoninteractiveFSChangeEvent?: boolean | null,

  /**
   * Command pid1Config
   */
  pid1Config?: api$Pid1Config | api$IPid1Config | null,

  /**
   * Command metrics
   */
  metrics?: api$Metrics | api$IMetrics | null,

  /**
   * Command bootStatus
   */
  bootStatus?: api$BootStatus | api$IBootStatus | null,

  /**
   * Command readMetaRequest
   */
  readMetaRequest?: api$ReadMetaRequest | api$IReadMetaRequest | null,

  /**
   * Command readMetaResponse
   */
  readMetaResponse?: api$ReadMetaResponse | api$IReadMetaResponse | null,

  /**
   * Command writeMetaRequest
   */
  writeMetaRequest?: api$WriteMetaRequest | api$IWriteMetaRequest | null,

  /**
   * Command writeMetaResponse
   */
  writeMetaResponse?: api$WriteMetaResponse | api$IWriteMetaResponse | null,

  /**
   * Command appendMetaRequest
   */
  appendMetaRequest?: api$AppendMetaRequest | api$IAppendMetaRequest | null,

  /**
   * Command appendMetaResponse
   */
  appendMetaResponse?: api$AppendMetaResponse | api$IAppendMetaResponse | null,

  /**
   * Command audio
   */
  audio?: api$Audio | api$IAudio | null,

  /**
   * Command pprofRequest
   */
  pprofRequest?: api$PprofRequest | api$IPprofRequest | null,

  /**
   * Command pprofResponse
   */
  pprofResponse?: api$PprofResponse | api$IPprofResponse | null,

  /**
   * Command audio2
   */
  audio2?: api$Audio2 | api$IAudio2 | null,

  /**
   * Command PTYConfig
   */
  PTYConfig?: api$PTYConfig | api$IPTYConfig | null,

  /**
   * Command debugMain
   */
  debugMain?: api$DebugMain | api$IDebugMain | null,

  /**
   * Command debugState
   */
  debugState?: api$DebugState | api$IDebugState | null,

  /**
   * Command debugMainReply
   */
  debugMainReply?: api$DebugMainReply | api$IDebugMainReply | null,

  /**
   * Command debugInput
   */
  debugInput?: api$DebugInput | api$IDebugInput | null,

  /**
   * Command debugOutput
   */
  debugOutput?: api$DebugOutput | api$IDebugOutput | null,

  /**
   * Command debugStop
   */
  debugStop?: api$DebugStop | api$IDebugStop | null,

  /**
   * Command debugLeave
   */
  debugLeave?: api$DebugLeave | api$IDebugLeave | null,

  /**
   * Command debugSessions
   */
  debugSessions?: api$DebugSessions | api$IDebugSessions | null,

  /**
   * Command debugAddBreakpointRequest
   */
  debugAddBreakpointRequest?:
    | api$DebugAddBreakpointRequest
    | api$IDebugAddBreakpointRequest
    | null,

  /**
   * Command debugUpdateBreakpointRequest
   */
  debugUpdateBreakpointRequest?:
    | api$DebugUpdateBreakpointRequest
    | api$IDebugUpdateBreakpointRequest
    | null,

  /**
   * Command debugRemoveBreakpointRequest
   */
  debugRemoveBreakpointRequest?:
    | api$DebugRemoveBreakpointRequest
    | api$IDebugRemoveBreakpointRequest
    | null,

  /**
   * Command debugBreakpointEvent
   */
  debugBreakpointEvent?:
    | api$DebugBreakpointEvent
    | api$IDebugBreakpointEvent
    | null,

  /**
   * Command dotReplitGetRequest
   */
  dotReplitGetRequest?:
    | api$DotReplitGetRequest
    | api$IDotReplitGetRequest
    | null,

  /**
   * Command dotReplitGetResponse
   */
  dotReplitGetResponse?:
    | api$DotReplitGetResponse
    | api$IDotReplitGetResponse
    | null,

  /**
   * Command runConfigGetRequest
   */
  runConfigGetRequest?:
    | api$RunConfigGetRequest
    | api$IRunConfigGetRequest
    | null,

  /**
   * Command runConfigGetResponse
   */
  runConfigGetResponse?:
    | api$RunConfigGetResponse
    | api$IRunConfigGetResponse
    | null,

  /**
   * Command dotReplitUpdateRequest
   */
  dotReplitUpdateRequest?:
    | api$DotReplitUpdateRequest
    | api$IDotReplitUpdateRequest
    | null,

  /**
   * Command dotReplitUpdateResponse
   */
  dotReplitUpdateResponse?:
    | api$DotReplitUpdateResponse
    | api$IDotReplitUpdateResponse
    | null,

  /**
   * Command startLSP
   */
  startLSP?: api$StartLSP | api$IStartLSP | null,

  /**
   * Command firewallDenied
   */
  firewallDenied?: api$FirewallDenied | api$IFirewallDenied | null,

  /**
   * Command ref
   */
  ref?: string | null,

  /**
   * Command traceInfo
   */
  traceInfo?: {|
    [k: string]: string,
  |} | null,
|};

/**
 * Represents a Command.
 */
declare class api$Command {
  /**
   * Constructs a new Command.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ICommand): this;

  /**
   * Command channel.
   */
  channel: number;

  /**
   * Command session.
   */
  session: number;

  /**
   * Command openChan.
   */
  openChan?: api$OpenChannel | null;

  /**
   * Command openChanRes.
   */
  openChanRes?: api$OpenChannelRes | null;

  /**
   * Command closeChan.
   */
  closeChan?: api$CloseChannel | null;

  /**
   * Command closeChanRes.
   */
  closeChanRes?: api$CloseChannelRes | null;

  /**
   * Command containerState.
   */
  containerState?: api$ContainerState | null;

  /**
   * Command portOpen.
   */
  portOpen?: api$PortOpen | null;

  /**
   * Command portClose.
   */
  portClose?: api$PortClose | null;

  /**
   * Command toast.
   */
  toast?: api$Toast | null;

  /**
   * Command protocolError.
   */
  protocolError?: api$ProtocolError | null;

  /**
   * Command redirect.
   */
  redirect?: api$Redirect | null;

  /**
   * Command alwaysOn.
   */
  alwaysOn?: api$AlwaysOn | null;

  /**
   * Command runMain.
   */
  runMain?: api$RunMain | null;

  /**
   * Command clear.
   */
  clear?: api$Clear | null;

  /**
   * Command eval.
   */
  eval?: string | null;

  /**
   * Command result.
   */
  result?: string | null;

  /**
   * Command input.
   */
  input?: string | null;

  /**
   * Command output.
   */
  output?: string | null;

  /**
   * Command error.
   */
  error?: string | null;

  /**
   * Command stderr.
   */
  stderr?: string | null;

  /**
   * Command log.
   */
  log?: string | null;

  /**
   * Command saneTerm.
   */
  saneTerm?: api$SaneTerm | null;

  /**
   * Command resizeTerm.
   */
  resizeTerm?: api$ResizeTerm | null;

  /**
   * Command state.
   */
  state?: $Values<typeof api$State> | null;

  /**
   * Command ok.
   */
  ok?: api$OK | null;

  /**
   * Command persist.
   */
  persist?: api$File | null;

  /**
   * Command persistMirror.
   */
  persistMirror?: api$File | null;

  /**
   * Command write.
   */
  write?: api$File | null;

  /**
   * Command remove.
   */
  remove?: api$File | null;

  /**
   * Command move.
   */
  move?: api$Move | null;

  /**
   * Command tryRemove.
   */
  tryRemove?: api$File | null;

  /**
   * Command mkdir.
   */
  mkdir?: api$File | null;

  /**
   * Command stat.
   */
  stat?: api$File | null;

  /**
   * Command statRes.
   */
  statRes?: api$StatResult | null;

  /**
   * Command transferStart.
   */
  transferStart?: api$TransferStart | null;

  /**
   * Command transferChunk.
   */
  transferChunk?: api$TransferChunk | null;

  /**
   * Command transferComplete.
   */
  transferComplete?: api$TransferComplete | null;

  /**
   * Command transferCancel.
   */
  transferCancel?: api$Transfer | null;

  /**
   * Command transfer.
   */
  transfer?: api$Transfer | null;

  /**
   * Command read.
   */
  read?: api$File | null;

  /**
   * Command readdir.
   */
  readdir?: api$File | null;

  /**
   * Command files.
   */
  files?: api$Files | null;

  /**
   * Command file.
   */
  file?: api$File | null;

  /**
   * Command checkChanges.
   */
  checkChanges?: api$CheckChanges | null;

  /**
   * Command changedFiles.
   */
  changedFiles?: api$Files | null;

  /**
   * Command lintResults.
   */
  lintResults?: api$LintResults | null;

  /**
   * Command runContainedTest.
   */
  runContainedTest?: api$ContainedTest | null;

  /**
   * Command testResult.
   */
  testResult?: api$TestResult | null;

  /**
   * Command debuggerStart.
   */
  debuggerStart?: string | null;

  /**
   * Command debuggerStep.
   */
  debuggerStep?: api$RunMain | null;

  /**
   * Command debuggerStatus.
   */
  debuggerStatus?: api$DebugStatus | null;

  /**
   * Command ensurePackages.
   */
  ensurePackages?: api$EnsurePackages | null;

  /**
   * Command ping.
   */
  ping?: api$Ping | null;

  /**
   * Command pong.
   */
  pong?: api$Pong | null;

  /**
   * Command hello.
   */
  hello?: api$Hello | null;

  /**
   * Command goodbye.
   */
  goodbye?: api$Goodbye | null;

  /**
   * Command proxyGoingAway.
   */
  proxyGoingAway?: api$ProxyGoingAway | null;

  /**
   * Command hint.
   */
  hint?: api$Hint | null;

  /**
   * Command connect.
   */
  connect?: api$Connect | null;

  /**
   * Command send.
   */
  send?: api$Send | null;

  /**
   * Command recv.
   */
  recv?: api$Recv | null;

  /**
   * Command disconnect.
   */
  disconnect?: api$Disconnect | null;

  /**
   * Command fileAuthReq.
   */
  fileAuthReq?: api$FileAuthReq | null;

  /**
   * Command fileAuthRes.
   */
  fileAuthRes?: api$FileAuthRes | null;

  /**
   * Command mutliFileAuthRes.
   */
  mutliFileAuthRes?: api$MultiFileAuthRes | null;

  /**
   * Command listObjects.
   */
  listObjects?: api$ListObjects | null;

  /**
   * Command listObjectsResp.
   */
  listObjectsResp?: api$ListObjectsResp | null;

  /**
   * Command ot.
   */
  ot?: api$OTPacket | null;

  /**
   * Command otstatus.
   */
  otstatus?: api$OTStatus | null;

  /**
   * Command otLinkFile.
   */
  otLinkFile?: api$OTLinkFile | null;

  /**
   * Command otLinkFileResponse.
   */
  otLinkFileResponse?: api$OTLinkFileResponse | null;

  /**
   * Command otNewCursor.
   */
  otNewCursor?: api$OTCursor | null;

  /**
   * Command otDeleteCursor.
   */
  otDeleteCursor?: api$OTCursor | null;

  /**
   * Command otFetchRequest.
   */
  otFetchRequest?: api$OTFetchRequest | null;

  /**
   * Command otFetchResponse.
   */
  otFetchResponse?: api$OTFetchResponse | null;

  /**
   * Command otTransformSelectionRequest.
   */
  otTransformSelectionRequest?: api$OTTransformSelectionRequest | null;

  /**
   * Command otTransformSelectionResponse.
   */
  otTransformSelectionResponse?: api$OTTransformSelectionResponse | null;

  /**
   * Command flush.
   */
  flush?: api$Flush | null;

  /**
   * Command debug.
   */
  debug?: api$Debug | null;

  /**
   * Command startVCR.
   */
  startVCR?: api$StartVCR | null;

  /**
   * Command readVCR.
   */
  readVCR?: api$ReadVCR | null;

  /**
   * Command VCRLog.
   */
  VCRLog?: api$VCRLog | null;

  /**
   * Command auth.
   */
  auth?: api$Auth | null;

  /**
   * Command execInfo.
   */
  execInfo?: api$ExecInfo | null;

  /**
   * Command subscribeFile.
   */
  subscribeFile?: api$SubscribeFile | null;

  /**
   * Command fileEvent.
   */
  fileEvent?: api$FileEvent | null;

  /**
   * Command roster.
   */
  roster?: api$Roster | null;

  /**
   * Command join.
   */
  join?: api$User | null;

  /**
   * Command part.
   */
  part?: api$User | null;

  /**
   * Command openFile.
   */
  openFile?: api$OpenFile | null;

  /**
   * Command fileOpened.
   */
  fileOpened?: api$FileOpened | null;

  /**
   * Command followUser.
   */
  followUser?: api$FollowUser | null;

  /**
   * Command unfollowUser.
   */
  unfollowUser?: api$UnfollowUser | null;

  /**
   * Command updateSessionTimestamp.
   */
  updateSessionTimestamp?: api$UpdateSessionTimestamp | null;

  /**
   * Command sessionTimestampUpdated.
   */
  sessionTimestampUpdated?: api$SessionTimestampUpdated | null;

  /**
   * Command exec.
   */
  exec?: api$Exec | null;

  /**
   * Command packageSearch.
   */
  packageSearch?: api$PackageSearch | null;

  /**
   * Command packageSearchResp.
   */
  packageSearchResp?: api$PackageSearchResp | null;

  /**
   * Command packageInfo.
   */
  packageInfo?: api$PackageInfo | null;

  /**
   * Command packageInfoResp.
   */
  packageInfoResp?: api$PackageInfoResp | null;

  /**
   * Command packageAdd.
   */
  packageAdd?: api$PackageAdd | null;

  /**
   * Command packageRemove.
   */
  packageRemove?: api$PackageRemove | null;

  /**
   * Command packageInstall.
   */
  packageInstall?: api$PackageInstall | null;

  /**
   * Command packageListSpecfile.
   */
  packageListSpecfile?: api$PackageListSpecfile | null;

  /**
   * Command packageListSpecfileResp.
   */
  packageListSpecfileResp?: api$PackageListSpecfileResp | null;

  /**
   * Command packageCacheSave.
   */
  packageCacheSave?: api$PackageCacheSave | null;

  /**
   * Command chatMessage.
   */
  chatMessage?: api$ChatMessage | null;

  /**
   * Command chatTyping.
   */
  chatTyping?: api$ChatTyping | null;

  /**
   * Command chatScrollback.
   */
  chatScrollback?: api$ChatScrollback | null;

  /**
   * Command fsSnapshot.
   */
  fsSnapshot?: api$FSSnapshot | null;

  /**
   * Command fsSnapshotEvent.
   */
  fsSnapshotEvent?: api$FSSnapshotEvent | null;

  /**
   * Command fsTakeLock.
   */
  fsTakeLock?: api$FSLock | null;

  /**
   * Command fsReleaseLock.
   */
  fsReleaseLock?: api$FSLock | null;

  /**
   * Command hasCap.
   */
  hasCap?: boolean | null;

  /**
   * Command snapshotEvent.
   */
  snapshotEvent?: api$SnapshotEvent | null;

  /**
   * Command NoninteractiveFSChangeEvent.
   */
  NoninteractiveFSChangeEvent?: boolean | null;

  /**
   * Command pid1Config.
   */
  pid1Config?: api$Pid1Config | null;

  /**
   * Command metrics.
   */
  metrics?: api$Metrics | null;

  /**
   * Command bootStatus.
   */
  bootStatus?: api$BootStatus | null;

  /**
   * Command readMetaRequest.
   */
  readMetaRequest?: api$ReadMetaRequest | null;

  /**
   * Command readMetaResponse.
   */
  readMetaResponse?: api$ReadMetaResponse | null;

  /**
   * Command writeMetaRequest.
   */
  writeMetaRequest?: api$WriteMetaRequest | null;

  /**
   * Command writeMetaResponse.
   */
  writeMetaResponse?: api$WriteMetaResponse | null;

  /**
   * Command appendMetaRequest.
   */
  appendMetaRequest?: api$AppendMetaRequest | null;

  /**
   * Command appendMetaResponse.
   */
  appendMetaResponse?: api$AppendMetaResponse | null;

  /**
   * Command audio.
   */
  audio?: api$Audio | null;

  /**
   * Command pprofRequest.
   */
  pprofRequest?: api$PprofRequest | null;

  /**
   * Command pprofResponse.
   */
  pprofResponse?: api$PprofResponse | null;

  /**
   * Command audio2.
   */
  audio2?: api$Audio2 | null;

  /**
   * Command PTYConfig.
   */
  PTYConfig?: api$PTYConfig | null;

  /**
   * Command debugMain.
   */
  debugMain?: api$DebugMain | null;

  /**
   * Command debugState.
   */
  debugState?: api$DebugState | null;

  /**
   * Command debugMainReply.
   */
  debugMainReply?: api$DebugMainReply | null;

  /**
   * Command debugInput.
   */
  debugInput?: api$DebugInput | null;

  /**
   * Command debugOutput.
   */
  debugOutput?: api$DebugOutput | null;

  /**
   * Command debugStop.
   */
  debugStop?: api$DebugStop | null;

  /**
   * Command debugLeave.
   */
  debugLeave?: api$DebugLeave | null;

  /**
   * Command debugSessions.
   */
  debugSessions?: api$DebugSessions | null;

  /**
   * Command debugAddBreakpointRequest.
   */
  debugAddBreakpointRequest?: api$DebugAddBreakpointRequest | null;

  /**
   * Command debugUpdateBreakpointRequest.
   */
  debugUpdateBreakpointRequest?: api$DebugUpdateBreakpointRequest | null;

  /**
   * Command debugRemoveBreakpointRequest.
   */
  debugRemoveBreakpointRequest?: api$DebugRemoveBreakpointRequest | null;

  /**
   * Command debugBreakpointEvent.
   */
  debugBreakpointEvent?: api$DebugBreakpointEvent | null;

  /**
   * Command dotReplitGetRequest.
   */
  dotReplitGetRequest?: api$DotReplitGetRequest | null;

  /**
   * Command dotReplitGetResponse.
   */
  dotReplitGetResponse?: api$DotReplitGetResponse | null;

  /**
   * Command runConfigGetRequest.
   */
  runConfigGetRequest?: api$RunConfigGetRequest | null;

  /**
   * Command runConfigGetResponse.
   */
  runConfigGetResponse?: api$RunConfigGetResponse | null;

  /**
   * Command dotReplitUpdateRequest.
   */
  dotReplitUpdateRequest?: api$DotReplitUpdateRequest | null;

  /**
   * Command dotReplitUpdateResponse.
   */
  dotReplitUpdateResponse?: api$DotReplitUpdateResponse | null;

  /**
   * Command startLSP.
   */
  startLSP?: api$StartLSP | null;

  /**
   * Command firewallDenied.
   */
  firewallDenied?: api$FirewallDenied | null;

  /**
   * Command ref.
   */
  ref: string;

  /**
   * Command traceInfo.
   */
  traceInfo: {|
    [k: string]: string,
  |};

  /**
   * Command body.
   */
  body?:
    | "openChan"
    | "openChanRes"
    | "closeChan"
    | "closeChanRes"
    | "containerState"
    | "portOpen"
    | "portClose"
    | "toast"
    | "protocolError"
    | "redirect"
    | "alwaysOn"
    | "runMain"
    | "clear"
    | "eval"
    | "result"
    | "input"
    | "output"
    | "error"
    | "stderr"
    | "log"
    | "saneTerm"
    | "resizeTerm"
    | "state"
    | "ok"
    | "persist"
    | "persistMirror"
    | "write"
    | "remove"
    | "move"
    | "tryRemove"
    | "mkdir"
    | "stat"
    | "statRes"
    | "transferStart"
    | "transferChunk"
    | "transferComplete"
    | "transferCancel"
    | "transfer"
    | "read"
    | "readdir"
    | "files"
    | "file"
    | "checkChanges"
    | "changedFiles"
    | "lintResults"
    | "runContainedTest"
    | "testResult"
    | "debuggerStart"
    | "debuggerStep"
    | "debuggerStatus"
    | "ensurePackages"
    | "ping"
    | "pong"
    | "hello"
    | "goodbye"
    | "proxyGoingAway"
    | "hint"
    | "connect"
    | "send"
    | "recv"
    | "disconnect"
    | "fileAuthReq"
    | "fileAuthRes"
    | "mutliFileAuthRes"
    | "listObjects"
    | "listObjectsResp"
    | "ot"
    | "otstatus"
    | "otLinkFile"
    | "otLinkFileResponse"
    | "otNewCursor"
    | "otDeleteCursor"
    | "otFetchRequest"
    | "otFetchResponse"
    | "otTransformSelectionRequest"
    | "otTransformSelectionResponse"
    | "flush"
    | "debug"
    | "startVCR"
    | "readVCR"
    | "VCRLog"
    | "auth"
    | "execInfo"
    | "subscribeFile"
    | "fileEvent"
    | "roster"
    | "join"
    | "part"
    | "openFile"
    | "fileOpened"
    | "followUser"
    | "unfollowUser"
    | "updateSessionTimestamp"
    | "sessionTimestampUpdated"
    | "exec"
    | "packageSearch"
    | "packageSearchResp"
    | "packageInfo"
    | "packageInfoResp"
    | "packageAdd"
    | "packageRemove"
    | "packageInstall"
    | "packageListSpecfile"
    | "packageListSpecfileResp"
    | "packageCacheSave"
    | "chatMessage"
    | "chatTyping"
    | "chatScrollback"
    | "fsSnapshot"
    | "fsSnapshotEvent"
    | "fsTakeLock"
    | "fsReleaseLock"
    | "hasCap"
    | "snapshotEvent"
    | "NoninteractiveFSChangeEvent"
    | "pid1Config"
    | "metrics"
    | "bootStatus"
    | "readMetaRequest"
    | "readMetaResponse"
    | "writeMetaRequest"
    | "writeMetaResponse"
    | "appendMetaRequest"
    | "appendMetaResponse"
    | "audio"
    | "pprofRequest"
    | "pprofResponse"
    | "audio2"
    | "PTYConfig"
    | "debugMain"
    | "debugState"
    | "debugMainReply"
    | "debugInput"
    | "debugOutput"
    | "debugStop"
    | "debugLeave"
    | "debugSessions"
    | "debugAddBreakpointRequest"
    | "debugUpdateBreakpointRequest"
    | "debugRemoveBreakpointRequest"
    | "debugBreakpointEvent"
    | "dotReplitGetRequest"
    | "dotReplitGetResponse"
    | "runConfigGetRequest"
    | "runConfigGetResponse"
    | "dotReplitUpdateRequest"
    | "dotReplitUpdateResponse"
    | "startLSP"
    | "firewallDenied";

  /**
   * Creates a new Command instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Command instance
   */
  static create(properties?: api$ICommand): api$Command;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Command message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Command,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Command message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Command,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Command message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Command
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Command;

  /**
   * Decodes a Command message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Command
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Command;

  /**
   * Verifies a Command message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Command message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Command
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Command;

  /**
   * Creates a plain object from a Command message. Also converts values to other types if specified.
   * @param message Command
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Command,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Command to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a StartLSP.
 */
declare type api$IStartLSP = {|
  /**
   * StartLSP language
   */
  language?: string | null,
|};

/**
 * Represents a StartLSP.
 */
declare class api$StartLSP {
  /**
   * Constructs a new StartLSP.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IStartLSP): this;

  /**
   * StartLSP language.
   */
  language: string;

  /**
   * Creates a new StartLSP instance using the specified properties.
   * @param [properties] Properties to set
   * @returns StartLSP instance
   */
  static create(properties?: api$IStartLSP): api$StartLSP;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StartLSP message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$StartLSP,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StartLSP message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$StartLSP,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a StartLSP message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns StartLSP
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$StartLSP;

  /**
   * Decodes a StartLSP message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns StartLSP
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$StartLSP;

  /**
   * Verifies a StartLSP message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a StartLSP message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns StartLSP
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$StartLSP;

  /**
   * Creates a plain object from a StartLSP message. Also converts values to other types if specified.
   * @param message StartLSP
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$StartLSP,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this StartLSP to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an Audio.
 */
declare type api$IAudio = {|
  /**
   * Audio data
   */
  data?: number[] | null,
|};

/**
 * Represents an Audio.
 */
declare class api$Audio {
  /**
   * Constructs a new Audio.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IAudio): this;

  /**
   * Audio data.
   */
  data: number[];

  /**
   * Creates a new Audio instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Audio instance
   */
  static create(properties?: api$IAudio): api$Audio;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Audio message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Audio,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Audio message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Audio,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an Audio message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Audio
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Audio;

  /**
   * Decodes an Audio message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Audio
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Audio;

  /**
   * Verifies an Audio message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an Audio message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Audio
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Audio;

  /**
   * Creates a plain object from an Audio message. Also converts values to other types if specified.
   * @param message Audio
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Audio,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Audio to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an Audio2.
 */
declare type api$IAudio2 = {|
  /**
   * Audio2 data
   */
  data?: number[] | null,

  /**
   * Audio2 samples
   */
  samples?: number | null,
|};

/**
 * Represents an Audio2.
 */
declare class api$Audio2 {
  /**
   * Constructs a new Audio2.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IAudio2): this;

  /**
   * Audio2 data.
   */
  data: number[];

  /**
   * Audio2 samples.
   */
  samples: number;

  /**
   * Creates a new Audio2 instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Audio2 instance
   */
  static create(properties?: api$IAudio2): api$Audio2;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Audio2 message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Audio2,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Audio2 message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Audio2,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an Audio2 message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Audio2
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Audio2;

  /**
   * Decodes an Audio2 message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Audio2
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Audio2;

  /**
   * Verifies an Audio2 message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an Audio2 message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Audio2
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Audio2;

  /**
   * Creates a plain object from an Audio2 message. Also converts values to other types if specified.
   * @param message Audio2
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Audio2,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Audio2 to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Preconditions.
 */
declare type api$IPreconditions = {|
  /**
   * Preconditions generation
   */
  generation?: number | null,

  /**
   * Preconditions metageneration
   */
  metageneration?: number | null,

  /**
   * Preconditions doesNotExist
   */
  doesNotExist?: boolean | null,
|};

/**
 * Represents a Preconditions.
 */
declare class api$Preconditions {
  /**
   * Constructs a new Preconditions.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPreconditions): this;

  /**
   * Preconditions generation.
   */
  generation: number;

  /**
   * Preconditions metageneration.
   */
  metageneration: number;

  /**
   * Preconditions doesNotExist.
   */
  doesNotExist: boolean;

  /**
   * Creates a new Preconditions instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Preconditions instance
   */
  static create(properties?: api$IPreconditions): api$Preconditions;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Preconditions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Preconditions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Preconditions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Preconditions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Preconditions message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Preconditions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Preconditions;

  /**
   * Decodes a Preconditions message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Preconditions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$Preconditions;

  /**
   * Verifies a Preconditions message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Preconditions message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Preconditions
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Preconditions;

  /**
   * Creates a plain object from a Preconditions message. Also converts values to other types if specified.
   * @param message Preconditions
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Preconditions,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Preconditions to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReadMetaRequest.
 */
declare type api$IReadMetaRequest = {|
  /**
   * ReadMetaRequest key
   */
  key?: string | null,

  /**
   * ReadMetaRequest exists
   */
  exists?: boolean | null,

  /**
   * ReadMetaRequest data
   */
  data?: Uint8Array | null,
|};

/**
 * Represents a ReadMetaRequest.
 */
declare class api$ReadMetaRequest {
  /**
   * Constructs a new ReadMetaRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IReadMetaRequest): this;

  /**
   * ReadMetaRequest key.
   */
  key: string;

  /**
   * ReadMetaRequest exists.
   */
  exists: boolean;

  /**
   * ReadMetaRequest data.
   */
  data: Uint8Array;

  /**
   * Creates a new ReadMetaRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReadMetaRequest instance
   */
  static create(properties?: api$IReadMetaRequest): api$ReadMetaRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReadMetaRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ReadMetaRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReadMetaRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ReadMetaRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReadMetaRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReadMetaRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ReadMetaRequest;

  /**
   * Decodes a ReadMetaRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReadMetaRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ReadMetaRequest;

  /**
   * Verifies a ReadMetaRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReadMetaRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReadMetaRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ReadMetaRequest;

  /**
   * Creates a plain object from a ReadMetaRequest message. Also converts values to other types if specified.
   * @param message ReadMetaRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ReadMetaRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReadMetaRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReadMetaResponse.
 */
declare type api$IReadMetaResponse = {|
  /**
   * ReadMetaResponse key
   */
  key?: string | null,

  /**
   * ReadMetaResponse exists
   */
  exists?: boolean | null,

  /**
   * ReadMetaResponse data
   */
  data?: Uint8Array | null,

  /**
   * ReadMetaResponse generation
   */
  generation?: number | null,

  /**
   * ReadMetaResponse metageneration
   */
  metageneration?: number | null,
|};

/**
 * Represents a ReadMetaResponse.
 */
declare class api$ReadMetaResponse {
  /**
   * Constructs a new ReadMetaResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IReadMetaResponse): this;

  /**
   * ReadMetaResponse key.
   */
  key: string;

  /**
   * ReadMetaResponse exists.
   */
  exists: boolean;

  /**
   * ReadMetaResponse data.
   */
  data: Uint8Array;

  /**
   * ReadMetaResponse generation.
   */
  generation: number;

  /**
   * ReadMetaResponse metageneration.
   */
  metageneration: number;

  /**
   * Creates a new ReadMetaResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReadMetaResponse instance
   */
  static create(properties?: api$IReadMetaResponse): api$ReadMetaResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReadMetaResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ReadMetaResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReadMetaResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ReadMetaResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReadMetaResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReadMetaResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ReadMetaResponse;

  /**
   * Decodes a ReadMetaResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReadMetaResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ReadMetaResponse;

  /**
   * Verifies a ReadMetaResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReadMetaResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReadMetaResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ReadMetaResponse;

  /**
   * Creates a plain object from a ReadMetaResponse message. Also converts values to other types if specified.
   * @param message ReadMetaResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ReadMetaResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReadMetaResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a WriteMetaRequest.
 */
declare type api$IWriteMetaRequest = {|
  /**
   * WriteMetaRequest key
   */
  key?: string | null,

  /**
   * WriteMetaRequest data
   */
  data?: Uint8Array | null,

  /**
   * WriteMetaRequest preconditions
   */
  preconditions?: api$Preconditions | api$IPreconditions | null,
|};

/**
 * Represents a WriteMetaRequest.
 */
declare class api$WriteMetaRequest {
  /**
   * Constructs a new WriteMetaRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IWriteMetaRequest): this;

  /**
   * WriteMetaRequest key.
   */
  key: string;

  /**
   * WriteMetaRequest data.
   */
  data: Uint8Array;

  /**
   * WriteMetaRequest preconditions.
   */
  preconditions?: api$Preconditions | null;

  /**
   * Creates a new WriteMetaRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns WriteMetaRequest instance
   */
  static create(properties?: api$IWriteMetaRequest): api$WriteMetaRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message WriteMetaRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$WriteMetaRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message WriteMetaRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$WriteMetaRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a WriteMetaRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns WriteMetaRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$WriteMetaRequest;

  /**
   * Decodes a WriteMetaRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns WriteMetaRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$WriteMetaRequest;

  /**
   * Verifies a WriteMetaRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a WriteMetaRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns WriteMetaRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$WriteMetaRequest;

  /**
   * Creates a plain object from a WriteMetaRequest message. Also converts values to other types if specified.
   * @param message WriteMetaRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$WriteMetaRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this WriteMetaRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a WriteMetaResponse.
 */
declare type api$IWriteMetaResponse = {|
  /**
   * WriteMetaResponse generation
   */
  generation?: number | null,

  /**
   * WriteMetaResponse metageneration
   */
  metageneration?: number | null,
|};

/**
 * Represents a WriteMetaResponse.
 */
declare class api$WriteMetaResponse {
  /**
   * Constructs a new WriteMetaResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IWriteMetaResponse): this;

  /**
   * WriteMetaResponse generation.
   */
  generation: number;

  /**
   * WriteMetaResponse metageneration.
   */
  metageneration: number;

  /**
   * Creates a new WriteMetaResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns WriteMetaResponse instance
   */
  static create(properties?: api$IWriteMetaResponse): api$WriteMetaResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message WriteMetaResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$WriteMetaResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message WriteMetaResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$WriteMetaResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a WriteMetaResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns WriteMetaResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$WriteMetaResponse;

  /**
   * Decodes a WriteMetaResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns WriteMetaResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$WriteMetaResponse;

  /**
   * Verifies a WriteMetaResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a WriteMetaResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns WriteMetaResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$WriteMetaResponse;

  /**
   * Creates a plain object from a WriteMetaResponse message. Also converts values to other types if specified.
   * @param message WriteMetaResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$WriteMetaResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this WriteMetaResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an AppendMetaRequest.
 */
declare type api$IAppendMetaRequest = {|
  /**
   * AppendMetaRequest key
   */
  key?: string | null,

  /**
   * AppendMetaRequest data
   */
  data?: Uint8Array | null,

  /**
   * AppendMetaRequest preconditions
   */
  preconditions?: api$Preconditions | api$IPreconditions | null,
|};

/**
 * Represents an AppendMetaRequest.
 */
declare class api$AppendMetaRequest {
  /**
   * Constructs a new AppendMetaRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IAppendMetaRequest): this;

  /**
   * AppendMetaRequest key.
   */
  key: string;

  /**
   * AppendMetaRequest data.
   */
  data: Uint8Array;

  /**
   * AppendMetaRequest preconditions.
   */
  preconditions?: api$Preconditions | null;

  /**
   * Creates a new AppendMetaRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns AppendMetaRequest instance
   */
  static create(properties?: api$IAppendMetaRequest): api$AppendMetaRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AppendMetaRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$AppendMetaRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AppendMetaRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$AppendMetaRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an AppendMetaRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns AppendMetaRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$AppendMetaRequest;

  /**
   * Decodes an AppendMetaRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns AppendMetaRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$AppendMetaRequest;

  /**
   * Verifies an AppendMetaRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an AppendMetaRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns AppendMetaRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$AppendMetaRequest;

  /**
   * Creates a plain object from an AppendMetaRequest message. Also converts values to other types if specified.
   * @param message AppendMetaRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$AppendMetaRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this AppendMetaRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an AppendMetaResponse.
 */
declare type api$IAppendMetaResponse = {|
  /**
   * AppendMetaResponse generation
   */
  generation?: number | null,

  /**
   * AppendMetaResponse metageneration
   */
  metageneration?: number | null,
|};

/**
 * Represents an AppendMetaResponse.
 */
declare class api$AppendMetaResponse {
  /**
   * Constructs a new AppendMetaResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IAppendMetaResponse): this;

  /**
   * AppendMetaResponse generation.
   */
  generation: number;

  /**
   * AppendMetaResponse metageneration.
   */
  metageneration: number;

  /**
   * Creates a new AppendMetaResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns AppendMetaResponse instance
   */
  static create(properties?: api$IAppendMetaResponse): api$AppendMetaResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AppendMetaResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$AppendMetaResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AppendMetaResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$AppendMetaResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an AppendMetaResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns AppendMetaResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$AppendMetaResponse;

  /**
   * Decodes an AppendMetaResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns AppendMetaResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$AppendMetaResponse;

  /**
   * Verifies an AppendMetaResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an AppendMetaResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns AppendMetaResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$AppendMetaResponse;

  /**
   * Creates a plain object from an AppendMetaResponse message. Also converts values to other types if specified.
   * @param message AppendMetaResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$AppendMetaResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this AppendMetaResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a BootStatus.
 */
declare type api$IBootStatus = {|
  /**
   * BootStatus stage
   */
  stage?: $Values<typeof api$BootStatus$Stage> | null,

  /**
   * BootStatus progress
   */
  progress?: number | null,

  /**
   * BootStatus total
   */
  total?: number | null,
|};

/**
 * Represents a BootStatus.
 */
declare class api$BootStatus {
  /**
   * Constructs a new BootStatus.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IBootStatus): this;

  /**
   * BootStatus stage.
   */
  stage: $Values<typeof api$BootStatus$Stage>;

  /**
   * BootStatus progress.
   */
  progress: number;

  /**
   * BootStatus total.
   */
  total: number;

  /**
   * Creates a new BootStatus instance using the specified properties.
   * @param [properties] Properties to set
   * @returns BootStatus instance
   */
  static create(properties?: api$IBootStatus): api$BootStatus;

  /**
   * [object Object],[object Object],[object Object]
   * @param message BootStatus message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$BootStatus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message BootStatus message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$BootStatus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a BootStatus message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns BootStatus
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$BootStatus;

  /**
   * Decodes a BootStatus message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns BootStatus
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$BootStatus;

  /**
   * Verifies a BootStatus message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a BootStatus message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns BootStatus
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$BootStatus;

  /**
   * Creates a plain object from a BootStatus message. Also converts values to other types if specified.
   * @param message BootStatus
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$BootStatus,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this BootStatus to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Stage: typeof api$BootStatus$Stage;
}

/**
 * Stage enum.
 */

declare var api$BootStatus$Stage: {|
  +HANDSHAKE: 0, // 0
  +ACQUIRING: 3, // 3
  +COMPLETE: 4, // 4
  +PROXY: 5, // 5
  +PULL_FILES: 6, // 6
  +LOAD_BLOCK: 7, // 7
  +RETRY: 8, // 8
|};

/**
 * Properties of a Pid1Config.
 */
declare type api$IPid1Config = {|
  /**
   * Pid1Config cwd
   */
  cwd?: string | null,

  /**
   * Pid1Config language
   */
  language?: string | null,

  /**
   * Pid1Config env
   */
  env?: {|
    [k: string]: string,
  |} | null,

  /**
   * Pid1Config noStore
   */
  noStore?: boolean | null,

  /**
   * Pid1Config noninteractiveFSChange
   */
  noninteractiveFSChange?: boolean | null,
|};

/**
 * Represents a Pid1Config.
 */
declare class api$Pid1Config {
  /**
   * Constructs a new Pid1Config.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPid1Config): this;

  /**
   * Pid1Config cwd.
   */
  cwd: string;

  /**
   * Pid1Config language.
   */
  language: string;

  /**
   * Pid1Config env.
   */
  env: {|
    [k: string]: string,
  |};

  /**
   * Pid1Config noStore.
   */
  noStore: boolean;

  /**
   * Pid1Config noninteractiveFSChange.
   */
  noninteractiveFSChange: boolean;

  /**
   * Creates a new Pid1Config instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Pid1Config instance
   */
  static create(properties?: api$IPid1Config): api$Pid1Config;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Pid1Config message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Pid1Config,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Pid1Config message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Pid1Config,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Pid1Config message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Pid1Config
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Pid1Config;

  /**
   * Decodes a Pid1Config message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Pid1Config
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Pid1Config;

  /**
   * Verifies a Pid1Config message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Pid1Config message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Pid1Config
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Pid1Config;

  /**
   * Creates a plain object from a Pid1Config message. Also converts values to other types if specified.
   * @param message Pid1Config
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Pid1Config,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Pid1Config to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FSLock.
 */
declare type api$IFSLock = {|
  /**
   * FSLock name
   */
  name?: string | null,
|};

/**
 * Represents a FSLock.
 */
declare class api$FSLock {
  /**
   * Constructs a new FSLock.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IFSLock): this;

  /**
   * FSLock name.
   */
  name: string;

  /**
   * Creates a new FSLock instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FSLock instance
   */
  static create(properties?: api$IFSLock): api$FSLock;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FSLock message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$FSLock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FSLock message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$FSLock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FSLock message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FSLock
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$FSLock;

  /**
   * Decodes a FSLock message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FSLock
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$FSLock;

  /**
   * Verifies a FSLock message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FSLock message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FSLock
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$FSLock;

  /**
   * Creates a plain object from a FSLock message. Also converts values to other types if specified.
   * @param message FSLock
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$FSLock,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FSLock to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FSSnapshot.
 */
declare type api$IFSSnapshot = {||};

/**
 * Represents a FSSnapshot.
 */
declare class api$FSSnapshot {
  /**
   * Constructs a new FSSnapshot.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IFSSnapshot): this;

  /**
   * Creates a new FSSnapshot instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FSSnapshot instance
   */
  static create(properties?: api$IFSSnapshot): api$FSSnapshot;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FSSnapshot message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$FSSnapshot,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FSSnapshot message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$FSSnapshot,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FSSnapshot message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FSSnapshot
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$FSSnapshot;

  /**
   * Decodes a FSSnapshot message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FSSnapshot
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$FSSnapshot;

  /**
   * Verifies a FSSnapshot message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FSSnapshot message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FSSnapshot
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$FSSnapshot;

  /**
   * Creates a plain object from a FSSnapshot message. Also converts values to other types if specified.
   * @param message FSSnapshot
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$FSSnapshot,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FSSnapshot to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FSSnapshotEvent.
 */
declare type api$IFSSnapshotEvent = {|
  /**
   * FSSnapshotEvent sources
   */
  sources?: string[] | null,
|};

/**
 * Represents a FSSnapshotEvent.
 */
declare class api$FSSnapshotEvent {
  /**
   * Constructs a new FSSnapshotEvent.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IFSSnapshotEvent): this;

  /**
   * FSSnapshotEvent sources.
   */
  sources: string[];

  /**
   * Creates a new FSSnapshotEvent instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FSSnapshotEvent instance
   */
  static create(properties?: api$IFSSnapshotEvent): api$FSSnapshotEvent;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FSSnapshotEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$FSSnapshotEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FSSnapshotEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$FSSnapshotEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FSSnapshotEvent message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FSSnapshotEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$FSSnapshotEvent;

  /**
   * Decodes a FSSnapshotEvent message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FSSnapshotEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$FSSnapshotEvent;

  /**
   * Verifies a FSSnapshotEvent message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FSSnapshotEvent message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FSSnapshotEvent
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$FSSnapshotEvent;

  /**
   * Creates a plain object from a FSSnapshotEvent message. Also converts values to other types if specified.
   * @param message FSSnapshotEvent
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$FSSnapshotEvent,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FSSnapshotEvent to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a SnapshotEvent.
 */
declare type api$ISnapshotEvent = {|
  /**
   * SnapshotEvent sources
   */
  sources?: string[] | null,
|};

/**
 * Represents a SnapshotEvent.
 */
declare class api$SnapshotEvent {
  /**
   * Constructs a new SnapshotEvent.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ISnapshotEvent): this;

  /**
   * SnapshotEvent sources.
   */
  sources: string[];

  /**
   * Creates a new SnapshotEvent instance using the specified properties.
   * @param [properties] Properties to set
   * @returns SnapshotEvent instance
   */
  static create(properties?: api$ISnapshotEvent): api$SnapshotEvent;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SnapshotEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$SnapshotEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SnapshotEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$SnapshotEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a SnapshotEvent message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns SnapshotEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$SnapshotEvent;

  /**
   * Decodes a SnapshotEvent message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns SnapshotEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$SnapshotEvent;

  /**
   * Verifies a SnapshotEvent message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a SnapshotEvent message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns SnapshotEvent
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$SnapshotEvent;

  /**
   * Creates a plain object from a SnapshotEvent message. Also converts values to other types if specified.
   * @param message SnapshotEvent
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$SnapshotEvent,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this SnapshotEvent to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a SubscribeFile.
 */
declare type api$ISubscribeFile = {|
  /**
   * SubscribeFile files
   */
  files?: (api$File | api$IFile)[] | null,
|};

/**
 * Represents a SubscribeFile.
 */
declare class api$SubscribeFile {
  /**
   * Constructs a new SubscribeFile.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ISubscribeFile): this;

  /**
   * SubscribeFile files.
   */
  files: api$File[];

  /**
   * Creates a new SubscribeFile instance using the specified properties.
   * @param [properties] Properties to set
   * @returns SubscribeFile instance
   */
  static create(properties?: api$ISubscribeFile): api$SubscribeFile;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SubscribeFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$SubscribeFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SubscribeFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$SubscribeFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a SubscribeFile message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns SubscribeFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$SubscribeFile;

  /**
   * Decodes a SubscribeFile message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns SubscribeFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$SubscribeFile;

  /**
   * Verifies a SubscribeFile message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a SubscribeFile message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns SubscribeFile
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$SubscribeFile;

  /**
   * Creates a plain object from a SubscribeFile message. Also converts values to other types if specified.
   * @param message SubscribeFile
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$SubscribeFile,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this SubscribeFile to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FileEvent.
 */
declare type api$IFileEvent = {|
  /**
   * FileEvent file
   */
  file?: api$File | api$IFile | null,

  /**
   * FileEvent dest
   */
  dest?: api$File | api$IFile | null,

  /**
   * FileEvent op
   */
  op?: $Values<typeof api$FileEvent$Op> | null,
|};

/**
 * Represents a FileEvent.
 */
declare class api$FileEvent {
  /**
   * Constructs a new FileEvent.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IFileEvent): this;

  /**
   * FileEvent file.
   */
  file?: api$File | null;

  /**
   * FileEvent dest.
   */
  dest?: api$File | null;

  /**
   * FileEvent op.
   */
  op: $Values<typeof api$FileEvent$Op>;

  /**
   * Creates a new FileEvent instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FileEvent instance
   */
  static create(properties?: api$IFileEvent): api$FileEvent;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$FileEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$FileEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FileEvent message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FileEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$FileEvent;

  /**
   * Decodes a FileEvent message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FileEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$FileEvent;

  /**
   * Verifies a FileEvent message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FileEvent message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FileEvent
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$FileEvent;

  /**
   * Creates a plain object from a FileEvent message. Also converts values to other types if specified.
   * @param message FileEvent
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$FileEvent,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FileEvent to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Op: typeof api$FileEvent$Op;
}

/**
 * Op enum.
 */

declare var api$FileEvent$Op: {|
  +Create: 0, // 0
  +Move: 1, // 1
  +Remove: 2, // 2
  +Modify: 3, // 3
|};

/**
 * Properties of a Flush.
 */
declare type api$IFlush = {||};

/**
 * Represents a Flush.
 */
declare class api$Flush {
  /**
   * Constructs a new Flush.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IFlush): this;

  /**
   * Creates a new Flush instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Flush instance
   */
  static create(properties?: api$IFlush): api$Flush;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Flush message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Flush,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Flush message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Flush,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Flush message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Flush
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Flush;

  /**
   * Decodes a Flush message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Flush
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Flush;

  /**
   * Verifies a Flush message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Flush message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Flush
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Flush;

  /**
   * Creates a plain object from a Flush message. Also converts values to other types if specified.
   * @param message Flush
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Flush,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Flush to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTLinkFile.
 */
declare type api$IOTLinkFile = {|
  /**
   * OTLinkFile file
   */
  file?: api$File | api$IFile | null,

  /**
   * OTLinkFile highConsistency
   */
  highConsistency?: boolean | null,

  /**
   * OTLinkFile OBSOLETEUseModTime
   */
  OBSOLETEUseModTime?: boolean | null,
|};

/**
 * Represents a OTLinkFile.
 */
declare class api$OTLinkFile {
  /**
   * Constructs a new OTLinkFile.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IOTLinkFile): this;

  /**
   * OTLinkFile file.
   */
  file?: api$File | null;

  /**
   * OTLinkFile highConsistency.
   */
  highConsistency: boolean;

  /**
   * OTLinkFile OBSOLETEUseModTime.
   */
  OBSOLETEUseModTime: boolean;

  /**
   * Creates a new OTLinkFile instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTLinkFile instance
   */
  static create(properties?: api$IOTLinkFile): api$OTLinkFile;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTLinkFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$OTLinkFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTLinkFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$OTLinkFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTLinkFile message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTLinkFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$OTLinkFile;

  /**
   * Decodes a OTLinkFile message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTLinkFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$OTLinkFile;

  /**
   * Verifies a OTLinkFile message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTLinkFile message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTLinkFile
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$OTLinkFile;

  /**
   * Creates a plain object from a OTLinkFile message. Also converts values to other types if specified.
   * @param message OTLinkFile
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$OTLinkFile,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTLinkFile to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTLinkFileResponse.
 */
declare type api$IOTLinkFileResponse = {|
  /**
   * OTLinkFileResponse version
   */
  version?: number | null,

  /**
   * OTLinkFileResponse linkedFile
   */
  linkedFile?: api$File | api$IFile | null,
|};

/**
 * Represents a OTLinkFileResponse.
 */
declare class api$OTLinkFileResponse {
  /**
   * Constructs a new OTLinkFileResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IOTLinkFileResponse): this;

  /**
   * OTLinkFileResponse version.
   */
  version: number;

  /**
   * OTLinkFileResponse linkedFile.
   */
  linkedFile?: api$File | null;

  /**
   * Creates a new OTLinkFileResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTLinkFileResponse instance
   */
  static create(properties?: api$IOTLinkFileResponse): api$OTLinkFileResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTLinkFileResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$OTLinkFileResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTLinkFileResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$OTLinkFileResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTLinkFileResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTLinkFileResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$OTLinkFileResponse;

  /**
   * Decodes a OTLinkFileResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTLinkFileResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$OTLinkFileResponse;

  /**
   * Verifies a OTLinkFileResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTLinkFileResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTLinkFileResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$OTLinkFileResponse;

  /**
   * Creates a plain object from a OTLinkFileResponse message. Also converts values to other types if specified.
   * @param message OTLinkFileResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$OTLinkFileResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTLinkFileResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an Auth.
 */
declare type api$IAuth = {|
  /**
   * Auth token
   */
  token?: string | null,

  /**
   * Auth containerID
   */
  containerID?: string | null,
|};

/**
 * Represents an Auth.
 */
declare class api$Auth {
  /**
   * Constructs a new Auth.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IAuth): this;

  /**
   * Auth token.
   */
  token: string;

  /**
   * Auth containerID.
   */
  containerID: string;

  /**
   * Creates a new Auth instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Auth instance
   */
  static create(properties?: api$IAuth): api$Auth;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Auth message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(message: api$Auth, writer?: $protobuf.Writer): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Auth message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Auth,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an Auth message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Auth
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Auth;

  /**
   * Decodes an Auth message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Auth
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Auth;

  /**
   * Verifies an Auth message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an Auth message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Auth
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Auth;

  /**
   * Creates a plain object from an Auth message. Also converts values to other types if specified.
   * @param message Auth
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Auth,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Auth to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a VCREntry.
 */
declare type api$IVCREntry = {|
  /**
   * VCREntry timestamp
   */
  timestamp?: number | null,

  /**
   * VCREntry direction
   */
  direction?: $Values<typeof api$VCREntry$Direction> | null,

  /**
   * VCREntry command
   */
  command?: api$Command | api$ICommand | null,

  /**
   * VCREntry uid
   */
  uid?: string | null,

  /**
   * VCREntry replid
   */
  replid?: string | null,
|};

/**
 * Represents a VCREntry.
 */
declare class api$VCREntry {
  /**
   * Constructs a new VCREntry.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IVCREntry): this;

  /**
   * VCREntry timestamp.
   */
  timestamp: number;

  /**
   * VCREntry direction.
   */
  direction: $Values<typeof api$VCREntry$Direction>;

  /**
   * VCREntry command.
   */
  command?: api$Command | null;

  /**
   * VCREntry uid.
   */
  uid: string;

  /**
   * VCREntry replid.
   */
  replid: string;

  /**
   * Creates a new VCREntry instance using the specified properties.
   * @param [properties] Properties to set
   * @returns VCREntry instance
   */
  static create(properties?: api$IVCREntry): api$VCREntry;

  /**
   * [object Object],[object Object],[object Object]
   * @param message VCREntry message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$VCREntry,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message VCREntry message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$VCREntry,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a VCREntry message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns VCREntry
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$VCREntry;

  /**
   * Decodes a VCREntry message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns VCREntry
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$VCREntry;

  /**
   * Verifies a VCREntry message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a VCREntry message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns VCREntry
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$VCREntry;

  /**
   * Creates a plain object from a VCREntry message. Also converts values to other types if specified.
   * @param message VCREntry
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$VCREntry,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this VCREntry to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Direction: typeof api$VCREntry$Direction;
}

/**
 * Direction enum.
 */

declare var api$VCREntry$Direction: {|
  +IN: 0, // 0
  +OUT: 1, // 1
|};

/**
 * Properties of a StartVCR.
 */
declare type api$IStartVCR = {||};

/**
 * Represents a StartVCR.
 */
declare class api$StartVCR {
  /**
   * Constructs a new StartVCR.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IStartVCR): this;

  /**
   * Creates a new StartVCR instance using the specified properties.
   * @param [properties] Properties to set
   * @returns StartVCR instance
   */
  static create(properties?: api$IStartVCR): api$StartVCR;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StartVCR message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$StartVCR,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StartVCR message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$StartVCR,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a StartVCR message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns StartVCR
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$StartVCR;

  /**
   * Decodes a StartVCR message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns StartVCR
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$StartVCR;

  /**
   * Verifies a StartVCR message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a StartVCR message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns StartVCR
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$StartVCR;

  /**
   * Creates a plain object from a StartVCR message. Also converts values to other types if specified.
   * @param message StartVCR
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$StartVCR,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this StartVCR to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReadVCR.
 */
declare type api$IReadVCR = {||};

/**
 * Represents a ReadVCR.
 */
declare class api$ReadVCR {
  /**
   * Constructs a new ReadVCR.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IReadVCR): this;

  /**
   * Creates a new ReadVCR instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReadVCR instance
   */
  static create(properties?: api$IReadVCR): api$ReadVCR;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReadVCR message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ReadVCR,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReadVCR message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ReadVCR,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReadVCR message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReadVCR
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ReadVCR;

  /**
   * Decodes a ReadVCR message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReadVCR
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$ReadVCR;

  /**
   * Verifies a ReadVCR message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReadVCR message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReadVCR
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ReadVCR;

  /**
   * Creates a plain object from a ReadVCR message. Also converts values to other types if specified.
   * @param message ReadVCR
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ReadVCR,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReadVCR to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a VCRLog.
 */
declare type api$IVCRLog = {|
  /**
   * VCRLog log
   */
  log?: (api$VCREntry | api$IVCREntry)[] | null,

  /**
   * VCRLog logfile
   */
  logfile?: api$File | api$IFile | null,
|};

/**
 * Represents a VCRLog.
 */
declare class api$VCRLog {
  /**
   * Constructs a new VCRLog.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IVCRLog): this;

  /**
   * VCRLog log.
   */
  log: api$VCREntry[];

  /**
   * VCRLog logfile.
   */
  logfile?: api$File | null;

  /**
   * Creates a new VCRLog instance using the specified properties.
   * @param [properties] Properties to set
   * @returns VCRLog instance
   */
  static create(properties?: api$IVCRLog): api$VCRLog;

  /**
   * [object Object],[object Object],[object Object]
   * @param message VCRLog message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$VCRLog,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message VCRLog message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$VCRLog,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a VCRLog message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns VCRLog
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$VCRLog;

  /**
   * Decodes a VCRLog message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns VCRLog
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$VCRLog;

  /**
   * Verifies a VCRLog message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a VCRLog message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns VCRLog
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$VCRLog;

  /**
   * Creates a plain object from a VCRLog message. Also converts values to other types if specified.
   * @param message VCRLog
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$VCRLog,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this VCRLog to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an ExecInfo.
 */
declare type api$IExecInfo = {|
  /**
   * ExecInfo command
   */
  command?: string[] | null,

  /**
   * ExecInfo reason
   */
  reason?: string | null,
|};

/**
 * Represents an ExecInfo.
 */
declare class api$ExecInfo {
  /**
   * Constructs a new ExecInfo.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IExecInfo): this;

  /**
   * ExecInfo command.
   */
  command: string[];

  /**
   * ExecInfo reason.
   */
  reason: string;

  /**
   * Creates a new ExecInfo instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ExecInfo instance
   */
  static create(properties?: api$IExecInfo): api$ExecInfo;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ExecInfo message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ExecInfo,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ExecInfo message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ExecInfo,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an ExecInfo message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ExecInfo
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ExecInfo;

  /**
   * Decodes an ExecInfo message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ExecInfo
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$ExecInfo;

  /**
   * Verifies an ExecInfo message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an ExecInfo message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ExecInfo
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ExecInfo;

  /**
   * Creates a plain object from an ExecInfo message. Also converts values to other types if specified.
   * @param message ExecInfo
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ExecInfo,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ExecInfo to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Debug.
 */
declare type api$IDebug = {|
  /**
   * Debug text
   */
  text?: string | null,
|};

/**
 * Represents a Debug.
 */
declare class api$Debug {
  /**
   * Constructs a new Debug.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebug): this;

  /**
   * Debug text.
   */
  text: string;

  /**
   * Creates a new Debug instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Debug instance
   */
  static create(properties?: api$IDebug): api$Debug;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Debug message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Debug,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Debug message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Debug,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Debug message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Debug
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Debug;

  /**
   * Decodes a Debug message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Debug
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Debug;

  /**
   * Verifies a Debug message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Debug message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Debug
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Debug;

  /**
   * Creates a plain object from a Debug message. Also converts values to other types if specified.
   * @param message Debug
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Debug,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Debug to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * FileAuthMethod enum.
 */

declare var api$FileAuthMethod: {|
  +GET: 0, // 0
  +HEAD: 1, // 1
  +PUT: 2, // 2
  +DELETE: 3, // 3
|};

/**
 * Properties of a FileAuthReq.
 */
declare type api$IFileAuthReq = {|
  /**
   * FileAuthReq file
   */
  file?: api$File | api$IFile | null,

  /**
   * FileAuthReq method
   */
  method?: $Values<typeof api$FileAuthMethod> | null,
|};

/**
 * Represents a FileAuthReq.
 */
declare class api$FileAuthReq {
  /**
   * Constructs a new FileAuthReq.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IFileAuthReq): this;

  /**
   * FileAuthReq file.
   */
  file?: api$File | null;

  /**
   * FileAuthReq method.
   */
  method: $Values<typeof api$FileAuthMethod>;

  /**
   * Creates a new FileAuthReq instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FileAuthReq instance
   */
  static create(properties?: api$IFileAuthReq): api$FileAuthReq;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileAuthReq message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$FileAuthReq,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileAuthReq message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$FileAuthReq,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FileAuthReq message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FileAuthReq
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$FileAuthReq;

  /**
   * Decodes a FileAuthReq message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FileAuthReq
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$FileAuthReq;

  /**
   * Verifies a FileAuthReq message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FileAuthReq message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FileAuthReq
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$FileAuthReq;

  /**
   * Creates a plain object from a FileAuthReq message. Also converts values to other types if specified.
   * @param message FileAuthReq
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$FileAuthReq,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FileAuthReq to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a MultiFileAuthRes.
 */
declare type api$IMultiFileAuthRes = {|
  /**
   * MultiFileAuthRes put
   */
  put?: api$FileAuthRes | api$IFileAuthRes | null,

  /**
   * MultiFileAuthRes del
   */
  del?: api$FileAuthRes | api$IFileAuthRes | null,

  /**
   * MultiFileAuthRes get
   */
  get?: api$FileAuthRes | api$IFileAuthRes | null,
|};

/**
 * Represents a MultiFileAuthRes.
 */
declare class api$MultiFileAuthRes {
  /**
   * Constructs a new MultiFileAuthRes.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IMultiFileAuthRes): this;

  /**
   * MultiFileAuthRes put.
   */
  put?: api$FileAuthRes | null;

  /**
   * MultiFileAuthRes del.
   */
  del?: api$FileAuthRes | null;

  /**
   * MultiFileAuthRes get.
   */
  get?: api$FileAuthRes | null;

  /**
   * Creates a new MultiFileAuthRes instance using the specified properties.
   * @param [properties] Properties to set
   * @returns MultiFileAuthRes instance
   */
  static create(properties?: api$IMultiFileAuthRes): api$MultiFileAuthRes;

  /**
   * [object Object],[object Object],[object Object]
   * @param message MultiFileAuthRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$MultiFileAuthRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message MultiFileAuthRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$MultiFileAuthRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a MultiFileAuthRes message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns MultiFileAuthRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$MultiFileAuthRes;

  /**
   * Decodes a MultiFileAuthRes message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns MultiFileAuthRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$MultiFileAuthRes;

  /**
   * Verifies a MultiFileAuthRes message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a MultiFileAuthRes message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns MultiFileAuthRes
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$MultiFileAuthRes;

  /**
   * Creates a plain object from a MultiFileAuthRes message. Also converts values to other types if specified.
   * @param message MultiFileAuthRes
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$MultiFileAuthRes,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this MultiFileAuthRes to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FileAuthRes.
 */
declare type api$IFileAuthRes = {|
  /**
   * FileAuthRes file
   */
  file?: api$File | api$IFile | null,

  /**
   * FileAuthRes url
   */
  url?: string | null,

  /**
   * FileAuthRes method
   */
  method?: $Values<typeof api$FileAuthMethod> | null,

  /**
   * FileAuthRes expire
   */
  expire?: number | null,

  /**
   * FileAuthRes error
   */
  error?: string | null,

  /**
   * FileAuthRes replError
   */
  replError?: boolean | null,
|};

/**
 * Represents a FileAuthRes.
 */
declare class api$FileAuthRes {
  /**
   * Constructs a new FileAuthRes.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IFileAuthRes): this;

  /**
   * FileAuthRes file.
   */
  file?: api$File | null;

  /**
   * FileAuthRes url.
   */
  url: string;

  /**
   * FileAuthRes method.
   */
  method: $Values<typeof api$FileAuthMethod>;

  /**
   * FileAuthRes expire.
   */
  expire: number;

  /**
   * FileAuthRes error.
   */
  error: string;

  /**
   * FileAuthRes replError.
   */
  replError: boolean;

  /**
   * Creates a new FileAuthRes instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FileAuthRes instance
   */
  static create(properties?: api$IFileAuthRes): api$FileAuthRes;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileAuthRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$FileAuthRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileAuthRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$FileAuthRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FileAuthRes message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FileAuthRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$FileAuthRes;

  /**
   * Decodes a FileAuthRes message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FileAuthRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$FileAuthRes;

  /**
   * Verifies a FileAuthRes message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FileAuthRes message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FileAuthRes
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$FileAuthRes;

  /**
   * Creates a plain object from a FileAuthRes message. Also converts values to other types if specified.
   * @param message FileAuthRes
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$FileAuthRes,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FileAuthRes to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ListObjects.
 */
declare type api$IListObjects = {|
  /**
   * ListObjects prefix
   */
  prefix?: string | null,
|};

/**
 * Represents a ListObjects.
 */
declare class api$ListObjects {
  /**
   * Constructs a new ListObjects.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IListObjects): this;

  /**
   * ListObjects prefix.
   */
  prefix: string;

  /**
   * Creates a new ListObjects instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ListObjects instance
   */
  static create(properties?: api$IListObjects): api$ListObjects;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ListObjects message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ListObjects,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ListObjects message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ListObjects,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ListObjects message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ListObjects
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ListObjects;

  /**
   * Decodes a ListObjects message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ListObjects
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ListObjects;

  /**
   * Verifies a ListObjects message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ListObjects message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ListObjects
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ListObjects;

  /**
   * Creates a plain object from a ListObjects message. Also converts values to other types if specified.
   * @param message ListObjects
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ListObjects,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ListObjects to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ListObjectsResp.
 */
declare type api$IListObjectsResp = {|
  /**
   * ListObjectsResp objects
   */
  objects?: string[] | null,
|};

/**
 * Represents a ListObjectsResp.
 */
declare class api$ListObjectsResp {
  /**
   * Constructs a new ListObjectsResp.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IListObjectsResp): this;

  /**
   * ListObjectsResp objects.
   */
  objects: string[];

  /**
   * Creates a new ListObjectsResp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ListObjectsResp instance
   */
  static create(properties?: api$IListObjectsResp): api$ListObjectsResp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ListObjectsResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ListObjectsResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ListObjectsResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ListObjectsResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ListObjectsResp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ListObjectsResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ListObjectsResp;

  /**
   * Decodes a ListObjectsResp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ListObjectsResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ListObjectsResp;

  /**
   * Verifies a ListObjectsResp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ListObjectsResp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ListObjectsResp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ListObjectsResp;

  /**
   * Creates a plain object from a ListObjectsResp message. Also converts values to other types if specified.
   * @param message ListObjectsResp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ListObjectsResp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ListObjectsResp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Disconnect.
 */
declare type api$IDisconnect = {|
  /**
   * Disconnect error
   */
  error?: string | null,
|};

/**
 * Represents a Disconnect.
 */
declare class api$Disconnect {
  /**
   * Constructs a new Disconnect.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDisconnect): this;

  /**
   * Disconnect error.
   */
  error: string;

  /**
   * Creates a new Disconnect instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Disconnect instance
   */
  static create(properties?: api$IDisconnect): api$Disconnect;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Disconnect message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Disconnect,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Disconnect message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Disconnect,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Disconnect message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Disconnect
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Disconnect;

  /**
   * Decodes a Disconnect message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Disconnect
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Disconnect;

  /**
   * Verifies a Disconnect message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Disconnect message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Disconnect
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Disconnect;

  /**
   * Creates a plain object from a Disconnect message. Also converts values to other types if specified.
   * @param message Disconnect
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Disconnect,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Disconnect to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Send.
 */
declare type api$ISend = {|
  /**
   * Send buff
   */
  buff?: Uint8Array | null,
|};

/**
 * Represents a Send.
 */
declare class api$Send {
  /**
   * Constructs a new Send.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ISend): this;

  /**
   * Send buff.
   */
  buff: Uint8Array;

  /**
   * Creates a new Send instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Send instance
   */
  static create(properties?: api$ISend): api$Send;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Send message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(message: api$Send, writer?: $protobuf.Writer): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Send message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Send,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Send message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Send
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Send;

  /**
   * Decodes a Send message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Send
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Send;

  /**
   * Verifies a Send message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Send message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Send
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Send;

  /**
   * Creates a plain object from a Send message. Also converts values to other types if specified.
   * @param message Send
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Send,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Send to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Recv.
 */
declare type api$IRecv = {|
  /**
   * Recv buff
   */
  buff?: Uint8Array | null,
|};

/**
 * Represents a Recv.
 */
declare class api$Recv {
  /**
   * Constructs a new Recv.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IRecv): this;

  /**
   * Recv buff.
   */
  buff: Uint8Array;

  /**
   * Creates a new Recv instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Recv instance
   */
  static create(properties?: api$IRecv): api$Recv;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Recv message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(message: api$Recv, writer?: $protobuf.Writer): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Recv message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Recv,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Recv message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Recv
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Recv;

  /**
   * Decodes a Recv message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Recv
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Recv;

  /**
   * Verifies a Recv message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Recv message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Recv
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Recv;

  /**
   * Creates a plain object from a Recv message. Also converts values to other types if specified.
   * @param message Recv
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Recv,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Recv to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Connect.
 */
declare type api$IConnect = {|
  /**
   * Connect proto
   */
  proto?: string | null,

  /**
   * Connect addr
   */
  addr?: string | null,
|};

/**
 * Represents a Connect.
 */
declare class api$Connect {
  /**
   * Constructs a new Connect.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IConnect): this;

  /**
   * Connect proto.
   */
  proto: string;

  /**
   * Connect addr.
   */
  addr: string;

  /**
   * Creates a new Connect instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Connect instance
   */
  static create(properties?: api$IConnect): api$Connect;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Connect message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Connect,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Connect message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Connect,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Connect message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Connect
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Connect;

  /**
   * Decodes a Connect message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Connect
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Connect;

  /**
   * Verifies a Connect message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Connect message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Connect
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Connect;

  /**
   * Creates a plain object from a Connect message. Also converts values to other types if specified.
   * @param message Connect
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Connect,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Connect to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Hint.
 */
declare type api$IHint = {|
  /**
   * Hint text
   */
  text?: string | null,
|};

/**
 * Represents a Hint.
 */
declare class api$Hint {
  /**
   * Constructs a new Hint.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IHint): this;

  /**
   * Hint text.
   */
  text: string;

  /**
   * Creates a new Hint instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Hint instance
   */
  static create(properties?: api$IHint): api$Hint;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Hint message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(message: api$Hint, writer?: $protobuf.Writer): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Hint message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Hint,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Hint message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Hint
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Hint;

  /**
   * Decodes a Hint message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Hint
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Hint;

  /**
   * Verifies a Hint message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Hint message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Hint
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Hint;

  /**
   * Creates a plain object from a Hint message. Also converts values to other types if specified.
   * @param message Hint
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Hint,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Hint to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Ping.
 */
declare type api$IPing = {||};

/**
 * Represents a Ping.
 */
declare class api$Ping {
  /**
   * Constructs a new Ping.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPing): this;

  /**
   * Creates a new Ping instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Ping instance
   */
  static create(properties?: api$IPing): api$Ping;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Ping message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(message: api$Ping, writer?: $protobuf.Writer): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Ping message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Ping,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Ping message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Ping
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Ping;

  /**
   * Decodes a Ping message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Ping
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Ping;

  /**
   * Verifies a Ping message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Ping message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Ping
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Ping;

  /**
   * Creates a plain object from a Ping message. Also converts values to other types if specified.
   * @param message Ping
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Ping,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Ping to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Pong.
 */
declare type api$IPong = {||};

/**
 * Represents a Pong.
 */
declare class api$Pong {
  /**
   * Constructs a new Pong.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPong): this;

  /**
   * Creates a new Pong instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Pong instance
   */
  static create(properties?: api$IPong): api$Pong;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Pong message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(message: api$Pong, writer?: $protobuf.Writer): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Pong message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Pong,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Pong message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Pong
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Pong;

  /**
   * Decodes a Pong message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Pong
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Pong;

  /**
   * Verifies a Pong message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Pong message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Pong
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Pong;

  /**
   * Creates a plain object from a Pong message. Also converts values to other types if specified.
   * @param message Pong
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Pong,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Pong to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Hello.
 */
declare type api$IHello = {|
  /**
   * Hello userid
   */
  userid?: number | null,

  /**
   * Hello username
   */
  username?: string | null,

  /**
   * Hello token
   */
  token?: string | null,
|};

/**
 * Represents a Hello.
 */
declare class api$Hello {
  /**
   * Constructs a new Hello.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IHello): this;

  /**
   * Hello userid.
   */
  userid: number;

  /**
   * Hello username.
   */
  username: string;

  /**
   * Hello token.
   */
  token: string;

  /**
   * Creates a new Hello instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Hello instance
   */
  static create(properties?: api$IHello): api$Hello;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Hello message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Hello,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Hello message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Hello,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Hello message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Hello
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Hello;

  /**
   * Decodes a Hello message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Hello
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Hello;

  /**
   * Verifies a Hello message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Hello message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Hello
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Hello;

  /**
   * Creates a plain object from a Hello message. Also converts values to other types if specified.
   * @param message Hello
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Hello,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Hello to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Goodbye.
 */
declare type api$IGoodbye = {||};

/**
 * Represents a Goodbye.
 */
declare class api$Goodbye {
  /**
   * Constructs a new Goodbye.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IGoodbye): this;

  /**
   * Creates a new Goodbye instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Goodbye instance
   */
  static create(properties?: api$IGoodbye): api$Goodbye;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Goodbye message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Goodbye,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Goodbye message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Goodbye,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Goodbye message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Goodbye
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Goodbye;

  /**
   * Decodes a Goodbye message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Goodbye
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Goodbye;

  /**
   * Verifies a Goodbye message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Goodbye message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Goodbye
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Goodbye;

  /**
   * Creates a plain object from a Goodbye message. Also converts values to other types if specified.
   * @param message Goodbye
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Goodbye,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Goodbye to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * State enum.
 */

declare var api$State: {|
  +Stopped: 0, // 0
  +Running: 1, // 1
|};

/**
 * Properties of a CheckChanges.
 */
declare type api$ICheckChanges = {||};

/**
 * Represents a CheckChanges.
 */
declare class api$CheckChanges {
  /**
   * Constructs a new CheckChanges.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ICheckChanges): this;

  /**
   * Creates a new CheckChanges instance using the specified properties.
   * @param [properties] Properties to set
   * @returns CheckChanges instance
   */
  static create(properties?: api$ICheckChanges): api$CheckChanges;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CheckChanges message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$CheckChanges,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CheckChanges message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$CheckChanges,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a CheckChanges message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns CheckChanges
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$CheckChanges;

  /**
   * Decodes a CheckChanges message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns CheckChanges
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$CheckChanges;

  /**
   * Verifies a CheckChanges message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a CheckChanges message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns CheckChanges
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$CheckChanges;

  /**
   * Creates a plain object from a CheckChanges message. Also converts values to other types if specified.
   * @param message CheckChanges
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$CheckChanges,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this CheckChanges to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an EnsurePackages.
 */
declare type api$IEnsurePackages = {|
  /**
   * EnsurePackages install
   */
  install?: boolean | null,

  /**
   * EnsurePackages file
   */
  file?: api$File | api$IFile | null,
|};

/**
 * Represents an EnsurePackages.
 */
declare class api$EnsurePackages {
  /**
   * Constructs a new EnsurePackages.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IEnsurePackages): this;

  /**
   * EnsurePackages install.
   */
  install: boolean;

  /**
   * EnsurePackages file.
   */
  file?: api$File | null;

  /**
   * Creates a new EnsurePackages instance using the specified properties.
   * @param [properties] Properties to set
   * @returns EnsurePackages instance
   */
  static create(properties?: api$IEnsurePackages): api$EnsurePackages;

  /**
   * [object Object],[object Object],[object Object]
   * @param message EnsurePackages message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$EnsurePackages,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message EnsurePackages message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$EnsurePackages,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an EnsurePackages message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns EnsurePackages
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$EnsurePackages;

  /**
   * Decodes an EnsurePackages message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns EnsurePackages
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$EnsurePackages;

  /**
   * Verifies an EnsurePackages message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an EnsurePackages message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns EnsurePackages
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$EnsurePackages;

  /**
   * Creates a plain object from an EnsurePackages message. Also converts values to other types if specified.
   * @param message EnsurePackages
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$EnsurePackages,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this EnsurePackages to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Start.
 */
declare type api$IStart = {||};

/**
 * Represents a Start.
 */
declare class api$Start {
  /**
   * Constructs a new Start.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IStart): this;

  /**
   * Creates a new Start instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Start instance
   */
  static create(properties?: api$IStart): api$Start;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Start message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Start,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Start message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Start,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Start message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Start
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Start;

  /**
   * Decodes a Start message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Start
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Start;

  /**
   * Verifies a Start message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Start message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Start
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Start;

  /**
   * Creates a plain object from a Start message. Also converts values to other types if specified.
   * @param message Start
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Start,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Start to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugStatus.
 */
declare type api$IDebugStatus = {|
  /**
   * DebugStatus done
   */
  done?: boolean | null,

  /**
   * DebugStatus stack
   */
  stack?: (api$StackFrame | api$IStackFrame)[] | null,
|};

/**
 * Represents a DebugStatus.
 */
declare class api$DebugStatus {
  /**
   * Constructs a new DebugStatus.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebugStatus): this;

  /**
   * DebugStatus done.
   */
  done: boolean;

  /**
   * DebugStatus stack.
   */
  stack: api$StackFrame[];

  /**
   * Creates a new DebugStatus instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugStatus instance
   */
  static create(properties?: api$IDebugStatus): api$DebugStatus;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugStatus message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DebugStatus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugStatus message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DebugStatus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugStatus message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugStatus
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DebugStatus;

  /**
   * Decodes a DebugStatus message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugStatus
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DebugStatus;

  /**
   * Verifies a DebugStatus message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugStatus message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugStatus
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DebugStatus;

  /**
   * Creates a plain object from a DebugStatus message. Also converts values to other types if specified.
   * @param message DebugStatus
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DebugStatus,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugStatus to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a StackFrame.
 */
declare type api$IStackFrame = {|
  /**
   * StackFrame function
   */
  function?: string | null,

  /**
   * StackFrame line
   */
  line?: number | null,
|};

/**
 * Represents a StackFrame.
 */
declare class api$StackFrame {
  /**
   * Constructs a new StackFrame.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IStackFrame): this;

  /**
   * StackFrame function.
   */
  function: string;

  /**
   * StackFrame line.
   */
  line: number;

  /**
   * Creates a new StackFrame instance using the specified properties.
   * @param [properties] Properties to set
   * @returns StackFrame instance
   */
  static create(properties?: api$IStackFrame): api$StackFrame;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StackFrame message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$StackFrame,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StackFrame message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$StackFrame,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a StackFrame message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns StackFrame
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$StackFrame;

  /**
   * Decodes a StackFrame message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns StackFrame
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$StackFrame;

  /**
   * Verifies a StackFrame message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a StackFrame message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns StackFrame
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$StackFrame;

  /**
   * Creates a plain object from a StackFrame message. Also converts values to other types if specified.
   * @param message StackFrame
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$StackFrame,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this StackFrame to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ContainedTest.
 */
declare type api$IContainedTest = {|
  /**
   * ContainedTest suite
   */
  suite?: api$File | api$IFile | null,

  /**
   * ContainedTest project
   */
  project?: (api$File | api$IFile)[] | null,
|};

/**
 * Represents a ContainedTest.
 */
declare class api$ContainedTest {
  /**
   * Constructs a new ContainedTest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IContainedTest): this;

  /**
   * ContainedTest suite.
   */
  suite?: api$File | null;

  /**
   * ContainedTest project.
   */
  project: api$File[];

  /**
   * Creates a new ContainedTest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ContainedTest instance
   */
  static create(properties?: api$IContainedTest): api$ContainedTest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ContainedTest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ContainedTest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ContainedTest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ContainedTest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ContainedTest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ContainedTest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ContainedTest;

  /**
   * Decodes a ContainedTest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ContainedTest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ContainedTest;

  /**
   * Verifies a ContainedTest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ContainedTest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ContainedTest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ContainedTest;

  /**
   * Creates a plain object from a ContainedTest message. Also converts values to other types if specified.
   * @param message ContainedTest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ContainedTest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ContainedTest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a TestResult.
 */
declare type api$ITestResult = {|
  /**
   * TestResult passed
   */
  passed?: boolean | null,

  /**
   * TestResult stderr
   */
  stderr?: string | null,

  /**
   * TestResult fails
   */
  fails?: (api$TestFailure | api$ITestFailure)[] | null,
|};

/**
 * Represents a TestResult.
 */
declare class api$TestResult {
  /**
   * Constructs a new TestResult.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ITestResult): this;

  /**
   * TestResult passed.
   */
  passed: boolean;

  /**
   * TestResult stderr.
   */
  stderr: string;

  /**
   * TestResult fails.
   */
  fails: api$TestFailure[];

  /**
   * Creates a new TestResult instance using the specified properties.
   * @param [properties] Properties to set
   * @returns TestResult instance
   */
  static create(properties?: api$ITestResult): api$TestResult;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TestResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$TestResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TestResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$TestResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a TestResult message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns TestResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$TestResult;

  /**
   * Decodes a TestResult message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns TestResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$TestResult;

  /**
   * Verifies a TestResult message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a TestResult message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns TestResult
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$TestResult;

  /**
   * Creates a plain object from a TestResult message. Also converts values to other types if specified.
   * @param message TestResult
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$TestResult,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this TestResult to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a TestFailure.
 */
declare type api$ITestFailure = {|
  /**
   * TestFailure name
   */
  name?: string | null,

  /**
   * TestFailure trace
   */
  trace?: string | null,
|};

/**
 * Represents a TestFailure.
 */
declare class api$TestFailure {
  /**
   * Constructs a new TestFailure.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ITestFailure): this;

  /**
   * TestFailure name.
   */
  name: string;

  /**
   * TestFailure trace.
   */
  trace: string;

  /**
   * Creates a new TestFailure instance using the specified properties.
   * @param [properties] Properties to set
   * @returns TestFailure instance
   */
  static create(properties?: api$ITestFailure): api$TestFailure;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TestFailure message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$TestFailure,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TestFailure message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$TestFailure,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a TestFailure message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns TestFailure
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$TestFailure;

  /**
   * Decodes a TestFailure message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns TestFailure
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$TestFailure;

  /**
   * Verifies a TestFailure message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a TestFailure message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns TestFailure
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$TestFailure;

  /**
   * Creates a plain object from a TestFailure message. Also converts values to other types if specified.
   * @param message TestFailure
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$TestFailure,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this TestFailure to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ResizeTerm.
 */
declare type api$IResizeTerm = {|
  /**
   * ResizeTerm rows
   */
  rows?: number | null,

  /**
   * ResizeTerm cols
   */
  cols?: number | null,
|};

/**
 * Represents a ResizeTerm.
 */
declare class api$ResizeTerm {
  /**
   * Constructs a new ResizeTerm.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IResizeTerm): this;

  /**
   * ResizeTerm rows.
   */
  rows: number;

  /**
   * ResizeTerm cols.
   */
  cols: number;

  /**
   * Creates a new ResizeTerm instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ResizeTerm instance
   */
  static create(properties?: api$IResizeTerm): api$ResizeTerm;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ResizeTerm message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ResizeTerm,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ResizeTerm message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ResizeTerm,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ResizeTerm message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ResizeTerm
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ResizeTerm;

  /**
   * Decodes a ResizeTerm message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ResizeTerm
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$ResizeTerm;

  /**
   * Verifies a ResizeTerm message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ResizeTerm message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ResizeTerm
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ResizeTerm;

  /**
   * Creates a plain object from a ResizeTerm message. Also converts values to other types if specified.
   * @param message ResizeTerm
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ResizeTerm,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ResizeTerm to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a SaneTerm.
 */
declare type api$ISaneTerm = {||};

/**
 * Represents a SaneTerm.
 */
declare class api$SaneTerm {
  /**
   * Constructs a new SaneTerm.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ISaneTerm): this;

  /**
   * Creates a new SaneTerm instance using the specified properties.
   * @param [properties] Properties to set
   * @returns SaneTerm instance
   */
  static create(properties?: api$ISaneTerm): api$SaneTerm;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SaneTerm message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$SaneTerm,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SaneTerm message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$SaneTerm,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a SaneTerm message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns SaneTerm
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$SaneTerm;

  /**
   * Decodes a SaneTerm message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns SaneTerm
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$SaneTerm;

  /**
   * Verifies a SaneTerm message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a SaneTerm message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns SaneTerm
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$SaneTerm;

  /**
   * Creates a plain object from a SaneTerm message. Also converts values to other types if specified.
   * @param message SaneTerm
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$SaneTerm,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this SaneTerm to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a LintResults.
 */
declare type api$ILintResults = {|
  /**
   * LintResults results
   */
  results?: (api$LintResult | api$ILintResult)[] | null,
|};

/**
 * Represents a LintResults.
 */
declare class api$LintResults {
  /**
   * Constructs a new LintResults.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ILintResults): this;

  /**
   * LintResults results.
   */
  results: api$LintResult[];

  /**
   * Creates a new LintResults instance using the specified properties.
   * @param [properties] Properties to set
   * @returns LintResults instance
   */
  static create(properties?: api$ILintResults): api$LintResults;

  /**
   * [object Object],[object Object],[object Object]
   * @param message LintResults message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$LintResults,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message LintResults message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$LintResults,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a LintResults message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns LintResults
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$LintResults;

  /**
   * Decodes a LintResults message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns LintResults
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$LintResults;

  /**
   * Verifies a LintResults message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a LintResults message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns LintResults
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$LintResults;

  /**
   * Creates a plain object from a LintResults message. Also converts values to other types if specified.
   * @param message LintResults
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$LintResults,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this LintResults to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a LintResult.
 */
declare type api$ILintResult = {|
  /**
   * LintResult text
   */
  text?: string | null,

  /**
   * LintResult row
   */
  row?: number | null,

  /**
   * LintResult column
   */
  column?: number | null,

  /**
   * LintResult type
   */
  type?: string | null,
|};

/**
 * Represents a LintResult.
 */
declare class api$LintResult {
  /**
   * Constructs a new LintResult.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ILintResult): this;

  /**
   * LintResult text.
   */
  text: string;

  /**
   * LintResult row.
   */
  row: number;

  /**
   * LintResult column.
   */
  column: number;

  /**
   * LintResult type.
   */
  type: string;

  /**
   * Creates a new LintResult instance using the specified properties.
   * @param [properties] Properties to set
   * @returns LintResult instance
   */
  static create(properties?: api$ILintResult): api$LintResult;

  /**
   * [object Object],[object Object],[object Object]
   * @param message LintResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$LintResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message LintResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$LintResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a LintResult message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns LintResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$LintResult;

  /**
   * Decodes a LintResult message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns LintResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$LintResult;

  /**
   * Verifies a LintResult message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a LintResult message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns LintResult
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$LintResult;

  /**
   * Creates a plain object from a LintResult message. Also converts values to other types if specified.
   * @param message LintResult
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$LintResult,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this LintResult to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OK.
 */
declare type api$IOK = {||};

/**
 * Represents a OK.
 */
declare class api$OK {
  /**
   * Constructs a new OK.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IOK): this;

  /**
   * Creates a new OK instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OK instance
   */
  static create(properties?: api$IOK): api$OK;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OK message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(message: api$OK, writer?: $protobuf.Writer): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OK message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$OK,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OK message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OK
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): api$OK;

  /**
   * Decodes a OK message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OK
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$OK;

  /**
   * Verifies a OK message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OK message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OK
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$OK;

  /**
   * Creates a plain object from a OK message. Also converts values to other types if specified.
   * @param message OK
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$OK,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OK to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Move.
 */
declare type api$IMove = {|
  /**
   * Move oldPath
   */
  oldPath?: string | null,

  /**
   * Move newPath
   */
  newPath?: string | null,
|};

/**
 * Represents a Move.
 */
declare class api$Move {
  /**
   * Constructs a new Move.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IMove): this;

  /**
   * Move oldPath.
   */
  oldPath: string;

  /**
   * Move newPath.
   */
  newPath: string;

  /**
   * Creates a new Move instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Move instance
   */
  static create(properties?: api$IMove): api$Move;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Move message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(message: api$Move, writer?: $protobuf.Writer): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Move message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Move,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Move message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Move
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Move;

  /**
   * Decodes a Move message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Move
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Move;

  /**
   * Verifies a Move message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Move message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Move
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Move;

  /**
   * Creates a plain object from a Move message. Also converts values to other types if specified.
   * @param message Move
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Move,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Move to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Files.
 */
declare type api$IFiles = {|
  /**
   * Files files
   */
  files?: (api$File | api$IFile)[] | null,
|};

/**
 * Represents a Files.
 */
declare class api$Files {
  /**
   * Constructs a new Files.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IFiles): this;

  /**
   * Files files.
   */
  files: api$File[];

  /**
   * Creates a new Files instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Files instance
   */
  static create(properties?: api$IFiles): api$Files;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Files message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Files,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Files message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Files,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Files message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Files
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Files;

  /**
   * Decodes a Files message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Files
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Files;

  /**
   * Verifies a Files message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Files message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Files
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Files;

  /**
   * Creates a plain object from a Files message. Also converts values to other types if specified.
   * @param message Files
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Files,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Files to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a StatResult.
 */
declare type api$IStatResult = {|
  /**
   * StatResult exists
   */
  exists?: boolean | null,

  /**
   * StatResult type
   */
  type?: $Values<typeof api$File$Type> | null,

  /**
   * StatResult size
   */
  size?: number | null,

  /**
   * StatResult fileMode
   */
  fileMode?: string | null,

  /**
   * StatResult modTime
   */
  modTime?: number | null,
|};

/**
 * Represents a StatResult.
 */
declare class api$StatResult {
  /**
   * Constructs a new StatResult.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IStatResult): this;

  /**
   * StatResult exists.
   */
  exists: boolean;

  /**
   * StatResult type.
   */
  type: $Values<typeof api$File$Type>;

  /**
   * StatResult size.
   */
  size: number;

  /**
   * StatResult fileMode.
   */
  fileMode: string;

  /**
   * StatResult modTime.
   */
  modTime: number;

  /**
   * Creates a new StatResult instance using the specified properties.
   * @param [properties] Properties to set
   * @returns StatResult instance
   */
  static create(properties?: api$IStatResult): api$StatResult;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StatResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$StatResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message StatResult message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$StatResult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a StatResult message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns StatResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$StatResult;

  /**
   * Decodes a StatResult message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns StatResult
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$StatResult;

  /**
   * Verifies a StatResult message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a StatResult message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns StatResult
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$StatResult;

  /**
   * Creates a plain object from a StatResult message. Also converts values to other types if specified.
   * @param message StatResult
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$StatResult,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this StatResult to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a File.
 */
declare type api$IFile = {|
  /**
   * File path
   */
  path?: string | null,

  /**
   * File type
   */
  type?: $Values<typeof api$File$Type> | null,

  /**
   * File content
   */
  content?: Uint8Array | null,
|};

/**
 * Represents a File.
 */
declare class api$File {
  /**
   * Constructs a new File.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IFile): this;

  /**
   * File path.
   */
  path: string;

  /**
   * File type.
   */
  type: $Values<typeof api$File$Type>;

  /**
   * File content.
   */
  content: Uint8Array;

  /**
   * Creates a new File instance using the specified properties.
   * @param [properties] Properties to set
   * @returns File instance
   */
  static create(properties?: api$IFile): api$File;

  /**
   * [object Object],[object Object],[object Object]
   * @param message File message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(message: api$File, writer?: $protobuf.Writer): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message File message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$File,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a File message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns File
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$File;

  /**
   * Decodes a File message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns File
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$File;

  /**
   * Verifies a File message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a File message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns File
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$File;

  /**
   * Creates a plain object from a File message. Also converts values to other types if specified.
   * @param message File
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$File,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this File to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Type: typeof api$File$Type;
}

/**
 * Type enum.
 */

declare var api$File$Type: {|
  +REGULAR: 0, // 0
  +DIRECTORY: 1, // 1
|};

/**
 * Properties of a Transfer.
 */
declare type api$ITransfer = {|
  /**
   * Transfer id
   */
  id?: string | null,
|};

/**
 * Represents a Transfer.
 */
declare class api$Transfer {
  /**
   * Constructs a new Transfer.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ITransfer): this;

  /**
   * Transfer id.
   */
  id: string;

  /**
   * Creates a new Transfer instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Transfer instance
   */
  static create(properties?: api$ITransfer): api$Transfer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Transfer message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Transfer,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Transfer message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Transfer,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Transfer message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Transfer
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Transfer;

  /**
   * Decodes a Transfer message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Transfer
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Transfer;

  /**
   * Verifies a Transfer message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Transfer message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Transfer
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Transfer;

  /**
   * Creates a plain object from a Transfer message. Also converts values to other types if specified.
   * @param message Transfer
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Transfer,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Transfer to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a TransferStart.
 */
declare type api$ITransferStart = {|
  /**
   * TransferStart path
   */
  path?: string | null,

  /**
   * TransferStart size
   */
  size?: number | null,
|};

/**
 * Represents a TransferStart.
 */
declare class api$TransferStart {
  /**
   * Constructs a new TransferStart.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ITransferStart): this;

  /**
   * TransferStart path.
   */
  path: string;

  /**
   * TransferStart size.
   */
  size: number;

  /**
   * Creates a new TransferStart instance using the specified properties.
   * @param [properties] Properties to set
   * @returns TransferStart instance
   */
  static create(properties?: api$ITransferStart): api$TransferStart;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TransferStart message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$TransferStart,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TransferStart message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$TransferStart,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a TransferStart message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns TransferStart
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$TransferStart;

  /**
   * Decodes a TransferStart message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns TransferStart
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$TransferStart;

  /**
   * Verifies a TransferStart message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a TransferStart message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns TransferStart
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$TransferStart;

  /**
   * Creates a plain object from a TransferStart message. Also converts values to other types if specified.
   * @param message TransferStart
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$TransferStart,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this TransferStart to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a TransferChunk.
 */
declare type api$ITransferChunk = {|
  /**
   * TransferChunk id
   */
  id?: string | null,

  /**
   * TransferChunk content
   */
  content?: Uint8Array | null,
|};

/**
 * Represents a TransferChunk.
 */
declare class api$TransferChunk {
  /**
   * Constructs a new TransferChunk.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ITransferChunk): this;

  /**
   * TransferChunk id.
   */
  id: string;

  /**
   * TransferChunk content.
   */
  content: Uint8Array;

  /**
   * Creates a new TransferChunk instance using the specified properties.
   * @param [properties] Properties to set
   * @returns TransferChunk instance
   */
  static create(properties?: api$ITransferChunk): api$TransferChunk;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TransferChunk message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$TransferChunk,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TransferChunk message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$TransferChunk,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a TransferChunk message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns TransferChunk
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$TransferChunk;

  /**
   * Decodes a TransferChunk message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns TransferChunk
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$TransferChunk;

  /**
   * Verifies a TransferChunk message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a TransferChunk message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns TransferChunk
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$TransferChunk;

  /**
   * Creates a plain object from a TransferChunk message. Also converts values to other types if specified.
   * @param message TransferChunk
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$TransferChunk,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this TransferChunk to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a TransferComplete.
 */
declare type api$ITransferComplete = {|
  /**
   * TransferComplete id
   */
  id?: string | null,

  /**
   * TransferComplete crc32
   */
  crc32?: number | null,
|};

/**
 * Represents a TransferComplete.
 */
declare class api$TransferComplete {
  /**
   * Constructs a new TransferComplete.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ITransferComplete): this;

  /**
   * TransferComplete id.
   */
  id: string;

  /**
   * TransferComplete crc32.
   */
  crc32: number;

  /**
   * Creates a new TransferComplete instance using the specified properties.
   * @param [properties] Properties to set
   * @returns TransferComplete instance
   */
  static create(properties?: api$ITransferComplete): api$TransferComplete;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TransferComplete message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$TransferComplete,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TransferComplete message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$TransferComplete,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a TransferComplete message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns TransferComplete
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$TransferComplete;

  /**
   * Decodes a TransferComplete message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns TransferComplete
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$TransferComplete;

  /**
   * Verifies a TransferComplete message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a TransferComplete message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns TransferComplete
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$TransferComplete;

  /**
   * Creates a plain object from a TransferComplete message. Also converts values to other types if specified.
   * @param message TransferComplete
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$TransferComplete,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this TransferComplete to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Clear.
 */
declare type api$IClear = {||};

/**
 * Represents a Clear.
 */
declare class api$Clear {
  /**
   * Constructs a new Clear.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IClear): this;

  /**
   * Creates a new Clear instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Clear instance
   */
  static create(properties?: api$IClear): api$Clear;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Clear message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Clear,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Clear message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Clear,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Clear message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Clear
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Clear;

  /**
   * Decodes a Clear message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Clear
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Clear;

  /**
   * Verifies a Clear message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Clear message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Clear
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Clear;

  /**
   * Creates a plain object from a Clear message. Also converts values to other types if specified.
   * @param message Clear
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Clear,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Clear to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Toast.
 */
declare type api$IToast = {|
  /**
   * Toast text
   */
  text?: string | null,
|};

/**
 * Represents a Toast.
 */
declare class api$Toast {
  /**
   * Constructs a new Toast.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IToast): this;

  /**
   * Toast text.
   */
  text: string;

  /**
   * Creates a new Toast instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Toast instance
   */
  static create(properties?: api$IToast): api$Toast;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Toast message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Toast,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Toast message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Toast,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Toast message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Toast
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Toast;

  /**
   * Decodes a Toast message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Toast
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Toast;

  /**
   * Verifies a Toast message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Toast message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Toast
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Toast;

  /**
   * Creates a plain object from a Toast message. Also converts values to other types if specified.
   * @param message Toast
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Toast,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Toast to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ProtocolError.
 */
declare type api$IProtocolError = {|
  /**
   * ProtocolError text
   */
  text?: string | null,
|};

/**
 * Represents a ProtocolError.
 */
declare class api$ProtocolError {
  /**
   * Constructs a new ProtocolError.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IProtocolError): this;

  /**
   * ProtocolError text.
   */
  text: string;

  /**
   * Creates a new ProtocolError instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ProtocolError instance
   */
  static create(properties?: api$IProtocolError): api$ProtocolError;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ProtocolError message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ProtocolError,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ProtocolError message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ProtocolError,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ProtocolError message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ProtocolError
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ProtocolError;

  /**
   * Decodes a ProtocolError message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ProtocolError
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ProtocolError;

  /**
   * Verifies a ProtocolError message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ProtocolError message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ProtocolError
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ProtocolError;

  /**
   * Creates a plain object from a ProtocolError message. Also converts values to other types if specified.
   * @param message ProtocolError
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ProtocolError,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ProtocolError to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Redirect.
 */
declare type api$IRedirect = {|
  /**
   * Redirect url
   */
  url?: string | null,
|};

/**
 * Represents a Redirect.
 */
declare class api$Redirect {
  /**
   * Constructs a new Redirect.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IRedirect): this;

  /**
   * Redirect url.
   */
  url: string;

  /**
   * Creates a new Redirect instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Redirect instance
   */
  static create(properties?: api$IRedirect): api$Redirect;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Redirect message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Redirect,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Redirect message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Redirect,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Redirect message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Redirect
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Redirect;

  /**
   * Decodes a Redirect message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Redirect
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Redirect;

  /**
   * Verifies a Redirect message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Redirect message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Redirect
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Redirect;

  /**
   * Creates a plain object from a Redirect message. Also converts values to other types if specified.
   * @param message Redirect
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Redirect,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Redirect to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an AlwaysOn.
 */
declare type api$IAlwaysOn = {|
  /**
   * AlwaysOn enable
   */
  enable?: boolean | null,
|};

/**
 * Represents an AlwaysOn.
 */
declare class api$AlwaysOn {
  /**
   * Constructs a new AlwaysOn.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IAlwaysOn): this;

  /**
   * AlwaysOn enable.
   */
  enable: boolean;

  /**
   * Creates a new AlwaysOn instance using the specified properties.
   * @param [properties] Properties to set
   * @returns AlwaysOn instance
   */
  static create(properties?: api$IAlwaysOn): api$AlwaysOn;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AlwaysOn message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$AlwaysOn,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AlwaysOn message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$AlwaysOn,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an AlwaysOn message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns AlwaysOn
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$AlwaysOn;

  /**
   * Decodes an AlwaysOn message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns AlwaysOn
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$AlwaysOn;

  /**
   * Verifies an AlwaysOn message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an AlwaysOn message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns AlwaysOn
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$AlwaysOn;

  /**
   * Creates a plain object from an AlwaysOn message. Also converts values to other types if specified.
   * @param message AlwaysOn
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$AlwaysOn,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this AlwaysOn to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a RunMain.
 */
declare type api$IRunMain = {|
  /**
   * RunMain runMode
   */
  runMode?: $Values<typeof api$RunMain$RunMode> | null,
|};

/**
 * Represents a RunMain.
 */
declare class api$RunMain {
  /**
   * Constructs a new RunMain.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IRunMain): this;

  /**
   * RunMain runMode.
   */
  runMode: $Values<typeof api$RunMain$RunMode>;

  /**
   * Creates a new RunMain instance using the specified properties.
   * @param [properties] Properties to set
   * @returns RunMain instance
   */
  static create(properties?: api$IRunMain): api$RunMain;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RunMain message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$RunMain,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RunMain message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$RunMain,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a RunMain message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns RunMain
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$RunMain;

  /**
   * Decodes a RunMain message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns RunMain
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$RunMain;

  /**
   * Verifies a RunMain message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a RunMain message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns RunMain
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$RunMain;

  /**
   * Creates a plain object from a RunMain message. Also converts values to other types if specified.
   * @param message RunMain
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$RunMain,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this RunMain to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static RunMode: typeof api$RunMain$RunMode;
}

/**
 * RunMode enum.
 */

declare var api$RunMain$RunMode: {|
  +RUN: 0, // 0
  +RECORD: 1, // 1
|};

/**
 * Properties of an OpenChannel.
 */
declare type api$IOpenChannel = {|
  /**
   * OpenChannel service
   */
  service?: string | null,

  /**
   * OpenChannel name
   */
  name?: string | null,

  /**
   * OpenChannel action
   */
  action?: $Values<typeof api$OpenChannel$Action> | null,

  /**
   * OpenChannel id
   */
  id?: number | null,
|};

/**
 * Represents an OpenChannel.
 */
declare class api$OpenChannel {
  /**
   * Constructs a new OpenChannel.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IOpenChannel): this;

  /**
   * OpenChannel service.
   */
  service: string;

  /**
   * OpenChannel name.
   */
  name: string;

  /**
   * OpenChannel action.
   */
  action: $Values<typeof api$OpenChannel$Action>;

  /**
   * OpenChannel id.
   */
  id: number;

  /**
   * Creates a new OpenChannel instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OpenChannel instance
   */
  static create(properties?: api$IOpenChannel): api$OpenChannel;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OpenChannel message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$OpenChannel,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OpenChannel message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$OpenChannel,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an OpenChannel message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OpenChannel
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$OpenChannel;

  /**
   * Decodes an OpenChannel message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OpenChannel
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$OpenChannel;

  /**
   * Verifies an OpenChannel message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an OpenChannel message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OpenChannel
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$OpenChannel;

  /**
   * Creates a plain object from an OpenChannel message. Also converts values to other types if specified.
   * @param message OpenChannel
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$OpenChannel,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OpenChannel to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Action: typeof api$OpenChannel$Action;
}

/**
 * Action enum.
 */

declare var api$OpenChannel$Action: {|
  +CREATE: 0, // 0
  +ATTACH: 1, // 1
  +ATTACH_OR_CREATE: 2, // 2
|};

/**
 * Properties of an OpenChannelRes.
 */
declare type api$IOpenChannelRes = {|
  /**
   * OpenChannelRes id
   */
  id?: number | null,

  /**
   * OpenChannelRes state
   */
  state?: $Values<typeof api$OpenChannelRes$State> | null,

  /**
   * OpenChannelRes error
   */
  error?: string | null,
|};

/**
 * Represents an OpenChannelRes.
 */
declare class api$OpenChannelRes {
  /**
   * Constructs a new OpenChannelRes.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IOpenChannelRes): this;

  /**
   * OpenChannelRes id.
   */
  id: number;

  /**
   * OpenChannelRes state.
   */
  state: $Values<typeof api$OpenChannelRes$State>;

  /**
   * OpenChannelRes error.
   */
  error: string;

  /**
   * Creates a new OpenChannelRes instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OpenChannelRes instance
   */
  static create(properties?: api$IOpenChannelRes): api$OpenChannelRes;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OpenChannelRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$OpenChannelRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OpenChannelRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$OpenChannelRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an OpenChannelRes message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OpenChannelRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$OpenChannelRes;

  /**
   * Decodes an OpenChannelRes message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OpenChannelRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$OpenChannelRes;

  /**
   * Verifies an OpenChannelRes message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an OpenChannelRes message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OpenChannelRes
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$OpenChannelRes;

  /**
   * Creates a plain object from an OpenChannelRes message. Also converts values to other types if specified.
   * @param message OpenChannelRes
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$OpenChannelRes,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OpenChannelRes to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static State: typeof api$OpenChannelRes$State;
}

/**
 * State enum.
 */

declare var api$OpenChannelRes$State: {|
  +CREATED: 0, // 0
  +ATTACHED: 1, // 1
  +ERROR: 2, // 2
|};

/**
 * Properties of a CloseChannel.
 */
declare type api$ICloseChannel = {|
  /**
   * CloseChannel id
   */
  id?: number | null,

  /**
   * CloseChannel action
   */
  action?: $Values<typeof api$CloseChannel$Action> | null,
|};

/**
 * Represents a CloseChannel.
 */
declare class api$CloseChannel {
  /**
   * Constructs a new CloseChannel.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ICloseChannel): this;

  /**
   * CloseChannel id.
   */
  id: number;

  /**
   * CloseChannel action.
   */
  action: $Values<typeof api$CloseChannel$Action>;

  /**
   * Creates a new CloseChannel instance using the specified properties.
   * @param [properties] Properties to set
   * @returns CloseChannel instance
   */
  static create(properties?: api$ICloseChannel): api$CloseChannel;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CloseChannel message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$CloseChannel,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CloseChannel message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$CloseChannel,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a CloseChannel message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns CloseChannel
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$CloseChannel;

  /**
   * Decodes a CloseChannel message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns CloseChannel
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$CloseChannel;

  /**
   * Verifies a CloseChannel message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a CloseChannel message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns CloseChannel
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$CloseChannel;

  /**
   * Creates a plain object from a CloseChannel message. Also converts values to other types if specified.
   * @param message CloseChannel
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$CloseChannel,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this CloseChannel to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Action: typeof api$CloseChannel$Action;
}

/**
 * Action enum.
 */

declare var api$CloseChannel$Action: {|
  +DISCONNECT: 0, // 0
  +TRY_CLOSE: 1, // 1
  +CLOSE: 2, // 2
|};

/**
 * Properties of a CloseChannelRes.
 */
declare type api$ICloseChannelRes = {|
  /**
   * CloseChannelRes id
   */
  id?: number | null,

  /**
   * CloseChannelRes status
   */
  status?: $Values<typeof api$CloseChannelRes$Status> | null,
|};

/**
 * Represents a CloseChannelRes.
 */
declare class api$CloseChannelRes {
  /**
   * Constructs a new CloseChannelRes.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ICloseChannelRes): this;

  /**
   * CloseChannelRes id.
   */
  id: number;

  /**
   * CloseChannelRes status.
   */
  status: $Values<typeof api$CloseChannelRes$Status>;

  /**
   * Creates a new CloseChannelRes instance using the specified properties.
   * @param [properties] Properties to set
   * @returns CloseChannelRes instance
   */
  static create(properties?: api$ICloseChannelRes): api$CloseChannelRes;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CloseChannelRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$CloseChannelRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CloseChannelRes message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$CloseChannelRes,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a CloseChannelRes message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns CloseChannelRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$CloseChannelRes;

  /**
   * Decodes a CloseChannelRes message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns CloseChannelRes
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$CloseChannelRes;

  /**
   * Verifies a CloseChannelRes message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a CloseChannelRes message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns CloseChannelRes
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$CloseChannelRes;

  /**
   * Creates a plain object from a CloseChannelRes message. Also converts values to other types if specified.
   * @param message CloseChannelRes
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$CloseChannelRes,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this CloseChannelRes to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Status: typeof api$CloseChannelRes$Status;
}

/**
 * Status enum.
 */

declare var api$CloseChannelRes$Status: {|
  +DISCONNECT: 0, // 0
  +CLOSE: 1, // 1
  +NOTHING: 2, // 2
|};

/**
 * Properties of a ContainerState.
 */
declare type api$IContainerState = {|
  /**
   * ContainerState state
   */
  state?: $Values<typeof api$ContainerState$State> | null,
|};

/**
 * Represents a ContainerState.
 */
declare class api$ContainerState {
  /**
   * Constructs a new ContainerState.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IContainerState): this;

  /**
   * ContainerState state.
   */
  state: $Values<typeof api$ContainerState$State>;

  /**
   * Creates a new ContainerState instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ContainerState instance
   */
  static create(properties?: api$IContainerState): api$ContainerState;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ContainerState message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ContainerState,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ContainerState message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ContainerState,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ContainerState message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ContainerState
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ContainerState;

  /**
   * Decodes a ContainerState message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ContainerState
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ContainerState;

  /**
   * Verifies a ContainerState message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ContainerState message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ContainerState
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ContainerState;

  /**
   * Creates a plain object from a ContainerState message. Also converts values to other types if specified.
   * @param message ContainerState
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ContainerState,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ContainerState to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static State: typeof api$ContainerState$State;
}

/**
 * State enum.
 */

declare var api$ContainerState$State: {|
  +SLEEP: 0, // 0
  +READY: 1, // 1
|};

/**
 * Properties of a PortOpen.
 */
declare type api$IPortOpen = {|
  /**
   * PortOpen forwarded
   */
  forwarded?: boolean | null,

  /**
   * PortOpen port
   */
  port?: number | null,

  /**
   * PortOpen address
   */
  address?: string | null,
|};

/**
 * Represents a PortOpen.
 */
declare class api$PortOpen {
  /**
   * Constructs a new PortOpen.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPortOpen): this;

  /**
   * PortOpen forwarded.
   */
  forwarded: boolean;

  /**
   * PortOpen port.
   */
  port: number;

  /**
   * PortOpen address.
   */
  address: string;

  /**
   * Creates a new PortOpen instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PortOpen instance
   */
  static create(properties?: api$IPortOpen): api$PortOpen;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PortOpen message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PortOpen,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PortOpen message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PortOpen,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PortOpen message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PortOpen
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PortOpen;

  /**
   * Decodes a PortOpen message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PortOpen
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$PortOpen;

  /**
   * Verifies a PortOpen message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PortOpen message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PortOpen
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PortOpen;

  /**
   * Creates a plain object from a PortOpen message. Also converts values to other types if specified.
   * @param message PortOpen
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PortOpen,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PortOpen to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PortClose.
 */
declare type api$IPortClose = {|
  /**
   * PortClose port
   */
  port?: number | null,

  /**
   * PortClose address
   */
  address?: string | null,
|};

/**
 * Represents a PortClose.
 */
declare class api$PortClose {
  /**
   * Constructs a new PortClose.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPortClose): this;

  /**
   * PortClose port.
   */
  port: number;

  /**
   * PortClose address.
   */
  address: string;

  /**
   * Creates a new PortClose instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PortClose instance
   */
  static create(properties?: api$IPortClose): api$PortClose;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PortClose message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PortClose,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PortClose message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PortClose,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PortClose message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PortClose
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PortClose;

  /**
   * Decodes a PortClose message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PortClose
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$PortClose;

  /**
   * Verifies a PortClose message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PortClose message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PortClose
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PortClose;

  /**
   * Creates a plain object from a PortClose message. Also converts values to other types if specified.
   * @param message PortClose
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PortClose,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PortClose to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTFetchRequest.
 */
declare type api$IOTFetchRequest = {|
  /**
   * OTFetchRequest versionFrom
   */
  versionFrom?: number | null,

  /**
   * OTFetchRequest versionTo
   */
  versionTo?: number | null,
|};

/**
 * Represents a OTFetchRequest.
 */
declare class api$OTFetchRequest {
  /**
   * Constructs a new OTFetchRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IOTFetchRequest): this;

  /**
   * OTFetchRequest versionFrom.
   */
  versionFrom: number;

  /**
   * OTFetchRequest versionTo.
   */
  versionTo: number;

  /**
   * Creates a new OTFetchRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTFetchRequest instance
   */
  static create(properties?: api$IOTFetchRequest): api$OTFetchRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTFetchRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$OTFetchRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTFetchRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$OTFetchRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTFetchRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTFetchRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$OTFetchRequest;

  /**
   * Decodes a OTFetchRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTFetchRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$OTFetchRequest;

  /**
   * Verifies a OTFetchRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTFetchRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTFetchRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$OTFetchRequest;

  /**
   * Creates a plain object from a OTFetchRequest message. Also converts values to other types if specified.
   * @param message OTFetchRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$OTFetchRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTFetchRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTFetchResponse.
 */
declare type api$IOTFetchResponse = {|
  /**
   * OTFetchResponse packets
   */
  packets?: (api$OTPacket | api$IOTPacket)[] | null,
|};

/**
 * Represents a OTFetchResponse.
 */
declare class api$OTFetchResponse {
  /**
   * Constructs a new OTFetchResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IOTFetchResponse): this;

  /**
   * OTFetchResponse packets.
   */
  packets: api$OTPacket[];

  /**
   * Creates a new OTFetchResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTFetchResponse instance
   */
  static create(properties?: api$IOTFetchResponse): api$OTFetchResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTFetchResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$OTFetchResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTFetchResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$OTFetchResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTFetchResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTFetchResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$OTFetchResponse;

  /**
   * Decodes a OTFetchResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTFetchResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$OTFetchResponse;

  /**
   * Verifies a OTFetchResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTFetchResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTFetchResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$OTFetchResponse;

  /**
   * Creates a plain object from a OTFetchResponse message. Also converts values to other types if specified.
   * @param message OTFetchResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$OTFetchResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTFetchResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTTransformSelectionRequest.
 */
declare type api$IOTTransformSelectionRequest = {|
  /**
   * OTTransformSelectionRequest indexStart
   */
  indexStart?: number | null,

  /**
   * OTTransformSelectionRequest indexEnd
   */
  indexEnd?: number | null,

  /**
   * OTTransformSelectionRequest versionFrom
   */
  versionFrom?: number | null,

  /**
   * OTTransformSelectionRequest versionTo
   */
  versionTo?: number | null,
|};

/**
 * Represents a OTTransformSelectionRequest.
 */
declare class api$OTTransformSelectionRequest {
  /**
   * Constructs a new OTTransformSelectionRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IOTTransformSelectionRequest): this;

  /**
   * OTTransformSelectionRequest indexStart.
   */
  indexStart: number;

  /**
   * OTTransformSelectionRequest indexEnd.
   */
  indexEnd: number;

  /**
   * OTTransformSelectionRequest versionFrom.
   */
  versionFrom: number;

  /**
   * OTTransformSelectionRequest versionTo.
   */
  versionTo: number;

  /**
   * Creates a new OTTransformSelectionRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTTransformSelectionRequest instance
   */
  static create(
    properties?: api$IOTTransformSelectionRequest
  ): api$OTTransformSelectionRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTTransformSelectionRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$OTTransformSelectionRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTTransformSelectionRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$OTTransformSelectionRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTTransformSelectionRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTTransformSelectionRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$OTTransformSelectionRequest;

  /**
   * Decodes a OTTransformSelectionRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTTransformSelectionRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$OTTransformSelectionRequest;

  /**
   * Verifies a OTTransformSelectionRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTTransformSelectionRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTTransformSelectionRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$OTTransformSelectionRequest;

  /**
   * Creates a plain object from a OTTransformSelectionRequest message. Also converts values to other types if specified.
   * @param message OTTransformSelectionRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$OTTransformSelectionRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTTransformSelectionRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTTransformSelectionResponse.
 */
declare type api$IOTTransformSelectionResponse = {|
  /**
   * OTTransformSelectionResponse indexStart
   */
  indexStart?: number | null,

  /**
   * OTTransformSelectionResponse indexEnd
   */
  indexEnd?: number | null,

  /**
   * OTTransformSelectionResponse version
   */
  version?: number | null,
|};

/**
 * Represents a OTTransformSelectionResponse.
 */
declare class api$OTTransformSelectionResponse {
  /**
   * Constructs a new OTTransformSelectionResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IOTTransformSelectionResponse): this;

  /**
   * OTTransformSelectionResponse indexStart.
   */
  indexStart: number;

  /**
   * OTTransformSelectionResponse indexEnd.
   */
  indexEnd: number;

  /**
   * OTTransformSelectionResponse version.
   */
  version: number;

  /**
   * Creates a new OTTransformSelectionResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTTransformSelectionResponse instance
   */
  static create(
    properties?: api$IOTTransformSelectionResponse
  ): api$OTTransformSelectionResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTTransformSelectionResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$OTTransformSelectionResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTTransformSelectionResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$OTTransformSelectionResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTTransformSelectionResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTTransformSelectionResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$OTTransformSelectionResponse;

  /**
   * Decodes a OTTransformSelectionResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTTransformSelectionResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$OTTransformSelectionResponse;

  /**
   * Verifies a OTTransformSelectionResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTTransformSelectionResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTTransformSelectionResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$OTTransformSelectionResponse;

  /**
   * Creates a plain object from a OTTransformSelectionResponse message. Also converts values to other types if specified.
   * @param message OTTransformSelectionResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$OTTransformSelectionResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTTransformSelectionResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTPacket.
 */
declare type api$IOTPacket = {|
  /**
   * OTPacket spookyVersion
   */
  spookyVersion?: number | null,

  /**
   * OTPacket version
   */
  version?: number | null,

  /**
   * OTPacket ops
   */
  ops?: (api$OTRuneTransformOp | api$IOTRuneTransformOp)[] | null,

  /**
   * OTPacket crc32
   */
  crc32?: number | null,

  /**
   * OTPacket committed
   */
  committed?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,

  /**
   * OTPacket nonce
   */
  nonce?: number | null,

  /**
   * OTPacket userId
   */
  userId?: number | null,
|};

/**
 * Represents a OTPacket.
 */
declare class api$OTPacket {
  /**
   * Constructs a new OTPacket.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IOTPacket): this;

  /**
   * OTPacket spookyVersion.
   */
  spookyVersion: number;

  /**
   * OTPacket version.
   */
  version: number;

  /**
   * OTPacket ops.
   */
  ops: api$OTRuneTransformOp[];

  /**
   * OTPacket crc32.
   */
  crc32: number;

  /**
   * OTPacket committed.
   */
  committed?: google$protobuf$Timestamp | null;

  /**
   * OTPacket nonce.
   */
  nonce: number;

  /**
   * OTPacket userId.
   */
  userId: number;

  /**
   * Creates a new OTPacket instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTPacket instance
   */
  static create(properties?: api$IOTPacket): api$OTPacket;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTPacket message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$OTPacket,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTPacket message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$OTPacket,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTPacket message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTPacket
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$OTPacket;

  /**
   * Decodes a OTPacket message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTPacket
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$OTPacket;

  /**
   * Verifies a OTPacket message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTPacket message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTPacket
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$OTPacket;

  /**
   * Creates a plain object from a OTPacket message. Also converts values to other types if specified.
   * @param message OTPacket
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$OTPacket,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTPacket to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTRuneTransformOp.
 */
declare type api$IOTRuneTransformOp = {|
  /**
   * OTRuneTransformOp skip
   */
  skip?: number | null,

  /**
   * OTRuneTransformOp delete
   */
  delete?: number | null,

  /**
   * OTRuneTransformOp insert
   */
  insert?: string | null,
|};

/**
 * Represents a OTRuneTransformOp.
 */
declare class api$OTRuneTransformOp {
  /**
   * Constructs a new OTRuneTransformOp.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IOTRuneTransformOp): this;

  /**
   * OTRuneTransformOp skip.
   */
  skip?: number | null;

  /**
   * OTRuneTransformOp delete.
   */
  delete?: number | null;

  /**
   * OTRuneTransformOp insert.
   */
  insert?: string | null;

  /**
   * OTRuneTransformOp op.
   */
  op?: "skip" | "delete" | "insert";

  /**
   * Creates a new OTRuneTransformOp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTRuneTransformOp instance
   */
  static create(properties?: api$IOTRuneTransformOp): api$OTRuneTransformOp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTRuneTransformOp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$OTRuneTransformOp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTRuneTransformOp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$OTRuneTransformOp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTRuneTransformOp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTRuneTransformOp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$OTRuneTransformOp;

  /**
   * Decodes a OTRuneTransformOp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTRuneTransformOp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$OTRuneTransformOp;

  /**
   * Verifies a OTRuneTransformOp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTRuneTransformOp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTRuneTransformOp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$OTRuneTransformOp;

  /**
   * Creates a plain object from a OTRuneTransformOp message. Also converts values to other types if specified.
   * @param message OTRuneTransformOp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$OTRuneTransformOp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTRuneTransformOp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTStatus.
 */
declare type api$IOTStatus = {|
  /**
   * OTStatus contents
   */
  contents?: string | null,

  /**
   * OTStatus version
   */
  version?: number | null,

  /**
   * OTStatus linkedFile
   */
  linkedFile?: api$File | api$IFile | null,

  /**
   * OTStatus cursors
   */
  cursors?: (api$OTCursor | api$IOTCursor)[] | null,
|};

/**
 * Represents a OTStatus.
 */
declare class api$OTStatus {
  /**
   * Constructs a new OTStatus.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IOTStatus): this;

  /**
   * OTStatus contents.
   */
  contents: string;

  /**
   * OTStatus version.
   */
  version: number;

  /**
   * OTStatus linkedFile.
   */
  linkedFile?: api$File | null;

  /**
   * OTStatus cursors.
   */
  cursors: api$OTCursor[];

  /**
   * Creates a new OTStatus instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTStatus instance
   */
  static create(properties?: api$IOTStatus): api$OTStatus;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTStatus message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$OTStatus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTStatus message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$OTStatus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTStatus message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTStatus
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$OTStatus;

  /**
   * Decodes a OTStatus message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTStatus
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$OTStatus;

  /**
   * Verifies a OTStatus message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTStatus message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTStatus
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$OTStatus;

  /**
   * Creates a plain object from a OTStatus message. Also converts values to other types if specified.
   * @param message OTStatus
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$OTStatus,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTStatus to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a OTCursor.
 */
declare type api$IOTCursor = {|
  /**
   * OTCursor position
   */
  position?: number | null,

  /**
   * OTCursor selectionStart
   */
  selectionStart?: number | null,

  /**
   * OTCursor selectionEnd
   */
  selectionEnd?: number | null,

  /**
   * OTCursor user
   */
  user?: api$User | api$IUser | null,

  /**
   * OTCursor id
   */
  id?: string | null,
|};

/**
 * Represents a OTCursor.
 */
declare class api$OTCursor {
  /**
   * Constructs a new OTCursor.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IOTCursor): this;

  /**
   * OTCursor position.
   */
  position: number;

  /**
   * OTCursor selectionStart.
   */
  selectionStart: number;

  /**
   * OTCursor selectionEnd.
   */
  selectionEnd: number;

  /**
   * OTCursor user.
   */
  user?: api$User | null;

  /**
   * OTCursor id.
   */
  id: string;

  /**
   * Creates a new OTCursor instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OTCursor instance
   */
  static create(properties?: api$IOTCursor): api$OTCursor;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTCursor message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$OTCursor,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OTCursor message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$OTCursor,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a OTCursor message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OTCursor
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$OTCursor;

  /**
   * Decodes a OTCursor message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OTCursor
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$OTCursor;

  /**
   * Verifies a OTCursor message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a OTCursor message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OTCursor
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$OTCursor;

  /**
   * Creates a plain object from a OTCursor message. Also converts values to other types if specified.
   * @param message OTCursor
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$OTCursor,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OTCursor to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ChatMessage.
 */
declare type api$IChatMessage = {|
  /**
   * ChatMessage username
   */
  username?: string | null,

  /**
   * ChatMessage text
   */
  text?: string | null,
|};

/**
 * Represents a ChatMessage.
 */
declare class api$ChatMessage {
  /**
   * Constructs a new ChatMessage.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IChatMessage): this;

  /**
   * ChatMessage username.
   */
  username: string;

  /**
   * ChatMessage text.
   */
  text: string;

  /**
   * Creates a new ChatMessage instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ChatMessage instance
   */
  static create(properties?: api$IChatMessage): api$ChatMessage;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ChatMessage message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ChatMessage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ChatMessage message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ChatMessage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ChatMessage message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ChatMessage
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ChatMessage;

  /**
   * Decodes a ChatMessage message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ChatMessage
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ChatMessage;

  /**
   * Verifies a ChatMessage message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ChatMessage message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ChatMessage
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ChatMessage;

  /**
   * Creates a plain object from a ChatMessage message. Also converts values to other types if specified.
   * @param message ChatMessage
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ChatMessage,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ChatMessage to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ChatTyping.
 */
declare type api$IChatTyping = {|
  /**
   * ChatTyping username
   */
  username?: string | null,

  /**
   * ChatTyping typing
   */
  typing?: boolean | null,
|};

/**
 * Represents a ChatTyping.
 */
declare class api$ChatTyping {
  /**
   * Constructs a new ChatTyping.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IChatTyping): this;

  /**
   * ChatTyping username.
   */
  username: string;

  /**
   * ChatTyping typing.
   */
  typing: boolean;

  /**
   * Creates a new ChatTyping instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ChatTyping instance
   */
  static create(properties?: api$IChatTyping): api$ChatTyping;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ChatTyping message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ChatTyping,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ChatTyping message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ChatTyping,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ChatTyping message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ChatTyping
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ChatTyping;

  /**
   * Decodes a ChatTyping message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ChatTyping
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$ChatTyping;

  /**
   * Verifies a ChatTyping message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ChatTyping message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ChatTyping
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ChatTyping;

  /**
   * Creates a plain object from a ChatTyping message. Also converts values to other types if specified.
   * @param message ChatTyping
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ChatTyping,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ChatTyping to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a User.
 */
declare type api$IUser = {|
  /**
   * User id
   */
  id?: number | null,

  /**
   * User name
   */
  name?: string | null,

  /**
   * User roles
   */
  roles?: string[] | null,

  /**
   * User session
   */
  session?: number | null,

  /**
   * User teams
   */
  teams?: string[] | null,
|};

/**
 * Represents a User.
 */
declare class api$User {
  /**
   * Constructs a new User.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IUser): this;

  /**
   * User id.
   */
  id: number;

  /**
   * User name.
   */
  name: string;

  /**
   * User roles.
   */
  roles: string[];

  /**
   * User session.
   */
  session: number;

  /**
   * User teams.
   */
  teams: string[];

  /**
   * Creates a new User instance using the specified properties.
   * @param [properties] Properties to set
   * @returns User instance
   */
  static create(properties?: api$IUser): api$User;

  /**
   * [object Object],[object Object],[object Object]
   * @param message User message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(message: api$User, writer?: $protobuf.Writer): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message User message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$User,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a User message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns User
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$User;

  /**
   * Decodes a User message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns User
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$User;

  /**
   * Verifies a User message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a User message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns User
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$User;

  /**
   * Creates a plain object from a User message. Also converts values to other types if specified.
   * @param message User
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$User,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this User to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Roster.
 */
declare type api$IRoster = {|
  /**
   * Roster user
   */
  user?: (api$User | api$IUser)[] | null,

  /**
   * Roster files
   */
  files?: (api$FileOpened | api$IFileOpened)[] | null,
|};

/**
 * Represents a Roster.
 */
declare class api$Roster {
  /**
   * Constructs a new Roster.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IRoster): this;

  /**
   * Roster user.
   */
  user: api$User[];

  /**
   * Roster files.
   */
  files: api$FileOpened[];

  /**
   * Creates a new Roster instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Roster instance
   */
  static create(properties?: api$IRoster): api$Roster;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Roster message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Roster,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Roster message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Roster,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Roster message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Roster
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Roster;

  /**
   * Decodes a Roster message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Roster
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Roster;

  /**
   * Verifies a Roster message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Roster message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Roster
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Roster;

  /**
   * Creates a plain object from a Roster message. Also converts values to other types if specified.
   * @param message Roster
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Roster,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Roster to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an OpenFile.
 */
declare type api$IOpenFile = {|
  /**
   * OpenFile file
   */
  file?: string | null,
|};

/**
 * Represents an OpenFile.
 */
declare class api$OpenFile {
  /**
   * Constructs a new OpenFile.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IOpenFile): this;

  /**
   * OpenFile file.
   */
  file: string;

  /**
   * Creates a new OpenFile instance using the specified properties.
   * @param [properties] Properties to set
   * @returns OpenFile instance
   */
  static create(properties?: api$IOpenFile): api$OpenFile;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OpenFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$OpenFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message OpenFile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$OpenFile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an OpenFile message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns OpenFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$OpenFile;

  /**
   * Decodes an OpenFile message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns OpenFile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$OpenFile;

  /**
   * Verifies an OpenFile message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an OpenFile message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns OpenFile
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$OpenFile;

  /**
   * Creates a plain object from an OpenFile message. Also converts values to other types if specified.
   * @param message OpenFile
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$OpenFile,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this OpenFile to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FileOpened.
 */
declare type api$IFileOpened = {|
  /**
   * FileOpened userId
   */
  userId?: number | null,

  /**
   * FileOpened file
   */
  file?: string | null,

  /**
   * FileOpened session
   */
  session?: number | null,

  /**
   * FileOpened timestamp
   */
  timestamp?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,
|};

/**
 * Represents a FileOpened.
 */
declare class api$FileOpened {
  /**
   * Constructs a new FileOpened.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IFileOpened): this;

  /**
   * FileOpened userId.
   */
  userId: number;

  /**
   * FileOpened file.
   */
  file: string;

  /**
   * FileOpened session.
   */
  session: number;

  /**
   * FileOpened timestamp.
   */
  timestamp?: google$protobuf$Timestamp | null;

  /**
   * Creates a new FileOpened instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FileOpened instance
   */
  static create(properties?: api$IFileOpened): api$FileOpened;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileOpened message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$FileOpened,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FileOpened message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$FileOpened,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FileOpened message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FileOpened
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$FileOpened;

  /**
   * Decodes a FileOpened message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FileOpened
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$FileOpened;

  /**
   * Verifies a FileOpened message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FileOpened message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FileOpened
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$FileOpened;

  /**
   * Creates a plain object from a FileOpened message. Also converts values to other types if specified.
   * @param message FileOpened
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$FileOpened,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FileOpened to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an UpdateSessionTimestamp.
 */
declare type api$IUpdateSessionTimestamp = {||};

/**
 * Represents an UpdateSessionTimestamp.
 */
declare class api$UpdateSessionTimestamp {
  /**
   * Constructs a new UpdateSessionTimestamp.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IUpdateSessionTimestamp): this;

  /**
   * Creates a new UpdateSessionTimestamp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns UpdateSessionTimestamp instance
   */
  static create(
    properties?: api$IUpdateSessionTimestamp
  ): api$UpdateSessionTimestamp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message UpdateSessionTimestamp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$UpdateSessionTimestamp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message UpdateSessionTimestamp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$UpdateSessionTimestamp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an UpdateSessionTimestamp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns UpdateSessionTimestamp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$UpdateSessionTimestamp;

  /**
   * Decodes an UpdateSessionTimestamp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns UpdateSessionTimestamp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$UpdateSessionTimestamp;

  /**
   * Verifies an UpdateSessionTimestamp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an UpdateSessionTimestamp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns UpdateSessionTimestamp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$UpdateSessionTimestamp;

  /**
   * Creates a plain object from an UpdateSessionTimestamp message. Also converts values to other types if specified.
   * @param message UpdateSessionTimestamp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$UpdateSessionTimestamp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this UpdateSessionTimestamp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a SessionTimestampUpdated.
 */
declare type api$ISessionTimestampUpdated = {|
  /**
   * SessionTimestampUpdated session
   */
  session?: number | null,

  /**
   * SessionTimestampUpdated timestamp
   */
  timestamp?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,
|};

/**
 * Represents a SessionTimestampUpdated.
 */
declare class api$SessionTimestampUpdated {
  /**
   * Constructs a new SessionTimestampUpdated.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ISessionTimestampUpdated): this;

  /**
   * SessionTimestampUpdated session.
   */
  session: number;

  /**
   * SessionTimestampUpdated timestamp.
   */
  timestamp?: google$protobuf$Timestamp | null;

  /**
   * Creates a new SessionTimestampUpdated instance using the specified properties.
   * @param [properties] Properties to set
   * @returns SessionTimestampUpdated instance
   */
  static create(
    properties?: api$ISessionTimestampUpdated
  ): api$SessionTimestampUpdated;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SessionTimestampUpdated message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$SessionTimestampUpdated,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message SessionTimestampUpdated message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$SessionTimestampUpdated,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a SessionTimestampUpdated message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns SessionTimestampUpdated
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$SessionTimestampUpdated;

  /**
   * Decodes a SessionTimestampUpdated message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns SessionTimestampUpdated
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$SessionTimestampUpdated;

  /**
   * Verifies a SessionTimestampUpdated message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a SessionTimestampUpdated message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns SessionTimestampUpdated
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$SessionTimestampUpdated;

  /**
   * Creates a plain object from a SessionTimestampUpdated message. Also converts values to other types if specified.
   * @param message SessionTimestampUpdated
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$SessionTimestampUpdated,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this SessionTimestampUpdated to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FollowUser.
 */
declare type api$IFollowUser = {|
  /**
   * FollowUser session
   */
  session?: number | null,
|};

/**
 * Represents a FollowUser.
 */
declare class api$FollowUser {
  /**
   * Constructs a new FollowUser.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IFollowUser): this;

  /**
   * FollowUser session.
   */
  session: number;

  /**
   * Creates a new FollowUser instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FollowUser instance
   */
  static create(properties?: api$IFollowUser): api$FollowUser;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FollowUser message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$FollowUser,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FollowUser message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$FollowUser,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FollowUser message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FollowUser
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$FollowUser;

  /**
   * Decodes a FollowUser message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FollowUser
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$FollowUser;

  /**
   * Verifies a FollowUser message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FollowUser message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FollowUser
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$FollowUser;

  /**
   * Creates a plain object from a FollowUser message. Also converts values to other types if specified.
   * @param message FollowUser
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$FollowUser,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FollowUser to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an UnfollowUser.
 */
declare type api$IUnfollowUser = {|
  /**
   * UnfollowUser session
   */
  session?: number | null,
|};

/**
 * Represents an UnfollowUser.
 */
declare class api$UnfollowUser {
  /**
   * Constructs a new UnfollowUser.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IUnfollowUser): this;

  /**
   * UnfollowUser session.
   */
  session: number;

  /**
   * Creates a new UnfollowUser instance using the specified properties.
   * @param [properties] Properties to set
   * @returns UnfollowUser instance
   */
  static create(properties?: api$IUnfollowUser): api$UnfollowUser;

  /**
   * [object Object],[object Object],[object Object]
   * @param message UnfollowUser message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$UnfollowUser,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message UnfollowUser message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$UnfollowUser,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an UnfollowUser message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns UnfollowUser
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$UnfollowUser;

  /**
   * Decodes an UnfollowUser message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns UnfollowUser
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$UnfollowUser;

  /**
   * Verifies an UnfollowUser message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an UnfollowUser message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns UnfollowUser
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$UnfollowUser;

  /**
   * Creates a plain object from an UnfollowUser message. Also converts values to other types if specified.
   * @param message UnfollowUser
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$UnfollowUser,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this UnfollowUser to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an Exec.
 */
declare type api$IExec = {|
  /**
   * Exec args
   */
  args?: string[] | null,

  /**
   * Exec env
   */
  env?: {|
    [k: string]: string,
  |} | null,

  /**
   * Exec blocking
   */
  blocking?: boolean | null,

  /**
   * Exec lifecycle
   */
  lifecycle?: $Values<typeof api$Exec$Lifecycle> | null,

  /**
   * Exec splitStderr
   */
  splitStderr?: boolean | null,

  /**
   * Exec splitLogs
   */
  splitLogs?: boolean | null,
|};

/**
 * Represents an Exec.
 */
declare class api$Exec {
  /**
   * Constructs a new Exec.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IExec): this;

  /**
   * Exec args.
   */
  args: string[];

  /**
   * Exec env.
   */
  env: {|
    [k: string]: string,
  |};

  /**
   * Exec blocking.
   */
  blocking: boolean;

  /**
   * Exec lifecycle.
   */
  lifecycle: $Values<typeof api$Exec$Lifecycle>;

  /**
   * Exec splitStderr.
   */
  splitStderr: boolean;

  /**
   * Exec splitLogs.
   */
  splitLogs: boolean;

  /**
   * Creates a new Exec instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Exec instance
   */
  static create(properties?: api$IExec): api$Exec;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Exec message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(message: api$Exec, writer?: $protobuf.Writer): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Exec message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Exec,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an Exec message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Exec
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Exec;

  /**
   * Decodes an Exec message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Exec
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Exec;

  /**
   * Verifies an Exec message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an Exec message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Exec
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Exec;

  /**
   * Creates a plain object from an Exec message. Also converts values to other types if specified.
   * @param message Exec
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Exec,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Exec to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Lifecycle: typeof api$Exec$Lifecycle;
}

/**
 * Lifecycle enum.
 */

declare var api$Exec$Lifecycle: {|
  +NON_BLOCKING: 0, // 0
  +BLOCKING: 1, // 1
  +STDIN: 2, // 2
|};

/**
 * Properties of a Package.
 */
declare type api$IPackage = {|
  /**
   * Package name
   */
  name?: string | null,

  /**
   * Package spec
   */
  spec?: string | null,

  /**
   * Package description
   */
  description?: string | null,

  /**
   * Package version
   */
  version?: string | null,

  /**
   * Package homepageURL
   */
  homepageURL?: string | null,

  /**
   * Package documentationURL
   */
  documentationURL?: string | null,

  /**
   * Package sourceCodeURL
   */
  sourceCodeURL?: string | null,

  /**
   * Package bugTrackerURL
   */
  bugTrackerURL?: string | null,

  /**
   * Package author
   */
  author?: string | null,

  /**
   * Package license
   */
  license?: string | null,

  /**
   * Package dependencies
   */
  dependencies?: (api$Package | api$IPackage)[] | null,
|};

/**
 * Represents a Package.
 */
declare class api$Package {
  /**
   * Constructs a new Package.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPackage): this;

  /**
   * Package name.
   */
  name: string;

  /**
   * Package spec.
   */
  spec: string;

  /**
   * Package description.
   */
  description: string;

  /**
   * Package version.
   */
  version: string;

  /**
   * Package homepageURL.
   */
  homepageURL: string;

  /**
   * Package documentationURL.
   */
  documentationURL: string;

  /**
   * Package sourceCodeURL.
   */
  sourceCodeURL: string;

  /**
   * Package bugTrackerURL.
   */
  bugTrackerURL: string;

  /**
   * Package author.
   */
  author: string;

  /**
   * Package license.
   */
  license: string;

  /**
   * Package dependencies.
   */
  dependencies: api$Package[];

  /**
   * Creates a new Package instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Package instance
   */
  static create(properties?: api$IPackage): api$Package;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Package message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Package,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Package message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Package,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Package message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Package
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Package;

  /**
   * Decodes a Package message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Package
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Package;

  /**
   * Verifies a Package message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Package message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Package
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Package;

  /**
   * Creates a plain object from a Package message. Also converts values to other types if specified.
   * @param message Package
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Package,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Package to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageSearch.
 */
declare type api$IPackageSearch = {|
  /**
   * PackageSearch query
   */
  query?: string | null,
|};

/**
 * Represents a PackageSearch.
 */
declare class api$PackageSearch {
  /**
   * Constructs a new PackageSearch.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPackageSearch): this;

  /**
   * PackageSearch query.
   */
  query: string;

  /**
   * Creates a new PackageSearch instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageSearch instance
   */
  static create(properties?: api$IPackageSearch): api$PackageSearch;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageSearch message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PackageSearch,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageSearch message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PackageSearch,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageSearch message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageSearch
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PackageSearch;

  /**
   * Decodes a PackageSearch message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageSearch
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PackageSearch;

  /**
   * Verifies a PackageSearch message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageSearch message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageSearch
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PackageSearch;

  /**
   * Creates a plain object from a PackageSearch message. Also converts values to other types if specified.
   * @param message PackageSearch
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PackageSearch,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageSearch to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageSearchResp.
 */
declare type api$IPackageSearchResp = {|
  /**
   * PackageSearchResp results
   */
  results?: (api$Package | api$IPackage)[] | null,
|};

/**
 * Represents a PackageSearchResp.
 */
declare class api$PackageSearchResp {
  /**
   * Constructs a new PackageSearchResp.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPackageSearchResp): this;

  /**
   * PackageSearchResp results.
   */
  results: api$Package[];

  /**
   * Creates a new PackageSearchResp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageSearchResp instance
   */
  static create(properties?: api$IPackageSearchResp): api$PackageSearchResp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageSearchResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PackageSearchResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageSearchResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PackageSearchResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageSearchResp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageSearchResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PackageSearchResp;

  /**
   * Decodes a PackageSearchResp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageSearchResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PackageSearchResp;

  /**
   * Verifies a PackageSearchResp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageSearchResp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageSearchResp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PackageSearchResp;

  /**
   * Creates a plain object from a PackageSearchResp message. Also converts values to other types if specified.
   * @param message PackageSearchResp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PackageSearchResp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageSearchResp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageInfo.
 */
declare type api$IPackageInfo = {|
  /**
   * PackageInfo pkg
   */
  pkg?: api$Package | api$IPackage | null,
|};

/**
 * Represents a PackageInfo.
 */
declare class api$PackageInfo {
  /**
   * Constructs a new PackageInfo.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPackageInfo): this;

  /**
   * PackageInfo pkg.
   */
  pkg?: api$Package | null;

  /**
   * Creates a new PackageInfo instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageInfo instance
   */
  static create(properties?: api$IPackageInfo): api$PackageInfo;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageInfo message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PackageInfo,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageInfo message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PackageInfo,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageInfo message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageInfo
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PackageInfo;

  /**
   * Decodes a PackageInfo message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageInfo
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PackageInfo;

  /**
   * Verifies a PackageInfo message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageInfo message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageInfo
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PackageInfo;

  /**
   * Creates a plain object from a PackageInfo message. Also converts values to other types if specified.
   * @param message PackageInfo
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PackageInfo,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageInfo to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageInfoResp.
 */
declare type api$IPackageInfoResp = {|
  /**
   * PackageInfoResp pkg
   */
  pkg?: api$Package | api$IPackage | null,
|};

/**
 * Represents a PackageInfoResp.
 */
declare class api$PackageInfoResp {
  /**
   * Constructs a new PackageInfoResp.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPackageInfoResp): this;

  /**
   * PackageInfoResp pkg.
   */
  pkg?: api$Package | null;

  /**
   * Creates a new PackageInfoResp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageInfoResp instance
   */
  static create(properties?: api$IPackageInfoResp): api$PackageInfoResp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageInfoResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PackageInfoResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageInfoResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PackageInfoResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageInfoResp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageInfoResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PackageInfoResp;

  /**
   * Decodes a PackageInfoResp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageInfoResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PackageInfoResp;

  /**
   * Verifies a PackageInfoResp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageInfoResp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageInfoResp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PackageInfoResp;

  /**
   * Creates a plain object from a PackageInfoResp message. Also converts values to other types if specified.
   * @param message PackageInfoResp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PackageInfoResp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageInfoResp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageAdd.
 */
declare type api$IPackageAdd = {|
  /**
   * PackageAdd pkgs
   */
  pkgs?: (api$Package | api$IPackage)[] | null,
|};

/**
 * Represents a PackageAdd.
 */
declare class api$PackageAdd {
  /**
   * Constructs a new PackageAdd.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPackageAdd): this;

  /**
   * PackageAdd pkgs.
   */
  pkgs: api$Package[];

  /**
   * Creates a new PackageAdd instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageAdd instance
   */
  static create(properties?: api$IPackageAdd): api$PackageAdd;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageAdd message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PackageAdd,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageAdd message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PackageAdd,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageAdd message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageAdd
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PackageAdd;

  /**
   * Decodes a PackageAdd message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageAdd
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$PackageAdd;

  /**
   * Verifies a PackageAdd message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageAdd message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageAdd
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PackageAdd;

  /**
   * Creates a plain object from a PackageAdd message. Also converts values to other types if specified.
   * @param message PackageAdd
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PackageAdd,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageAdd to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageRemove.
 */
declare type api$IPackageRemove = {|
  /**
   * PackageRemove pkgs
   */
  pkgs?: (api$Package | api$IPackage)[] | null,
|};

/**
 * Represents a PackageRemove.
 */
declare class api$PackageRemove {
  /**
   * Constructs a new PackageRemove.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPackageRemove): this;

  /**
   * PackageRemove pkgs.
   */
  pkgs: api$Package[];

  /**
   * Creates a new PackageRemove instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageRemove instance
   */
  static create(properties?: api$IPackageRemove): api$PackageRemove;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageRemove message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PackageRemove,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageRemove message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PackageRemove,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageRemove message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageRemove
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PackageRemove;

  /**
   * Decodes a PackageRemove message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageRemove
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PackageRemove;

  /**
   * Verifies a PackageRemove message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageRemove message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageRemove
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PackageRemove;

  /**
   * Creates a plain object from a PackageRemove message. Also converts values to other types if specified.
   * @param message PackageRemove
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PackageRemove,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageRemove to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageInstall.
 */
declare type api$IPackageInstall = {|
  /**
   * PackageInstall fromHosting
   */
  fromHosting?: boolean | null,
|};

/**
 * Represents a PackageInstall.
 */
declare class api$PackageInstall {
  /**
   * Constructs a new PackageInstall.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPackageInstall): this;

  /**
   * PackageInstall fromHosting.
   */
  fromHosting: boolean;

  /**
   * Creates a new PackageInstall instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageInstall instance
   */
  static create(properties?: api$IPackageInstall): api$PackageInstall;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageInstall message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PackageInstall,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageInstall message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PackageInstall,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageInstall message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageInstall
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PackageInstall;

  /**
   * Decodes a PackageInstall message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageInstall
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PackageInstall;

  /**
   * Verifies a PackageInstall message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageInstall message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageInstall
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PackageInstall;

  /**
   * Creates a plain object from a PackageInstall message. Also converts values to other types if specified.
   * @param message PackageInstall
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PackageInstall,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageInstall to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageListSpecfile.
 */
declare type api$IPackageListSpecfile = {||};

/**
 * Represents a PackageListSpecfile.
 */
declare class api$PackageListSpecfile {
  /**
   * Constructs a new PackageListSpecfile.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPackageListSpecfile): this;

  /**
   * Creates a new PackageListSpecfile instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageListSpecfile instance
   */
  static create(properties?: api$IPackageListSpecfile): api$PackageListSpecfile;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageListSpecfile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PackageListSpecfile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageListSpecfile message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PackageListSpecfile,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageListSpecfile message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageListSpecfile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PackageListSpecfile;

  /**
   * Decodes a PackageListSpecfile message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageListSpecfile
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PackageListSpecfile;

  /**
   * Verifies a PackageListSpecfile message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageListSpecfile message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageListSpecfile
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PackageListSpecfile;

  /**
   * Creates a plain object from a PackageListSpecfile message. Also converts values to other types if specified.
   * @param message PackageListSpecfile
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PackageListSpecfile,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageListSpecfile to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageListSpecfileResp.
 */
declare type api$IPackageListSpecfileResp = {|
  /**
   * PackageListSpecfileResp pkgs
   */
  pkgs?: (api$Package | api$IPackage)[] | null,
|};

/**
 * Represents a PackageListSpecfileResp.
 */
declare class api$PackageListSpecfileResp {
  /**
   * Constructs a new PackageListSpecfileResp.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPackageListSpecfileResp): this;

  /**
   * PackageListSpecfileResp pkgs.
   */
  pkgs: api$Package[];

  /**
   * Creates a new PackageListSpecfileResp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageListSpecfileResp instance
   */
  static create(
    properties?: api$IPackageListSpecfileResp
  ): api$PackageListSpecfileResp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageListSpecfileResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PackageListSpecfileResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageListSpecfileResp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PackageListSpecfileResp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageListSpecfileResp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageListSpecfileResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PackageListSpecfileResp;

  /**
   * Decodes a PackageListSpecfileResp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageListSpecfileResp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PackageListSpecfileResp;

  /**
   * Verifies a PackageListSpecfileResp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageListSpecfileResp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageListSpecfileResp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PackageListSpecfileResp;

  /**
   * Creates a plain object from a PackageListSpecfileResp message. Also converts values to other types if specified.
   * @param message PackageListSpecfileResp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PackageListSpecfileResp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageListSpecfileResp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PackageCacheSave.
 */
declare type api$IPackageCacheSave = {||};

/**
 * Represents a PackageCacheSave.
 */
declare class api$PackageCacheSave {
  /**
   * Constructs a new PackageCacheSave.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPackageCacheSave): this;

  /**
   * Creates a new PackageCacheSave instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PackageCacheSave instance
   */
  static create(properties?: api$IPackageCacheSave): api$PackageCacheSave;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageCacheSave message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PackageCacheSave,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PackageCacheSave message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PackageCacheSave,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PackageCacheSave message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PackageCacheSave
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PackageCacheSave;

  /**
   * Decodes a PackageCacheSave message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PackageCacheSave
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PackageCacheSave;

  /**
   * Verifies a PackageCacheSave message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PackageCacheSave message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PackageCacheSave
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PackageCacheSave;

  /**
   * Creates a plain object from a PackageCacheSave message. Also converts values to other types if specified.
   * @param message PackageCacheSave
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PackageCacheSave,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PackageCacheSave to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ChatScrollback.
 */
declare type api$IChatScrollback = {|
  /**
   * ChatScrollback scrollback
   */
  scrollback?: (api$ChatMessage | api$IChatMessage)[] | null,
|};

/**
 * Represents a ChatScrollback.
 */
declare class api$ChatScrollback {
  /**
   * Constructs a new ChatScrollback.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IChatScrollback): this;

  /**
   * ChatScrollback scrollback.
   */
  scrollback: api$ChatMessage[];

  /**
   * Creates a new ChatScrollback instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ChatScrollback instance
   */
  static create(properties?: api$IChatScrollback): api$ChatScrollback;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ChatScrollback message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ChatScrollback,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ChatScrollback message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ChatScrollback,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ChatScrollback message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ChatScrollback
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ChatScrollback;

  /**
   * Decodes a ChatScrollback message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ChatScrollback
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ChatScrollback;

  /**
   * Verifies a ChatScrollback message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ChatScrollback message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ChatScrollback
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ChatScrollback;

  /**
   * Creates a plain object from a ChatScrollback message. Also converts values to other types if specified.
   * @param message ChatScrollback
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ChatScrollback,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ChatScrollback to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Metrics.
 */
declare type api$IMetrics = {|
  /**
   * Metrics prometheusMetricFamilies
   */
  prometheusMetricFamilies?: Uint8Array[] | null,
|};

/**
 * Represents a Metrics.
 */
declare class api$Metrics {
  /**
   * Constructs a new Metrics.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IMetrics): this;

  /**
   * Metrics prometheusMetricFamilies.
   */
  prometheusMetricFamilies: Uint8Array[];

  /**
   * Creates a new Metrics instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Metrics instance
   */
  static create(properties?: api$IMetrics): api$Metrics;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Metrics message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Metrics,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Metrics message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Metrics,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Metrics message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Metrics
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Metrics;

  /**
   * Decodes a Metrics message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Metrics
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Metrics;

  /**
   * Verifies a Metrics message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Metrics message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Metrics
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Metrics;

  /**
   * Creates a plain object from a Metrics message. Also converts values to other types if specified.
   * @param message Metrics
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Metrics,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Metrics to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PprofRequest.
 */
declare type api$IPprofRequest = {|
  /**
   * PprofRequest id
   */
  id?: string | null,

  /**
   * PprofRequest pprofCpuProfileRequest
   */
  pprofCpuProfileRequest?:
    | api$PprofCpuProfileRequest
    | api$IPprofCpuProfileRequest
    | null,

  /**
   * PprofRequest pprofHeapProfileRequest
   */
  pprofHeapProfileRequest?:
    | api$PprofHeapProfileRequest
    | api$IPprofHeapProfileRequest
    | null,

  /**
   * PprofRequest pprofAllocsProfileRequest
   */
  pprofAllocsProfileRequest?:
    | api$PprofAllocsProfileRequest
    | api$IPprofAllocsProfileRequest
    | null,

  /**
   * PprofRequest pprofBlockProfileRequest
   */
  pprofBlockProfileRequest?:
    | api$PprofBlockProfileRequest
    | api$IPprofBlockProfileRequest
    | null,

  /**
   * PprofRequest pprofMutexProfileRequest
   */
  pprofMutexProfileRequest?:
    | api$PprofMutexProfileRequest
    | api$IPprofMutexProfileRequest
    | null,
|};

/**
 * Represents a PprofRequest.
 */
declare class api$PprofRequest {
  /**
   * Constructs a new PprofRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPprofRequest): this;

  /**
   * PprofRequest id.
   */
  id: string;

  /**
   * PprofRequest pprofCpuProfileRequest.
   */
  pprofCpuProfileRequest?: api$PprofCpuProfileRequest | null;

  /**
   * PprofRequest pprofHeapProfileRequest.
   */
  pprofHeapProfileRequest?: api$PprofHeapProfileRequest | null;

  /**
   * PprofRequest pprofAllocsProfileRequest.
   */
  pprofAllocsProfileRequest?: api$PprofAllocsProfileRequest | null;

  /**
   * PprofRequest pprofBlockProfileRequest.
   */
  pprofBlockProfileRequest?: api$PprofBlockProfileRequest | null;

  /**
   * PprofRequest pprofMutexProfileRequest.
   */
  pprofMutexProfileRequest?: api$PprofMutexProfileRequest | null;

  /**
   * PprofRequest body.
   */
  body?:
    | "pprofCpuProfileRequest"
    | "pprofHeapProfileRequest"
    | "pprofAllocsProfileRequest"
    | "pprofBlockProfileRequest"
    | "pprofMutexProfileRequest";

  /**
   * Creates a new PprofRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PprofRequest instance
   */
  static create(properties?: api$IPprofRequest): api$PprofRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PprofRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PprofRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PprofRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PprofRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PprofRequest;

  /**
   * Decodes a PprofRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PprofRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PprofRequest;

  /**
   * Verifies a PprofRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PprofRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PprofRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PprofRequest;

  /**
   * Creates a plain object from a PprofRequest message. Also converts values to other types if specified.
   * @param message PprofRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PprofRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PprofRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PprofAllocsProfileRequest.
 */
declare type api$IPprofAllocsProfileRequest = {|
  /**
   * PprofAllocsProfileRequest debug
   */
  debug?: boolean | null,
|};

/**
 * Represents a PprofAllocsProfileRequest.
 */
declare class api$PprofAllocsProfileRequest {
  /**
   * Constructs a new PprofAllocsProfileRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPprofAllocsProfileRequest): this;

  /**
   * PprofAllocsProfileRequest debug.
   */
  debug: boolean;

  /**
   * Creates a new PprofAllocsProfileRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PprofAllocsProfileRequest instance
   */
  static create(
    properties?: api$IPprofAllocsProfileRequest
  ): api$PprofAllocsProfileRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofAllocsProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PprofAllocsProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofAllocsProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PprofAllocsProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PprofAllocsProfileRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PprofAllocsProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PprofAllocsProfileRequest;

  /**
   * Decodes a PprofAllocsProfileRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PprofAllocsProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PprofAllocsProfileRequest;

  /**
   * Verifies a PprofAllocsProfileRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PprofAllocsProfileRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PprofAllocsProfileRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PprofAllocsProfileRequest;

  /**
   * Creates a plain object from a PprofAllocsProfileRequest message. Also converts values to other types if specified.
   * @param message PprofAllocsProfileRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PprofAllocsProfileRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PprofAllocsProfileRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PprofBlockProfileRequest.
 */
declare type api$IPprofBlockProfileRequest = {|
  /**
   * PprofBlockProfileRequest debug
   */
  debug?: boolean | null,
|};

/**
 * Represents a PprofBlockProfileRequest.
 */
declare class api$PprofBlockProfileRequest {
  /**
   * Constructs a new PprofBlockProfileRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPprofBlockProfileRequest): this;

  /**
   * PprofBlockProfileRequest debug.
   */
  debug: boolean;

  /**
   * Creates a new PprofBlockProfileRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PprofBlockProfileRequest instance
   */
  static create(
    properties?: api$IPprofBlockProfileRequest
  ): api$PprofBlockProfileRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofBlockProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PprofBlockProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofBlockProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PprofBlockProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PprofBlockProfileRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PprofBlockProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PprofBlockProfileRequest;

  /**
   * Decodes a PprofBlockProfileRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PprofBlockProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PprofBlockProfileRequest;

  /**
   * Verifies a PprofBlockProfileRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PprofBlockProfileRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PprofBlockProfileRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PprofBlockProfileRequest;

  /**
   * Creates a plain object from a PprofBlockProfileRequest message. Also converts values to other types if specified.
   * @param message PprofBlockProfileRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PprofBlockProfileRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PprofBlockProfileRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PprofCpuProfileRequest.
 */
declare type api$IPprofCpuProfileRequest = {|
  /**
   * PprofCpuProfileRequest seconds
   */
  seconds?: number | null,
|};

/**
 * Represents a PprofCpuProfileRequest.
 */
declare class api$PprofCpuProfileRequest {
  /**
   * Constructs a new PprofCpuProfileRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPprofCpuProfileRequest): this;

  /**
   * PprofCpuProfileRequest seconds.
   */
  seconds: number;

  /**
   * Creates a new PprofCpuProfileRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PprofCpuProfileRequest instance
   */
  static create(
    properties?: api$IPprofCpuProfileRequest
  ): api$PprofCpuProfileRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofCpuProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PprofCpuProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofCpuProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PprofCpuProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PprofCpuProfileRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PprofCpuProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PprofCpuProfileRequest;

  /**
   * Decodes a PprofCpuProfileRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PprofCpuProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PprofCpuProfileRequest;

  /**
   * Verifies a PprofCpuProfileRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PprofCpuProfileRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PprofCpuProfileRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PprofCpuProfileRequest;

  /**
   * Creates a plain object from a PprofCpuProfileRequest message. Also converts values to other types if specified.
   * @param message PprofCpuProfileRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PprofCpuProfileRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PprofCpuProfileRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PprofHeapProfileRequest.
 */
declare type api$IPprofHeapProfileRequest = {|
  /**
   * PprofHeapProfileRequest gc
   */
  gc?: boolean | null,

  /**
   * PprofHeapProfileRequest debug
   */
  debug?: boolean | null,
|};

/**
 * Represents a PprofHeapProfileRequest.
 */
declare class api$PprofHeapProfileRequest {
  /**
   * Constructs a new PprofHeapProfileRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPprofHeapProfileRequest): this;

  /**
   * PprofHeapProfileRequest gc.
   */
  gc: boolean;

  /**
   * PprofHeapProfileRequest debug.
   */
  debug: boolean;

  /**
   * Creates a new PprofHeapProfileRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PprofHeapProfileRequest instance
   */
  static create(
    properties?: api$IPprofHeapProfileRequest
  ): api$PprofHeapProfileRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofHeapProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PprofHeapProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofHeapProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PprofHeapProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PprofHeapProfileRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PprofHeapProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PprofHeapProfileRequest;

  /**
   * Decodes a PprofHeapProfileRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PprofHeapProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PprofHeapProfileRequest;

  /**
   * Verifies a PprofHeapProfileRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PprofHeapProfileRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PprofHeapProfileRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PprofHeapProfileRequest;

  /**
   * Creates a plain object from a PprofHeapProfileRequest message. Also converts values to other types if specified.
   * @param message PprofHeapProfileRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PprofHeapProfileRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PprofHeapProfileRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PprofMutexProfileRequest.
 */
declare type api$IPprofMutexProfileRequest = {|
  /**
   * PprofMutexProfileRequest debug
   */
  debug?: boolean | null,
|};

/**
 * Represents a PprofMutexProfileRequest.
 */
declare class api$PprofMutexProfileRequest {
  /**
   * Constructs a new PprofMutexProfileRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPprofMutexProfileRequest): this;

  /**
   * PprofMutexProfileRequest debug.
   */
  debug: boolean;

  /**
   * Creates a new PprofMutexProfileRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PprofMutexProfileRequest instance
   */
  static create(
    properties?: api$IPprofMutexProfileRequest
  ): api$PprofMutexProfileRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofMutexProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PprofMutexProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofMutexProfileRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PprofMutexProfileRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PprofMutexProfileRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PprofMutexProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PprofMutexProfileRequest;

  /**
   * Decodes a PprofMutexProfileRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PprofMutexProfileRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PprofMutexProfileRequest;

  /**
   * Verifies a PprofMutexProfileRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PprofMutexProfileRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PprofMutexProfileRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PprofMutexProfileRequest;

  /**
   * Creates a plain object from a PprofMutexProfileRequest message. Also converts values to other types if specified.
   * @param message PprofMutexProfileRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PprofMutexProfileRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PprofMutexProfileRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PprofResponse.
 */
declare type api$IPprofResponse = {|
  /**
   * PprofResponse id
   */
  id?: string | null,

  /**
   * PprofResponse profile
   */
  profile?: Uint8Array | null,
|};

/**
 * Represents a PprofResponse.
 */
declare class api$PprofResponse {
  /**
   * Constructs a new PprofResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPprofResponse): this;

  /**
   * PprofResponse id.
   */
  id: string;

  /**
   * PprofResponse profile.
   */
  profile: Uint8Array;

  /**
   * Creates a new PprofResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PprofResponse instance
   */
  static create(properties?: api$IPprofResponse): api$PprofResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PprofResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PprofResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PprofResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PprofResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PprofResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PprofResponse;

  /**
   * Decodes a PprofResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PprofResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$PprofResponse;

  /**
   * Verifies a PprofResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PprofResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PprofResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PprofResponse;

  /**
   * Creates a plain object from a PprofResponse message. Also converts values to other types if specified.
   * @param message PprofResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PprofResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PprofResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a PTYConfig.
 */
declare type api$IPTYConfig = {|
  /**
   * PTYConfig pipeMode
   */
  pipeMode?: boolean | null,
|};

/**
 * Represents a PTYConfig.
 */
declare class api$PTYConfig {
  /**
   * Constructs a new PTYConfig.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPTYConfig): this;

  /**
   * PTYConfig pipeMode.
   */
  pipeMode: boolean;

  /**
   * Creates a new PTYConfig instance using the specified properties.
   * @param [properties] Properties to set
   * @returns PTYConfig instance
   */
  static create(properties?: api$IPTYConfig): api$PTYConfig;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PTYConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$PTYConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message PTYConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$PTYConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a PTYConfig message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns PTYConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$PTYConfig;

  /**
   * Decodes a PTYConfig message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns PTYConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$PTYConfig;

  /**
   * Verifies a PTYConfig message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a PTYConfig message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns PTYConfig
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$PTYConfig;

  /**
   * Creates a plain object from a PTYConfig message. Also converts values to other types if specified.
   * @param message PTYConfig
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$PTYConfig,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this PTYConfig to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugMain.
 */
declare type api$IDebugMain = {|
  /**
   * DebugMain session
   */
  session?: string | null,

  /**
   * DebugMain readOnly
   */
  readOnly?: boolean | null,
|};

/**
 * Represents a DebugMain.
 */
declare class api$DebugMain {
  /**
   * Constructs a new DebugMain.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebugMain): this;

  /**
   * DebugMain session.
   */
  session: string;

  /**
   * DebugMain readOnly.
   */
  readOnly: boolean;

  /**
   * Creates a new DebugMain instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugMain instance
   */
  static create(properties?: api$IDebugMain): api$DebugMain;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugMain message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DebugMain,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugMain message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DebugMain,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugMain message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugMain
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DebugMain;

  /**
   * Decodes a DebugMain message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugMain
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$DebugMain;

  /**
   * Verifies a DebugMain message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugMain message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugMain
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DebugMain;

  /**
   * Creates a plain object from a DebugMain message. Also converts values to other types if specified.
   * @param message DebugMain
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DebugMain,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugMain to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugMainReply.
 */
declare type api$IDebugMainReply = {|
  /**
   * DebugMainReply joined
   */
  joined?: boolean | null,

  /**
   * DebugMainReply protocol
   */
  protocol?: $Values<typeof api$DebugMainReply$Protocol> | null,
|};

/**
 * Represents a DebugMainReply.
 */
declare class api$DebugMainReply {
  /**
   * Constructs a new DebugMainReply.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebugMainReply): this;

  /**
   * DebugMainReply joined.
   */
  joined: boolean;

  /**
   * DebugMainReply protocol.
   */
  protocol: $Values<typeof api$DebugMainReply$Protocol>;

  /**
   * Creates a new DebugMainReply instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugMainReply instance
   */
  static create(properties?: api$IDebugMainReply): api$DebugMainReply;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugMainReply message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DebugMainReply,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugMainReply message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DebugMainReply,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugMainReply message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugMainReply
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DebugMainReply;

  /**
   * Decodes a DebugMainReply message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugMainReply
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DebugMainReply;

  /**
   * Verifies a DebugMainReply message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugMainReply message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugMainReply
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DebugMainReply;

  /**
   * Creates a plain object from a DebugMainReply message. Also converts values to other types if specified.
   * @param message DebugMainReply
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DebugMainReply,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugMainReply to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Protocol: typeof api$DebugMainReply$Protocol;
}

/**
 * Protocol enum.
 */

declare var api$DebugMainReply$Protocol: {|
  +DAP: 0, // 0
|};

/**
 * Properties of a DebugState.
 */
declare type api$IDebugState = {|
  /**
   * DebugState session
   */
  session?: string | null,

  /**
   * DebugState state
   */
  state?: $Values<typeof api$State> | null,
|};

/**
 * Represents a DebugState.
 */
declare class api$DebugState {
  /**
   * Constructs a new DebugState.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebugState): this;

  /**
   * DebugState session.
   */
  session: string;

  /**
   * DebugState state.
   */
  state: $Values<typeof api$State>;

  /**
   * Creates a new DebugState instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugState instance
   */
  static create(properties?: api$IDebugState): api$DebugState;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugState message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DebugState,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugState message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DebugState,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugState message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugState
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DebugState;

  /**
   * Decodes a DebugState message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugState
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$DebugState;

  /**
   * Verifies a DebugState message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugState message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugState
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DebugState;

  /**
   * Creates a plain object from a DebugState message. Also converts values to other types if specified.
   * @param message DebugState
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DebugState,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugState to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugInput.
 */
declare type api$IDebugInput = {|
  /**
   * DebugInput session
   */
  session?: string | null,

  /**
   * DebugInput input
   */
  input?: string | null,

  /**
   * DebugInput adapterInput
   */
  adapterInput?: string | null,
|};

/**
 * Represents a DebugInput.
 */
declare class api$DebugInput {
  /**
   * Constructs a new DebugInput.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebugInput): this;

  /**
   * DebugInput session.
   */
  session: string;

  /**
   * DebugInput input.
   */
  input?: string | null;

  /**
   * DebugInput adapterInput.
   */
  adapterInput?: string | null;

  /**
   * DebugInput stream.
   */
  stream?: "input" | "adapterInput";

  /**
   * Creates a new DebugInput instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugInput instance
   */
  static create(properties?: api$IDebugInput): api$DebugInput;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugInput message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DebugInput,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugInput message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DebugInput,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugInput message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugInput
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DebugInput;

  /**
   * Decodes a DebugInput message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugInput
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$DebugInput;

  /**
   * Verifies a DebugInput message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugInput message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugInput
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DebugInput;

  /**
   * Creates a plain object from a DebugInput message. Also converts values to other types if specified.
   * @param message DebugInput
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DebugInput,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugInput to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugOutput.
 */
declare type api$IDebugOutput = {|
  /**
   * DebugOutput session
   */
  session?: string | null,

  /**
   * DebugOutput output
   */
  output?: string | null,

  /**
   * DebugOutput adapterOutput
   */
  adapterOutput?: string | null,
|};

/**
 * Represents a DebugOutput.
 */
declare class api$DebugOutput {
  /**
   * Constructs a new DebugOutput.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebugOutput): this;

  /**
   * DebugOutput session.
   */
  session: string;

  /**
   * DebugOutput output.
   */
  output?: string | null;

  /**
   * DebugOutput adapterOutput.
   */
  adapterOutput?: string | null;

  /**
   * DebugOutput stream.
   */
  stream?: "output" | "adapterOutput";

  /**
   * Creates a new DebugOutput instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugOutput instance
   */
  static create(properties?: api$IDebugOutput): api$DebugOutput;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugOutput message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DebugOutput,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugOutput message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DebugOutput,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugOutput message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugOutput
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DebugOutput;

  /**
   * Decodes a DebugOutput message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugOutput
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DebugOutput;

  /**
   * Verifies a DebugOutput message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugOutput message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugOutput
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DebugOutput;

  /**
   * Creates a plain object from a DebugOutput message. Also converts values to other types if specified.
   * @param message DebugOutput
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DebugOutput,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugOutput to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugStop.
 */
declare type api$IDebugStop = {|
  /**
   * DebugStop session
   */
  session?: string | null,
|};

/**
 * Represents a DebugStop.
 */
declare class api$DebugStop {
  /**
   * Constructs a new DebugStop.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebugStop): this;

  /**
   * DebugStop session.
   */
  session: string;

  /**
   * Creates a new DebugStop instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugStop instance
   */
  static create(properties?: api$IDebugStop): api$DebugStop;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugStop message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DebugStop,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugStop message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DebugStop,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugStop message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugStop
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DebugStop;

  /**
   * Decodes a DebugStop message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugStop
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$DebugStop;

  /**
   * Verifies a DebugStop message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugStop message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugStop
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DebugStop;

  /**
   * Creates a plain object from a DebugStop message. Also converts values to other types if specified.
   * @param message DebugStop
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DebugStop,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugStop to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugLeave.
 */
declare type api$IDebugLeave = {|
  /**
   * DebugLeave session
   */
  session?: string | null,
|};

/**
 * Represents a DebugLeave.
 */
declare class api$DebugLeave {
  /**
   * Constructs a new DebugLeave.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebugLeave): this;

  /**
   * DebugLeave session.
   */
  session: string;

  /**
   * Creates a new DebugLeave instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugLeave instance
   */
  static create(properties?: api$IDebugLeave): api$DebugLeave;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugLeave message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DebugLeave,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugLeave message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DebugLeave,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugLeave message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugLeave
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DebugLeave;

  /**
   * Decodes a DebugLeave message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugLeave
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$DebugLeave;

  /**
   * Verifies a DebugLeave message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugLeave message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugLeave
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DebugLeave;

  /**
   * Creates a plain object from a DebugLeave message. Also converts values to other types if specified.
   * @param message DebugLeave
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DebugLeave,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugLeave to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugSessions.
 */
declare type api$IDebugSessions = {|
  /**
   * DebugSessions sessions
   */
  sessions?: {|
    [k: string]: $Values<typeof api$State>,
  |} | null,
|};

/**
 * Represents a DebugSessions.
 */
declare class api$DebugSessions {
  /**
   * Constructs a new DebugSessions.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebugSessions): this;

  /**
   * DebugSessions sessions.
   */
  sessions: {|
    [k: string]: $Values<typeof api$State>,
  |};

  /**
   * Creates a new DebugSessions instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugSessions instance
   */
  static create(properties?: api$IDebugSessions): api$DebugSessions;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugSessions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DebugSessions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugSessions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DebugSessions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugSessions message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugSessions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DebugSessions;

  /**
   * Decodes a DebugSessions message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugSessions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DebugSessions;

  /**
   * Verifies a DebugSessions message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugSessions message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugSessions
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DebugSessions;

  /**
   * Creates a plain object from a DebugSessions message. Also converts values to other types if specified.
   * @param message DebugSessions
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DebugSessions,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugSessions to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitGetRequest.
 */
declare type api$IDotReplitGetRequest = {||};

/**
 * Represents a DotReplitGetRequest.
 */
declare class api$DotReplitGetRequest {
  /**
   * Constructs a new DotReplitGetRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDotReplitGetRequest): this;

  /**
   * Creates a new DotReplitGetRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitGetRequest instance
   */
  static create(properties?: api$IDotReplitGetRequest): api$DotReplitGetRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitGetRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DotReplitGetRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitGetRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DotReplitGetRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitGetRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitGetRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DotReplitGetRequest;

  /**
   * Decodes a DotReplitGetRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitGetRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DotReplitGetRequest;

  /**
   * Verifies a DotReplitGetRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitGetRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitGetRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DotReplitGetRequest;

  /**
   * Creates a plain object from a DotReplitGetRequest message. Also converts values to other types if specified.
   * @param message DotReplitGetRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DotReplitGetRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitGetRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitGetResponse.
 */
declare type api$IDotReplitGetResponse = {|
  /**
   * DotReplitGetResponse dotReplit
   */
  dotReplit?: api$DotReplit | api$IDotReplit | null,
|};

/**
 * Represents a DotReplitGetResponse.
 */
declare class api$DotReplitGetResponse {
  /**
   * Constructs a new DotReplitGetResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDotReplitGetResponse): this;

  /**
   * DotReplitGetResponse dotReplit.
   */
  dotReplit?: api$DotReplit | null;

  /**
   * Creates a new DotReplitGetResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitGetResponse instance
   */
  static create(
    properties?: api$IDotReplitGetResponse
  ): api$DotReplitGetResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitGetResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DotReplitGetResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitGetResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DotReplitGetResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitGetResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitGetResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DotReplitGetResponse;

  /**
   * Decodes a DotReplitGetResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitGetResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DotReplitGetResponse;

  /**
   * Verifies a DotReplitGetResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitGetResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitGetResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DotReplitGetResponse;

  /**
   * Creates a plain object from a DotReplitGetResponse message. Also converts values to other types if specified.
   * @param message DotReplitGetResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DotReplitGetResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitGetResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a RunConfigGetRequest.
 */
declare type api$IRunConfigGetRequest = {||};

/**
 * Represents a RunConfigGetRequest.
 */
declare class api$RunConfigGetRequest {
  /**
   * Constructs a new RunConfigGetRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IRunConfigGetRequest): this;

  /**
   * Creates a new RunConfigGetRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns RunConfigGetRequest instance
   */
  static create(properties?: api$IRunConfigGetRequest): api$RunConfigGetRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RunConfigGetRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$RunConfigGetRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RunConfigGetRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$RunConfigGetRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a RunConfigGetRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns RunConfigGetRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$RunConfigGetRequest;

  /**
   * Decodes a RunConfigGetRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns RunConfigGetRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$RunConfigGetRequest;

  /**
   * Verifies a RunConfigGetRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a RunConfigGetRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns RunConfigGetRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$RunConfigGetRequest;

  /**
   * Creates a plain object from a RunConfigGetRequest message. Also converts values to other types if specified.
   * @param message RunConfigGetRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$RunConfigGetRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this RunConfigGetRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a RunConfigGetResponse.
 */
declare type api$IRunConfigGetResponse = {|
  /**
   * RunConfigGetResponse interp
   */
  interp?: api$DotReplitInterp | api$IDotReplitInterp | null,

  /**
   * RunConfigGetResponse run
   */
  run?: api$RunConfigGetResponse$Run | api$RunConfigGetResponse$IRun | null,
|};

/**
 * Represents a RunConfigGetResponse.
 */
declare class api$RunConfigGetResponse {
  /**
   * Constructs a new RunConfigGetResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IRunConfigGetResponse): this;

  /**
   * RunConfigGetResponse interp.
   */
  interp?: api$DotReplitInterp | null;

  /**
   * RunConfigGetResponse run.
   */
  run?: api$RunConfigGetResponse$Run | null;

  /**
   * RunConfigGetResponse config.
   */
  config?: "interp" | "run";

  /**
   * Creates a new RunConfigGetResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns RunConfigGetResponse instance
   */
  static create(
    properties?: api$IRunConfigGetResponse
  ): api$RunConfigGetResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RunConfigGetResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$RunConfigGetResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message RunConfigGetResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$RunConfigGetResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a RunConfigGetResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns RunConfigGetResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$RunConfigGetResponse;

  /**
   * Decodes a RunConfigGetResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns RunConfigGetResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$RunConfigGetResponse;

  /**
   * Verifies a RunConfigGetResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a RunConfigGetResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns RunConfigGetResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$RunConfigGetResponse;

  /**
   * Creates a plain object from a RunConfigGetResponse message. Also converts values to other types if specified.
   * @param message RunConfigGetResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$RunConfigGetResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this RunConfigGetResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static IRun: Class<api$RunConfigGetResponse$IRun>;
  static Run: typeof api$RunConfigGetResponse$Run;
}

/**
 * Properties of a Run.
 */
declare type api$RunConfigGetResponse$IRun = {|
  /**
   * Run compile
   */
  compile?: api$Exec | api$IExec | null,

  /**
   * Run run
   */
  run?: api$Exec | api$IExec | null,
|};

/**
 * Represents a Run.
 */
declare class api$RunConfigGetResponse$Run {
  /**
   * Constructs a new Run.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$RunConfigGetResponse$IRun): this;

  /**
   * Run compile.
   */
  compile?: api$Exec | null;

  /**
   * Run run.
   */
  run?: api$Exec | null;

  /**
   * Creates a new Run instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Run instance
   */
  static create(
    properties?: api$RunConfigGetResponse$IRun
  ): api$RunConfigGetResponse$Run;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Run message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$RunConfigGetResponse$Run,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Run message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$RunConfigGetResponse$Run,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Run message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Run
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$RunConfigGetResponse$Run;

  /**
   * Decodes a Run message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Run
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$RunConfigGetResponse$Run;

  /**
   * Verifies a Run message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Run message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Run
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$RunConfigGetResponse$Run;

  /**
   * Creates a plain object from a Run message. Also converts values to other types if specified.
   * @param message Run
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$RunConfigGetResponse$Run,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Run to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitUpdateOp.
 */
declare type api$IDotReplitUpdateOp = {|
  /**
   * DotReplitUpdateOp op
   */
  op?: string | null,

  /**
   * DotReplitUpdateOp path
   */
  path?: string | null,

  /**
   * DotReplitUpdateOp value
   */
  value?: string | null,
|};

/**
 * Represents a DotReplitUpdateOp.
 */
declare class api$DotReplitUpdateOp {
  /**
   * Constructs a new DotReplitUpdateOp.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDotReplitUpdateOp): this;

  /**
   * DotReplitUpdateOp op.
   */
  op: string;

  /**
   * DotReplitUpdateOp path.
   */
  path: string;

  /**
   * DotReplitUpdateOp value.
   */
  value: string;

  /**
   * Creates a new DotReplitUpdateOp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitUpdateOp instance
   */
  static create(properties?: api$IDotReplitUpdateOp): api$DotReplitUpdateOp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUpdateOp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DotReplitUpdateOp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUpdateOp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DotReplitUpdateOp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitUpdateOp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitUpdateOp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DotReplitUpdateOp;

  /**
   * Decodes a DotReplitUpdateOp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitUpdateOp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DotReplitUpdateOp;

  /**
   * Verifies a DotReplitUpdateOp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitUpdateOp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitUpdateOp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DotReplitUpdateOp;

  /**
   * Creates a plain object from a DotReplitUpdateOp message. Also converts values to other types if specified.
   * @param message DotReplitUpdateOp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DotReplitUpdateOp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitUpdateOp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitUpdateRequest.
 */
declare type api$IDotReplitUpdateRequest = {|
  /**
   * DotReplitUpdateRequest ops
   */
  ops?: (api$DotReplitUpdateOp | api$IDotReplitUpdateOp)[] | null,
|};

/**
 * Represents a DotReplitUpdateRequest.
 */
declare class api$DotReplitUpdateRequest {
  /**
   * Constructs a new DotReplitUpdateRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDotReplitUpdateRequest): this;

  /**
   * DotReplitUpdateRequest ops.
   */
  ops: api$DotReplitUpdateOp[];

  /**
   * Creates a new DotReplitUpdateRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitUpdateRequest instance
   */
  static create(
    properties?: api$IDotReplitUpdateRequest
  ): api$DotReplitUpdateRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUpdateRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DotReplitUpdateRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUpdateRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DotReplitUpdateRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitUpdateRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitUpdateRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DotReplitUpdateRequest;

  /**
   * Decodes a DotReplitUpdateRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitUpdateRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DotReplitUpdateRequest;

  /**
   * Verifies a DotReplitUpdateRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitUpdateRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitUpdateRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DotReplitUpdateRequest;

  /**
   * Creates a plain object from a DotReplitUpdateRequest message. Also converts values to other types if specified.
   * @param message DotReplitUpdateRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DotReplitUpdateRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitUpdateRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitUpdateResponse.
 */
declare type api$IDotReplitUpdateResponse = {||};

/**
 * Represents a DotReplitUpdateResponse.
 */
declare class api$DotReplitUpdateResponse {
  /**
   * Constructs a new DotReplitUpdateResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDotReplitUpdateResponse): this;

  /**
   * Creates a new DotReplitUpdateResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitUpdateResponse instance
   */
  static create(
    properties?: api$IDotReplitUpdateResponse
  ): api$DotReplitUpdateResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUpdateResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DotReplitUpdateResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUpdateResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DotReplitUpdateResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitUpdateResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitUpdateResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DotReplitUpdateResponse;

  /**
   * Decodes a DotReplitUpdateResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitUpdateResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DotReplitUpdateResponse;

  /**
   * Verifies a DotReplitUpdateResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitUpdateResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitUpdateResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DotReplitUpdateResponse;

  /**
   * Creates a plain object from a DotReplitUpdateResponse message. Also converts values to other types if specified.
   * @param message DotReplitUpdateResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DotReplitUpdateResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitUpdateResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugAddBreakpointRequest.
 */
declare type api$IDebugAddBreakpointRequest = {|
  /**
   * DebugAddBreakpointRequest path
   */
  path?: string | null,

  /**
   * DebugAddBreakpointRequest otVersion
   */
  otVersion?: number | null,

  /**
   * DebugAddBreakpointRequest otIndex
   */
  otIndex?: number | null,

  /**
   * DebugAddBreakpointRequest sessionLocal
   */
  sessionLocal?: boolean | null,

  /**
   * DebugAddBreakpointRequest line
   */
  line?: number | null,

  /**
   * DebugAddBreakpointRequest logMessage
   */
  logMessage?: string | null,
|};

/**
 * Represents a DebugAddBreakpointRequest.
 */
declare class api$DebugAddBreakpointRequest {
  /**
   * Constructs a new DebugAddBreakpointRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebugAddBreakpointRequest): this;

  /**
   * DebugAddBreakpointRequest path.
   */
  path: string;

  /**
   * DebugAddBreakpointRequest otVersion.
   */
  otVersion: number;

  /**
   * DebugAddBreakpointRequest otIndex.
   */
  otIndex: number;

  /**
   * DebugAddBreakpointRequest sessionLocal.
   */
  sessionLocal: boolean;

  /**
   * DebugAddBreakpointRequest line.
   */
  line: number;

  /**
   * DebugAddBreakpointRequest logMessage.
   */
  logMessage: string;

  /**
   * Creates a new DebugAddBreakpointRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugAddBreakpointRequest instance
   */
  static create(
    properties?: api$IDebugAddBreakpointRequest
  ): api$DebugAddBreakpointRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugAddBreakpointRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DebugAddBreakpointRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugAddBreakpointRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DebugAddBreakpointRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugAddBreakpointRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugAddBreakpointRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DebugAddBreakpointRequest;

  /**
   * Decodes a DebugAddBreakpointRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugAddBreakpointRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DebugAddBreakpointRequest;

  /**
   * Verifies a DebugAddBreakpointRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugAddBreakpointRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugAddBreakpointRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DebugAddBreakpointRequest;

  /**
   * Creates a plain object from a DebugAddBreakpointRequest message. Also converts values to other types if specified.
   * @param message DebugAddBreakpointRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DebugAddBreakpointRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugAddBreakpointRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugUpdateBreakpointRequest.
 */
declare type api$IDebugUpdateBreakpointRequest = {|
  /**
   * DebugUpdateBreakpointRequest breakpointId
   */
  breakpointId?: string | null,

  /**
   * DebugUpdateBreakpointRequest logMessage
   */
  logMessage?: string | null,
|};

/**
 * Represents a DebugUpdateBreakpointRequest.
 */
declare class api$DebugUpdateBreakpointRequest {
  /**
   * Constructs a new DebugUpdateBreakpointRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebugUpdateBreakpointRequest): this;

  /**
   * DebugUpdateBreakpointRequest breakpointId.
   */
  breakpointId: string;

  /**
   * DebugUpdateBreakpointRequest logMessage.
   */
  logMessage: string;

  /**
   * Creates a new DebugUpdateBreakpointRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugUpdateBreakpointRequest instance
   */
  static create(
    properties?: api$IDebugUpdateBreakpointRequest
  ): api$DebugUpdateBreakpointRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugUpdateBreakpointRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DebugUpdateBreakpointRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugUpdateBreakpointRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DebugUpdateBreakpointRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugUpdateBreakpointRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugUpdateBreakpointRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DebugUpdateBreakpointRequest;

  /**
   * Decodes a DebugUpdateBreakpointRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugUpdateBreakpointRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DebugUpdateBreakpointRequest;

  /**
   * Verifies a DebugUpdateBreakpointRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugUpdateBreakpointRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugUpdateBreakpointRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DebugUpdateBreakpointRequest;

  /**
   * Creates a plain object from a DebugUpdateBreakpointRequest message. Also converts values to other types if specified.
   * @param message DebugUpdateBreakpointRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DebugUpdateBreakpointRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugUpdateBreakpointRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugRemoveBreakpointRequest.
 */
declare type api$IDebugRemoveBreakpointRequest = {|
  /**
   * DebugRemoveBreakpointRequest breakpointId
   */
  breakpointId?: string | null,
|};

/**
 * Represents a DebugRemoveBreakpointRequest.
 */
declare class api$DebugRemoveBreakpointRequest {
  /**
   * Constructs a new DebugRemoveBreakpointRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebugRemoveBreakpointRequest): this;

  /**
   * DebugRemoveBreakpointRequest breakpointId.
   */
  breakpointId: string;

  /**
   * Creates a new DebugRemoveBreakpointRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugRemoveBreakpointRequest instance
   */
  static create(
    properties?: api$IDebugRemoveBreakpointRequest
  ): api$DebugRemoveBreakpointRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugRemoveBreakpointRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DebugRemoveBreakpointRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugRemoveBreakpointRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DebugRemoveBreakpointRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugRemoveBreakpointRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugRemoveBreakpointRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DebugRemoveBreakpointRequest;

  /**
   * Decodes a DebugRemoveBreakpointRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugRemoveBreakpointRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DebugRemoveBreakpointRequest;

  /**
   * Verifies a DebugRemoveBreakpointRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugRemoveBreakpointRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugRemoveBreakpointRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DebugRemoveBreakpointRequest;

  /**
   * Creates a plain object from a DebugRemoveBreakpointRequest message. Also converts values to other types if specified.
   * @param message DebugRemoveBreakpointRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DebugRemoveBreakpointRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugRemoveBreakpointRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugBreakpointEvent.
 */
declare type api$IDebugBreakpointEvent = {|
  /**
   * DebugBreakpointEvent path
   */
  path?: string | null,

  /**
   * DebugBreakpointEvent absolutePath
   */
  absolutePath?: string | null,

  /**
   * DebugBreakpointEvent breakpoints
   */
  breakpoints?: (api$DebugBreakpoint | api$IDebugBreakpoint)[] | null,
|};

/**
 * Represents a DebugBreakpointEvent.
 */
declare class api$DebugBreakpointEvent {
  /**
   * Constructs a new DebugBreakpointEvent.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebugBreakpointEvent): this;

  /**
   * DebugBreakpointEvent path.
   */
  path: string;

  /**
   * DebugBreakpointEvent absolutePath.
   */
  absolutePath: string;

  /**
   * DebugBreakpointEvent breakpoints.
   */
  breakpoints: api$DebugBreakpoint[];

  /**
   * Creates a new DebugBreakpointEvent instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugBreakpointEvent instance
   */
  static create(
    properties?: api$IDebugBreakpointEvent
  ): api$DebugBreakpointEvent;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugBreakpointEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DebugBreakpointEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugBreakpointEvent message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DebugBreakpointEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugBreakpointEvent message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugBreakpointEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DebugBreakpointEvent;

  /**
   * Decodes a DebugBreakpointEvent message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugBreakpointEvent
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DebugBreakpointEvent;

  /**
   * Verifies a DebugBreakpointEvent message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugBreakpointEvent message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugBreakpointEvent
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DebugBreakpointEvent;

  /**
   * Creates a plain object from a DebugBreakpointEvent message. Also converts values to other types if specified.
   * @param message DebugBreakpointEvent
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DebugBreakpointEvent,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugBreakpointEvent to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebugBreakpoint.
 */
declare type api$IDebugBreakpoint = {|
  /**
   * DebugBreakpoint breakpointId
   */
  breakpointId?: string | null,

  /**
   * DebugBreakpoint line
   */
  line?: number | null,

  /**
   * DebugBreakpoint otVersion
   */
  otVersion?: number | null,

  /**
   * DebugBreakpoint otIndex
   */
  otIndex?: number | null,

  /**
   * DebugBreakpoint sessionLocal
   */
  sessionLocal?: boolean | null,

  /**
   * DebugBreakpoint logMessage
   */
  logMessage?: string | null,
|};

/**
 * Represents a DebugBreakpoint.
 */
declare class api$DebugBreakpoint {
  /**
   * Constructs a new DebugBreakpoint.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebugBreakpoint): this;

  /**
   * DebugBreakpoint breakpointId.
   */
  breakpointId: string;

  /**
   * DebugBreakpoint line.
   */
  line: number;

  /**
   * DebugBreakpoint otVersion.
   */
  otVersion: number;

  /**
   * DebugBreakpoint otIndex.
   */
  otIndex: number;

  /**
   * DebugBreakpoint sessionLocal.
   */
  sessionLocal: boolean;

  /**
   * DebugBreakpoint logMessage.
   */
  logMessage: string;

  /**
   * Creates a new DebugBreakpoint instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebugBreakpoint instance
   */
  static create(properties?: api$IDebugBreakpoint): api$DebugBreakpoint;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugBreakpoint message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DebugBreakpoint,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebugBreakpoint message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DebugBreakpoint,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebugBreakpoint message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebugBreakpoint
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DebugBreakpoint;

  /**
   * Decodes a DebugBreakpoint message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebugBreakpoint
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DebugBreakpoint;

  /**
   * Verifies a DebugBreakpoint message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebugBreakpoint message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebugBreakpoint
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DebugBreakpoint;

  /**
   * Creates a plain object from a DebugBreakpoint message. Also converts values to other types if specified.
   * @param message DebugBreakpoint
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DebugBreakpoint,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebugBreakpoint to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplit.
 */
declare type api$IDotReplit = {|
  /**
   * DotReplit run
   */
  run?: api$Exec | api$IExec | null,

  /**
   * DotReplit compile
   */
  compile?: api$Exec | api$IExec | null,

  /**
   * DotReplit debugger
   */
  debugger?: api$DebuggerConfig | api$IDebuggerConfig | null,

  /**
   * DotReplit language
   */
  language?: string | null,

  /**
   * DotReplit onBoot
   */
  onBoot?: api$Exec | api$IExec | null,

  /**
   * DotReplit packager
   */
  packager?: api$DotReplitPackager | api$IDotReplitPackager | null,

  /**
   * DotReplit interpreter
   */
  interpreter?: api$DotReplitInterp | api$IDotReplitInterp | null,

  /**
   * DotReplit entrypoint
   */
  entrypoint?: string | null,

  /**
   * DotReplit languages
   */
  languages?: {|
    [k: string]: api$DotReplitLanguage | api$IDotReplitLanguage,
  |} | null,

  /**
   * DotReplit unitTest
   */
  unitTest?: api$DotReplitUnitTest | api$IDotReplitUnitTest | null,

  /**
   * DotReplit hidden
   */
  hidden?: string[] | null,
|};

/**
 * Represents a DotReplit.
 */
declare class api$DotReplit {
  /**
   * Constructs a new DotReplit.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDotReplit): this;

  /**
   * DotReplit run.
   */
  run?: api$Exec | null;

  /**
   * DotReplit compile.
   */
  compile?: api$Exec | null;

  /**
   * DotReplit debugger.
   */
  debugger?: api$DebuggerConfig | null;

  /**
   * DotReplit language.
   */
  language: string;

  /**
   * DotReplit onBoot.
   */
  onBoot?: api$Exec | null;

  /**
   * DotReplit packager.
   */
  packager?: api$DotReplitPackager | null;

  /**
   * DotReplit interpreter.
   */
  interpreter?: api$DotReplitInterp | null;

  /**
   * DotReplit entrypoint.
   */
  entrypoint: string;

  /**
   * DotReplit languages.
   */
  languages: {|
    [k: string]: api$DotReplitLanguage,
  |};

  /**
   * DotReplit unitTest.
   */
  unitTest?: api$DotReplitUnitTest | null;

  /**
   * DotReplit hidden.
   */
  hidden: string[];

  /**
   * Creates a new DotReplit instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplit instance
   */
  static create(properties?: api$IDotReplit): api$DotReplit;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplit message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DotReplit,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplit message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DotReplit,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplit message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplit
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DotReplit;

  /**
   * Decodes a DotReplit message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplit
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$DotReplit;

  /**
   * Verifies a DotReplit message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplit message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplit
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DotReplit;

  /**
   * Creates a plain object from a DotReplit message. Also converts values to other types if specified.
   * @param message DotReplit
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DotReplit,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplit to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitInterp.
 */
declare type api$IDotReplitInterp = {|
  /**
   * DotReplitInterp command
   */
  command?: api$Exec | api$IExec | null,

  /**
   * DotReplitInterp prompt
   */
  prompt?: Uint8Array | null,
|};

/**
 * Represents a DotReplitInterp.
 */
declare class api$DotReplitInterp {
  /**
   * Constructs a new DotReplitInterp.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDotReplitInterp): this;

  /**
   * DotReplitInterp command.
   */
  command?: api$Exec | null;

  /**
   * DotReplitInterp prompt.
   */
  prompt: Uint8Array;

  /**
   * Creates a new DotReplitInterp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitInterp instance
   */
  static create(properties?: api$IDotReplitInterp): api$DotReplitInterp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitInterp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DotReplitInterp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitInterp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DotReplitInterp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitInterp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitInterp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DotReplitInterp;

  /**
   * Decodes a DotReplitInterp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitInterp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DotReplitInterp;

  /**
   * Verifies a DotReplitInterp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitInterp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitInterp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DotReplitInterp;

  /**
   * Creates a plain object from a DotReplitInterp message. Also converts values to other types if specified.
   * @param message DotReplitInterp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DotReplitInterp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitInterp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitLanguage.
 */
declare type api$IDotReplitLanguage = {|
  /**
   * DotReplitLanguage pattern
   */
  pattern?: string | null,

  /**
   * DotReplitLanguage syntax
   */
  syntax?: string | null,

  /**
   * DotReplitLanguage languageServer
   */
  languageServer?: api$LanguageServerConfig | api$ILanguageServerConfig | null,
|};

/**
 * Represents a DotReplitLanguage.
 */
declare class api$DotReplitLanguage {
  /**
   * Constructs a new DotReplitLanguage.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDotReplitLanguage): this;

  /**
   * DotReplitLanguage pattern.
   */
  pattern: string;

  /**
   * DotReplitLanguage syntax.
   */
  syntax: string;

  /**
   * DotReplitLanguage languageServer.
   */
  languageServer?: api$LanguageServerConfig | null;

  /**
   * Creates a new DotReplitLanguage instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitLanguage instance
   */
  static create(properties?: api$IDotReplitLanguage): api$DotReplitLanguage;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitLanguage message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DotReplitLanguage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitLanguage message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DotReplitLanguage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitLanguage message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitLanguage
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DotReplitLanguage;

  /**
   * Decodes a DotReplitLanguage message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitLanguage
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DotReplitLanguage;

  /**
   * Verifies a DotReplitLanguage message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitLanguage message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitLanguage
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DotReplitLanguage;

  /**
   * Creates a plain object from a DotReplitLanguage message. Also converts values to other types if specified.
   * @param message DotReplitLanguage
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DotReplitLanguage,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitLanguage to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a LanguageServerConfig.
 */
declare type api$ILanguageServerConfig = {|
  /**
   * LanguageServerConfig startCommand
   */
  startCommand?: api$Exec | api$IExec | null,

  /**
   * LanguageServerConfig configurationJson
   */
  configurationJson?: string | null,

  /**
   * LanguageServerConfig initializationOptionsJson
   */
  initializationOptionsJson?: string | null,
|};

/**
 * Represents a LanguageServerConfig.
 */
declare class api$LanguageServerConfig {
  /**
   * Constructs a new LanguageServerConfig.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ILanguageServerConfig): this;

  /**
   * LanguageServerConfig startCommand.
   */
  startCommand?: api$Exec | null;

  /**
   * LanguageServerConfig configurationJson.
   */
  configurationJson: string;

  /**
   * LanguageServerConfig initializationOptionsJson.
   */
  initializationOptionsJson: string;

  /**
   * Creates a new LanguageServerConfig instance using the specified properties.
   * @param [properties] Properties to set
   * @returns LanguageServerConfig instance
   */
  static create(
    properties?: api$ILanguageServerConfig
  ): api$LanguageServerConfig;

  /**
   * [object Object],[object Object],[object Object]
   * @param message LanguageServerConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$LanguageServerConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message LanguageServerConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$LanguageServerConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a LanguageServerConfig message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns LanguageServerConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$LanguageServerConfig;

  /**
   * Decodes a LanguageServerConfig message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns LanguageServerConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$LanguageServerConfig;

  /**
   * Verifies a LanguageServerConfig message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a LanguageServerConfig message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns LanguageServerConfig
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$LanguageServerConfig;

  /**
   * Creates a plain object from a LanguageServerConfig message. Also converts values to other types if specified.
   * @param message LanguageServerConfig
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$LanguageServerConfig,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this LanguageServerConfig to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitPackager.
 */
declare type api$IDotReplitPackager = {|
  /**
   * DotReplitPackager afterInstall
   */
  afterInstall?: api$Exec | api$IExec | null,

  /**
   * DotReplitPackager language
   */
  language?: string | null,

  /**
   * DotReplitPackager features
   */
  features?:
    | api$DotReplitPackagerFeatures
    | api$IDotReplitPackagerFeatures
    | null,

  /**
   * DotReplitPackager env
   */
  env?: {|
    [k: string]: string,
  |} | null,

  /**
   * DotReplitPackager ignoredPaths
   */
  ignoredPaths?: string[] | null,

  /**
   * DotReplitPackager ignoredPackages
   */
  ignoredPackages?: string[] | null,
|};

/**
 * Represents a DotReplitPackager.
 */
declare class api$DotReplitPackager {
  /**
   * Constructs a new DotReplitPackager.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDotReplitPackager): this;

  /**
   * DotReplitPackager afterInstall.
   */
  afterInstall?: api$Exec | null;

  /**
   * DotReplitPackager language.
   */
  language: string;

  /**
   * DotReplitPackager features.
   */
  features?: api$DotReplitPackagerFeatures | null;

  /**
   * DotReplitPackager env.
   */
  env: {|
    [k: string]: string,
  |};

  /**
   * DotReplitPackager ignoredPaths.
   */
  ignoredPaths: string[];

  /**
   * DotReplitPackager ignoredPackages.
   */
  ignoredPackages: string[];

  /**
   * Creates a new DotReplitPackager instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitPackager instance
   */
  static create(properties?: api$IDotReplitPackager): api$DotReplitPackager;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitPackager message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DotReplitPackager,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitPackager message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DotReplitPackager,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitPackager message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitPackager
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DotReplitPackager;

  /**
   * Decodes a DotReplitPackager message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitPackager
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DotReplitPackager;

  /**
   * Verifies a DotReplitPackager message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitPackager message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitPackager
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DotReplitPackager;

  /**
   * Creates a plain object from a DotReplitPackager message. Also converts values to other types if specified.
   * @param message DotReplitPackager
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DotReplitPackager,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitPackager to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitPackagerFeatures.
 */
declare type api$IDotReplitPackagerFeatures = {|
  /**
   * DotReplitPackagerFeatures packageSearch
   */
  packageSearch?: boolean | null,

  /**
   * DotReplitPackagerFeatures guessImports
   */
  guessImports?: boolean | null,
|};

/**
 * Represents a DotReplitPackagerFeatures.
 */
declare class api$DotReplitPackagerFeatures {
  /**
   * Constructs a new DotReplitPackagerFeatures.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDotReplitPackagerFeatures): this;

  /**
   * DotReplitPackagerFeatures packageSearch.
   */
  packageSearch: boolean;

  /**
   * DotReplitPackagerFeatures guessImports.
   */
  guessImports: boolean;

  /**
   * Creates a new DotReplitPackagerFeatures instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitPackagerFeatures instance
   */
  static create(
    properties?: api$IDotReplitPackagerFeatures
  ): api$DotReplitPackagerFeatures;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitPackagerFeatures message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DotReplitPackagerFeatures,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitPackagerFeatures message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DotReplitPackagerFeatures,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitPackagerFeatures message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitPackagerFeatures
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DotReplitPackagerFeatures;

  /**
   * Decodes a DotReplitPackagerFeatures message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitPackagerFeatures
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DotReplitPackagerFeatures;

  /**
   * Verifies a DotReplitPackagerFeatures message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitPackagerFeatures message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitPackagerFeatures
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DotReplitPackagerFeatures;

  /**
   * Creates a plain object from a DotReplitPackagerFeatures message. Also converts values to other types if specified.
   * @param message DotReplitPackagerFeatures
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DotReplitPackagerFeatures,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitPackagerFeatures to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DotReplitUnitTest.
 */
declare type api$IDotReplitUnitTest = {|
  /**
   * DotReplitUnitTest language
   */
  language?: string | null,
|};

/**
 * Represents a DotReplitUnitTest.
 */
declare class api$DotReplitUnitTest {
  /**
   * Constructs a new DotReplitUnitTest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDotReplitUnitTest): this;

  /**
   * DotReplitUnitTest language.
   */
  language: string;

  /**
   * Creates a new DotReplitUnitTest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DotReplitUnitTest instance
   */
  static create(properties?: api$IDotReplitUnitTest): api$DotReplitUnitTest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUnitTest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DotReplitUnitTest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DotReplitUnitTest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DotReplitUnitTest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DotReplitUnitTest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DotReplitUnitTest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DotReplitUnitTest;

  /**
   * Decodes a DotReplitUnitTest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DotReplitUnitTest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DotReplitUnitTest;

  /**
   * Verifies a DotReplitUnitTest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DotReplitUnitTest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DotReplitUnitTest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DotReplitUnitTest;

  /**
   * Creates a plain object from a DotReplitUnitTest message. Also converts values to other types if specified.
   * @param message DotReplitUnitTest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DotReplitUnitTest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DotReplitUnitTest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a DebuggerConfig.
 */
declare type api$IDebuggerConfig = {|
  /**
   * DebuggerConfig support
   */
  support?: boolean | null,
|};

/**
 * Represents a DebuggerConfig.
 */
declare class api$DebuggerConfig {
  /**
   * Constructs a new DebuggerConfig.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IDebuggerConfig): this;

  /**
   * DebuggerConfig support.
   */
  support: boolean;

  /**
   * Creates a new DebuggerConfig instance using the specified properties.
   * @param [properties] Properties to set
   * @returns DebuggerConfig instance
   */
  static create(properties?: api$IDebuggerConfig): api$DebuggerConfig;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebuggerConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$DebuggerConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message DebuggerConfig message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$DebuggerConfig,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a DebuggerConfig message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns DebuggerConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$DebuggerConfig;

  /**
   * Decodes a DebuggerConfig message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns DebuggerConfig
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$DebuggerConfig;

  /**
   * Verifies a DebuggerConfig message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a DebuggerConfig message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns DebuggerConfig
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$DebuggerConfig;

  /**
   * Creates a plain object from a DebuggerConfig message. Also converts values to other types if specified.
   * @param message DebuggerConfig
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$DebuggerConfig,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this DebuggerConfig to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ProxyGoingAway.
 */
declare type api$IProxyGoingAway = {||};

/**
 * Represents a ProxyGoingAway.
 */
declare class api$ProxyGoingAway {
  /**
   * Constructs a new ProxyGoingAway.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IProxyGoingAway): this;

  /**
   * Creates a new ProxyGoingAway instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ProxyGoingAway instance
   */
  static create(properties?: api$IProxyGoingAway): api$ProxyGoingAway;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ProxyGoingAway message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ProxyGoingAway,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ProxyGoingAway message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ProxyGoingAway,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ProxyGoingAway message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ProxyGoingAway
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ProxyGoingAway;

  /**
   * Decodes a ProxyGoingAway message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ProxyGoingAway
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ProxyGoingAway;

  /**
   * Verifies a ProxyGoingAway message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ProxyGoingAway message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ProxyGoingAway
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ProxyGoingAway;

  /**
   * Creates a plain object from a ProxyGoingAway message. Also converts values to other types if specified.
   * @param message ProxyGoingAway
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ProxyGoingAway,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ProxyGoingAway to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a FirewallDenied.
 */
declare type api$IFirewallDenied = {||};

/**
 * Represents a FirewallDenied.
 */
declare class api$FirewallDenied {
  /**
   * Constructs a new FirewallDenied.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IFirewallDenied): this;

  /**
   * Creates a new FirewallDenied instance using the specified properties.
   * @param [properties] Properties to set
   * @returns FirewallDenied instance
   */
  static create(properties?: api$IFirewallDenied): api$FirewallDenied;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FirewallDenied message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$FirewallDenied,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message FirewallDenied message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$FirewallDenied,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a FirewallDenied message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns FirewallDenied
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$FirewallDenied;

  /**
   * Decodes a FirewallDenied message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns FirewallDenied
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$FirewallDenied;

  /**
   * Verifies a FirewallDenied message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a FirewallDenied message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns FirewallDenied
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$FirewallDenied;

  /**
   * Creates a plain object from a FirewallDenied message. Also converts values to other types if specified.
   * @param message FirewallDenied
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$FirewallDenied,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this FirewallDenied to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a Repl.
 */
declare type api$IRepl = {|
  /**
   * Repl id
   */
  id?: string | null,

  /**
   * Repl language
   */
  language?: string | null,

  /**
   * Repl bucket
   */
  bucket?: string | null,

  /**
   * Repl slug
   */
  slug?: string | null,

  /**
   * Repl user
   */
  user?: string | null,

  /**
   * Repl sourceRepl
   */
  sourceRepl?: string | null,
|};

/**
 * Represents a Repl.
 */
declare class api$Repl {
  /**
   * Constructs a new Repl.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IRepl): this;

  /**
   * Repl id.
   */
  id: string;

  /**
   * Repl language.
   */
  language: string;

  /**
   * Repl bucket.
   */
  bucket: string;

  /**
   * Repl slug.
   */
  slug: string;

  /**
   * Repl user.
   */
  user: string;

  /**
   * Repl sourceRepl.
   */
  sourceRepl: string;

  /**
   * Creates a new Repl instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Repl instance
   */
  static create(properties?: api$IRepl): api$Repl;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Repl message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(message: api$Repl, writer?: $protobuf.Writer): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Repl message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Repl,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Repl message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Repl
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Repl;

  /**
   * Decodes a Repl message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Repl
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$Repl;

  /**
   * Verifies a Repl message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Repl message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Repl
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Repl;

  /**
   * Creates a plain object from a Repl message. Also converts values to other types if specified.
   * @param message Repl
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Repl,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Repl to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ResourceLimits.
 */
declare type api$IResourceLimits = {|
  /**
   * ResourceLimits net
   */
  net?: boolean | null,

  /**
   * ResourceLimits memory
   */
  memory?: number | null,

  /**
   * ResourceLimits threads
   */
  threads?: number | null,

  /**
   * ResourceLimits shares
   */
  shares?: number | null,

  /**
   * ResourceLimits disk
   */
  disk?: number | null,

  /**
   * ResourceLimits cache
   */
  cache?: $Values<typeof api$ResourceLimits$Cachability> | null,

  /**
   * ResourceLimits restrictNetwork
   */
  restrictNetwork?: boolean | null,
|};

/**
 * Represents a ResourceLimits.
 */
declare class api$ResourceLimits {
  /**
   * Constructs a new ResourceLimits.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IResourceLimits): this;

  /**
   * ResourceLimits net.
   */
  net: boolean;

  /**
   * ResourceLimits memory.
   */
  memory: number;

  /**
   * ResourceLimits threads.
   */
  threads: number;

  /**
   * ResourceLimits shares.
   */
  shares: number;

  /**
   * ResourceLimits disk.
   */
  disk: number;

  /**
   * ResourceLimits cache.
   */
  cache: $Values<typeof api$ResourceLimits$Cachability>;

  /**
   * ResourceLimits restrictNetwork.
   */
  restrictNetwork: boolean;

  /**
   * Creates a new ResourceLimits instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ResourceLimits instance
   */
  static create(properties?: api$IResourceLimits): api$ResourceLimits;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ResourceLimits message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ResourceLimits,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ResourceLimits message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ResourceLimits,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ResourceLimits message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ResourceLimits
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ResourceLimits;

  /**
   * Decodes a ResourceLimits message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ResourceLimits
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ResourceLimits;

  /**
   * Verifies a ResourceLimits message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ResourceLimits message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ResourceLimits
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ResourceLimits;

  /**
   * Creates a plain object from a ResourceLimits message. Also converts values to other types if specified.
   * @param message ResourceLimits
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ResourceLimits,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ResourceLimits to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Cachability: typeof api$ResourceLimits$Cachability;
}

/**
 * Cachability enum.
 */

declare var api$ResourceLimits$Cachability: {|
  +NONE: 0, // 0
  +USER: 1, // 1
  +REPL: 2, // 2
|};

/**
 * Properties of a Permissions.
 */
declare type api$IPermissions = {|
  /**
   * Permissions toggleAlwaysOn
   */
  toggleAlwaysOn?: boolean | null,
|};

/**
 * Represents a Permissions.
 */
declare class api$Permissions {
  /**
   * Constructs a new Permissions.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IPermissions): this;

  /**
   * Permissions toggleAlwaysOn.
   */
  toggleAlwaysOn: boolean;

  /**
   * Creates a new Permissions instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Permissions instance
   */
  static create(properties?: api$IPermissions): api$Permissions;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Permissions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$Permissions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Permissions message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$Permissions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Permissions message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Permissions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$Permissions;

  /**
   * Decodes a Permissions message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Permissions
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$Permissions;

  /**
   * Verifies a Permissions message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Permissions message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Permissions
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$Permissions;

  /**
   * Creates a plain object from a Permissions message. Also converts values to other types if specified.
   * @param message Permissions
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$Permissions,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Permissions to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReplToken.
 */
declare type api$IReplToken = {|
  /**
   * ReplToken iat
   */
  iat?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,

  /**
   * ReplToken exp
   */
  exp?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,

  /**
   * ReplToken salt
   */
  salt?: string | null,

  /**
   * ReplToken cluster
   */
  cluster?: string | null,

  /**
   * ReplToken persistence
   */
  persistence?: $Values<typeof api$ReplToken$Persistence> | null,

  /**
   * ReplToken repl
   */
  repl?: api$Repl | api$IRepl | null,

  /**
   * ReplToken id
   */
  id?: api$ReplToken$ReplID | api$ReplToken$IReplID | null,

  /**
   * ReplToken classroom
   */
  classroom?:
    | api$ReplToken$ClassroomMetadata
    | api$ReplToken$IClassroomMetadata
    | null,

  /**
   * ReplToken resourceLimits
   */
  resourceLimits?: api$ResourceLimits | api$IResourceLimits | null,

  /**
   * ReplToken format
   */
  format?: $Values<typeof api$ReplToken$WireFormat> | null,

  /**
   * ReplToken presenced
   */
  presenced?: api$ReplToken$Presenced | api$ReplToken$IPresenced | null,

  /**
   * ReplToken flags
   */
  flags?: string[] | null,

  /**
   * ReplToken permissions
   */
  permissions?: api$Permissions | api$IPermissions | null,
|};

/**
 * Represents a ReplToken.
 */
declare class api$ReplToken {
  /**
   * Constructs a new ReplToken.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IReplToken): this;

  /**
   * ReplToken iat.
   */
  iat?: google$protobuf$Timestamp | null;

  /**
   * ReplToken exp.
   */
  exp?: google$protobuf$Timestamp | null;

  /**
   * ReplToken salt.
   */
  salt: string;

  /**
   * ReplToken cluster.
   */
  cluster: string;

  /**
   * ReplToken persistence.
   */
  persistence: $Values<typeof api$ReplToken$Persistence>;

  /**
   * ReplToken repl.
   */
  repl?: api$Repl | null;

  /**
   * ReplToken id.
   */
  id?: api$ReplToken$ReplID | null;

  /**
   * ReplToken classroom.
   */
  classroom?: api$ReplToken$ClassroomMetadata | null;

  /**
   * ReplToken resourceLimits.
   */
  resourceLimits?: api$ResourceLimits | null;

  /**
   * ReplToken format.
   */
  format: $Values<typeof api$ReplToken$WireFormat>;

  /**
   * ReplToken presenced.
   */
  presenced?: api$ReplToken$Presenced | null;

  /**
   * ReplToken flags.
   */
  flags: string[];

  /**
   * ReplToken permissions.
   */
  permissions?: api$Permissions | null;

  /**
   * ReplToken metadata.
   */
  metadata?: "repl" | "id" | "classroom";

  /**
   * Creates a new ReplToken instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReplToken instance
   */
  static create(properties?: api$IReplToken): api$ReplToken;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplToken message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ReplToken,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplToken message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ReplToken,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReplToken message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReplToken
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ReplToken;

  /**
   * Decodes a ReplToken message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReplToken
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$ReplToken;

  /**
   * Verifies a ReplToken message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReplToken message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReplToken
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ReplToken;

  /**
   * Creates a plain object from a ReplToken message. Also converts values to other types if specified.
   * @param message ReplToken
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ReplToken,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReplToken to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
  static Persistence: typeof api$ReplToken$Persistence;
  static WireFormat: typeof api$ReplToken$WireFormat;
  static IClassroomMetadata: Class<api$ReplToken$IClassroomMetadata>;
  static IReplID: Class<api$ReplToken$IReplID>;
  static IPresenced: Class<api$ReplToken$IPresenced>;
  static ClassroomMetadata: typeof api$ReplToken$ClassroomMetadata;
  static ReplID: typeof api$ReplToken$ReplID;
  static Presenced: typeof api$ReplToken$Presenced;
}

/**
 * Persistence enum.
 */

declare var api$ReplToken$Persistence: {|
  +PERSISTENT: 0, // 0
  +EPHEMERAL: 1, // 1
  +NONE: 2, // 2
|};

/**
 * Properties of a ClassroomMetadata.
 */
declare type api$ReplToken$IClassroomMetadata = {|
  /**
   * ClassroomMetadata id
   */
  id?: string | null,

  /**
   * ClassroomMetadata language
   */
  language?: string | null,
|};

/**
 * Represents a ClassroomMetadata.
 */
declare class api$ReplToken$ClassroomMetadata {
  /**
   * Constructs a new ClassroomMetadata.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ReplToken$IClassroomMetadata): this;

  /**
   * ClassroomMetadata id.
   */
  id: string;

  /**
   * ClassroomMetadata language.
   */
  language: string;

  /**
   * Creates a new ClassroomMetadata instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ClassroomMetadata instance
   */
  static create(
    properties?: api$ReplToken$IClassroomMetadata
  ): api$ReplToken$ClassroomMetadata;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ClassroomMetadata message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ReplToken$ClassroomMetadata,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ClassroomMetadata message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ReplToken$ClassroomMetadata,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ClassroomMetadata message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ClassroomMetadata
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ReplToken$ClassroomMetadata;

  /**
   * Decodes a ClassroomMetadata message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ClassroomMetadata
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ReplToken$ClassroomMetadata;

  /**
   * Verifies a ClassroomMetadata message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ClassroomMetadata message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ClassroomMetadata
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ReplToken$ClassroomMetadata;

  /**
   * Creates a plain object from a ClassroomMetadata message. Also converts values to other types if specified.
   * @param message ClassroomMetadata
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ReplToken$ClassroomMetadata,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ClassroomMetadata to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReplID.
 */
declare type api$ReplToken$IReplID = {|
  /**
   * ReplID id
   */
  id?: string | null,

  /**
   * ReplID sourceRepl
   */
  sourceRepl?: string | null,
|};

/**
 * Represents a ReplID.
 */
declare class api$ReplToken$ReplID {
  /**
   * Constructs a new ReplID.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ReplToken$IReplID): this;

  /**
   * ReplID id.
   */
  id: string;

  /**
   * ReplID sourceRepl.
   */
  sourceRepl: string;

  /**
   * Creates a new ReplID instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReplID instance
   */
  static create(properties?: api$ReplToken$IReplID): api$ReplToken$ReplID;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplID message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ReplToken$ReplID,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplID message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ReplToken$ReplID,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReplID message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReplID
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ReplToken$ReplID;

  /**
   * Decodes a ReplID message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReplID
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ReplToken$ReplID;

  /**
   * Verifies a ReplID message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReplID message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReplID
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ReplToken$ReplID;

  /**
   * Creates a plain object from a ReplID message. Also converts values to other types if specified.
   * @param message ReplID
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ReplToken$ReplID,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReplID to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * WireFormat enum.
 */

declare var api$ReplToken$WireFormat: {|
  +PROTOBUF: 0, // 0
  +JSON: 1, // 1
|};

/**
 * Properties of a Presenced.
 */
declare type api$ReplToken$IPresenced = {|
  /**
   * Presenced bearerID
   */
  bearerID?: number | null,

  /**
   * Presenced bearerName
   */
  bearerName?: string | null,
|};

/**
 * Represents a Presenced.
 */
declare class api$ReplToken$Presenced {
  /**
   * Constructs a new Presenced.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ReplToken$IPresenced): this;

  /**
   * Presenced bearerID.
   */
  bearerID: number;

  /**
   * Presenced bearerName.
   */
  bearerName: string;

  /**
   * Creates a new Presenced instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Presenced instance
   */
  static create(properties?: api$ReplToken$IPresenced): api$ReplToken$Presenced;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Presenced message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ReplToken$Presenced,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Presenced message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ReplToken$Presenced,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Presenced message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Presenced
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ReplToken$Presenced;

  /**
   * Decodes a Presenced message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Presenced
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ReplToken$Presenced;

  /**
   * Verifies a Presenced message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Presenced message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Presenced
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ReplToken$Presenced;

  /**
   * Creates a plain object from a Presenced message. Also converts values to other types if specified.
   * @param message Presenced
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ReplToken$Presenced,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Presenced to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a TLSCertificate.
 */
declare type api$ITLSCertificate = {|
  /**
   * TLSCertificate domain
   */
  domain?: string | null,

  /**
   * TLSCertificate cert
   */
  cert?: Uint8Array | null,
|};

/**
 * Represents a TLSCertificate.
 */
declare class api$TLSCertificate {
  /**
   * Constructs a new TLSCertificate.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ITLSCertificate): this;

  /**
   * TLSCertificate domain.
   */
  domain: string;

  /**
   * TLSCertificate cert.
   */
  cert: Uint8Array;

  /**
   * Creates a new TLSCertificate instance using the specified properties.
   * @param [properties] Properties to set
   * @returns TLSCertificate instance
   */
  static create(properties?: api$ITLSCertificate): api$TLSCertificate;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TLSCertificate message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$TLSCertificate,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message TLSCertificate message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$TLSCertificate,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a TLSCertificate message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns TLSCertificate
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$TLSCertificate;

  /**
   * Decodes a TLSCertificate message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns TLSCertificate
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$TLSCertificate;

  /**
   * Verifies a TLSCertificate message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a TLSCertificate message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns TLSCertificate
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$TLSCertificate;

  /**
   * Creates a plain object from a TLSCertificate message. Also converts values to other types if specified.
   * @param message TLSCertificate
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$TLSCertificate,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this TLSCertificate to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ReplTransfer.
 */
declare type api$IReplTransfer = {|
  /**
   * ReplTransfer repl
   */
  repl?: api$Repl | api$IRepl | null,

  /**
   * ReplTransfer replLimits
   */
  replLimits?: api$ResourceLimits | api$IResourceLimits | null,

  /**
   * ReplTransfer userLimits
   */
  userLimits?: api$ResourceLimits | api$IResourceLimits | null,

  /**
   * ReplTransfer customDomains
   */
  customDomains?: string[] | null,

  /**
   * ReplTransfer certificates
   */
  certificates?: (api$TLSCertificate | api$ITLSCertificate)[] | null,

  /**
   * ReplTransfer flags
   */
  flags?: string[] | null,
|};

/**
 * Represents a ReplTransfer.
 */
declare class api$ReplTransfer {
  /**
   * Constructs a new ReplTransfer.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IReplTransfer): this;

  /**
   * ReplTransfer repl.
   */
  repl?: api$Repl | null;

  /**
   * ReplTransfer replLimits.
   */
  replLimits?: api$ResourceLimits | null;

  /**
   * ReplTransfer userLimits.
   */
  userLimits?: api$ResourceLimits | null;

  /**
   * ReplTransfer customDomains.
   */
  customDomains: string[];

  /**
   * ReplTransfer certificates.
   */
  certificates: api$TLSCertificate[];

  /**
   * ReplTransfer flags.
   */
  flags: string[];

  /**
   * Creates a new ReplTransfer instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ReplTransfer instance
   */
  static create(properties?: api$IReplTransfer): api$ReplTransfer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplTransfer message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ReplTransfer,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ReplTransfer message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ReplTransfer,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ReplTransfer message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ReplTransfer
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ReplTransfer;

  /**
   * Decodes a ReplTransfer message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ReplTransfer
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ReplTransfer;

  /**
   * Verifies a ReplTransfer message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ReplTransfer message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ReplTransfer
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ReplTransfer;

  /**
   * Creates a plain object from a ReplTransfer message. Also converts values to other types if specified.
   * @param message ReplTransfer
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ReplTransfer,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ReplTransfer to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an AllowReplRequest.
 */
declare type api$IAllowReplRequest = {|
  /**
   * AllowReplRequest replTransfer
   */
  replTransfer?: api$ReplTransfer | api$IReplTransfer | null,
|};

/**
 * Represents an AllowReplRequest.
 */
declare class api$AllowReplRequest {
  /**
   * Constructs a new AllowReplRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IAllowReplRequest): this;

  /**
   * AllowReplRequest replTransfer.
   */
  replTransfer?: api$ReplTransfer | null;

  /**
   * Creates a new AllowReplRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns AllowReplRequest instance
   */
  static create(properties?: api$IAllowReplRequest): api$AllowReplRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AllowReplRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$AllowReplRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message AllowReplRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$AllowReplRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an AllowReplRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns AllowReplRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$AllowReplRequest;

  /**
   * Decodes an AllowReplRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns AllowReplRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$AllowReplRequest;

  /**
   * Verifies an AllowReplRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an AllowReplRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns AllowReplRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$AllowReplRequest;

  /**
   * Creates a plain object from an AllowReplRequest message. Also converts values to other types if specified.
   * @param message AllowReplRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$AllowReplRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this AllowReplRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a ClusterMetadata.
 */
declare type api$IClusterMetadata = {|
  /**
   * ClusterMetadata id
   */
  id?: string | null,

  /**
   * ClusterMetadata conmanURL
   */
  conmanURL?: string | null,

  /**
   * ClusterMetadata gurl
   */
  gurl?: string | null,

  /**
   * ClusterMetadata proxy
   */
  proxy?: string | null,
|};

/**
 * Represents a ClusterMetadata.
 */
declare class api$ClusterMetadata {
  /**
   * Constructs a new ClusterMetadata.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IClusterMetadata): this;

  /**
   * ClusterMetadata id.
   */
  id: string;

  /**
   * ClusterMetadata conmanURL.
   */
  conmanURL: string;

  /**
   * ClusterMetadata gurl.
   */
  gurl: string;

  /**
   * ClusterMetadata proxy.
   */
  proxy: string;

  /**
   * Creates a new ClusterMetadata instance using the specified properties.
   * @param [properties] Properties to set
   * @returns ClusterMetadata instance
   */
  static create(properties?: api$IClusterMetadata): api$ClusterMetadata;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ClusterMetadata message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$ClusterMetadata,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message ClusterMetadata message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$ClusterMetadata,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a ClusterMetadata message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns ClusterMetadata
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$ClusterMetadata;

  /**
   * Decodes a ClusterMetadata message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns ClusterMetadata
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$ClusterMetadata;

  /**
   * Verifies a ClusterMetadata message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a ClusterMetadata message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns ClusterMetadata
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$ClusterMetadata;

  /**
   * Creates a plain object from a ClusterMetadata message. Also converts values to other types if specified.
   * @param message ClusterMetadata
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$ClusterMetadata,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this ClusterMetadata to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an EvictReplRequest.
 */
declare type api$IEvictReplRequest = {|
  /**
   * EvictReplRequest clusterMetadata
   */
  clusterMetadata?: api$ClusterMetadata | api$IClusterMetadata | null,

  /**
   * EvictReplRequest token
   */
  token?: string | null,

  /**
   * EvictReplRequest user
   */
  user?: string | null,

  /**
   * EvictReplRequest slug
   */
  slug?: string | null,
|};

/**
 * Represents an EvictReplRequest.
 */
declare class api$EvictReplRequest {
  /**
   * Constructs a new EvictReplRequest.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IEvictReplRequest): this;

  /**
   * EvictReplRequest clusterMetadata.
   */
  clusterMetadata?: api$ClusterMetadata | null;

  /**
   * EvictReplRequest token.
   */
  token: string;

  /**
   * EvictReplRequest user.
   */
  user: string;

  /**
   * EvictReplRequest slug.
   */
  slug: string;

  /**
   * Creates a new EvictReplRequest instance using the specified properties.
   * @param [properties] Properties to set
   * @returns EvictReplRequest instance
   */
  static create(properties?: api$IEvictReplRequest): api$EvictReplRequest;

  /**
   * [object Object],[object Object],[object Object]
   * @param message EvictReplRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$EvictReplRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message EvictReplRequest message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$EvictReplRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an EvictReplRequest message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns EvictReplRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$EvictReplRequest;

  /**
   * Decodes an EvictReplRequest message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns EvictReplRequest
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$EvictReplRequest;

  /**
   * Verifies an EvictReplRequest message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an EvictReplRequest message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns EvictReplRequest
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$EvictReplRequest;

  /**
   * Creates a plain object from an EvictReplRequest message. Also converts values to other types if specified.
   * @param message EvictReplRequest
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$EvictReplRequest,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this EvictReplRequest to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of an EvictReplResponse.
 */
declare type api$IEvictReplResponse = {|
  /**
   * EvictReplResponse replTransfer
   */
  replTransfer?: api$ReplTransfer | api$IReplTransfer | null,
|};

/**
 * Represents an EvictReplResponse.
 */
declare class api$EvictReplResponse {
  /**
   * Constructs a new EvictReplResponse.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IEvictReplResponse): this;

  /**
   * EvictReplResponse replTransfer.
   */
  replTransfer?: api$ReplTransfer | null;

  /**
   * Creates a new EvictReplResponse instance using the specified properties.
   * @param [properties] Properties to set
   * @returns EvictReplResponse instance
   */
  static create(properties?: api$IEvictReplResponse): api$EvictReplResponse;

  /**
   * [object Object],[object Object],[object Object]
   * @param message EvictReplResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$EvictReplResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message EvictReplResponse message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$EvictReplResponse,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes an EvictReplResponse message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns EvictReplResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$EvictReplResponse;

  /**
   * Decodes an EvictReplResponse message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns EvictReplResponse
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$EvictReplResponse;

  /**
   * Verifies an EvictReplResponse message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates an EvictReplResponse message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns EvictReplResponse
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$EvictReplResponse;

  /**
   * Creates a plain object from an EvictReplResponse message. Also converts values to other types if specified.
   * @param message EvictReplResponse
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$EvictReplResponse,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this EvictReplResponse to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * TokenVersion enum.
 */

declare var api$TokenVersion: {|
  +BARE_REPL_TOKEN: 0, // 0
  +TYPE_AWARE_TOKEN: 1, // 1
|};

/**
 * Properties of a GovalSigningAuthority.
 */
declare type api$IGovalSigningAuthority = {|
  /**
   * GovalSigningAuthority keyId
   */
  keyId?: string | null,

  /**
   * GovalSigningAuthority signedCert
   */
  signedCert?: string | null,

  /**
   * GovalSigningAuthority version
   */
  version?: $Values<typeof api$TokenVersion> | null,

  /**
   * GovalSigningAuthority issuer
   */
  issuer?: string | null,
|};

/**
 * Represents a GovalSigningAuthority.
 */
declare class api$GovalSigningAuthority {
  /**
   * Constructs a new GovalSigningAuthority.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IGovalSigningAuthority): this;

  /**
   * GovalSigningAuthority keyId.
   */
  keyId?: string | null;

  /**
   * GovalSigningAuthority signedCert.
   */
  signedCert?: string | null;

  /**
   * GovalSigningAuthority version.
   */
  version: $Values<typeof api$TokenVersion>;

  /**
   * GovalSigningAuthority issuer.
   */
  issuer: string;

  /**
   * GovalSigningAuthority cert.
   */
  cert?: "keyId" | "signedCert";

  /**
   * Creates a new GovalSigningAuthority instance using the specified properties.
   * @param [properties] Properties to set
   * @returns GovalSigningAuthority instance
   */
  static create(
    properties?: api$IGovalSigningAuthority
  ): api$GovalSigningAuthority;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalSigningAuthority message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$GovalSigningAuthority,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalSigningAuthority message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$GovalSigningAuthority,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a GovalSigningAuthority message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns GovalSigningAuthority
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$GovalSigningAuthority;

  /**
   * Decodes a GovalSigningAuthority message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns GovalSigningAuthority
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$GovalSigningAuthority;

  /**
   * Verifies a GovalSigningAuthority message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a GovalSigningAuthority message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns GovalSigningAuthority
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$GovalSigningAuthority;

  /**
   * Creates a plain object from a GovalSigningAuthority message. Also converts values to other types if specified.
   * @param message GovalSigningAuthority
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$GovalSigningAuthority,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this GovalSigningAuthority to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * FlagClaim enum.
 */

declare var api$FlagClaim: {|
  +MINT_GOVAL_TOKEN: 0, // 0
  +SIGN_INTERMEDIATE_CERT: 1, // 1
|};

/**
 * Properties of a CertificateClaim.
 */
declare type api$ICertificateClaim = {|
  /**
   * CertificateClaim replid
   */
  replid?: string | null,

  /**
   * CertificateClaim user
   */
  user?: string | null,

  /**
   * CertificateClaim flag
   */
  flag?: $Values<typeof api$FlagClaim> | null,
|};

/**
 * Represents a CertificateClaim.
 */
declare class api$CertificateClaim {
  /**
   * Constructs a new CertificateClaim.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$ICertificateClaim): this;

  /**
   * CertificateClaim replid.
   */
  replid?: string | null;

  /**
   * CertificateClaim user.
   */
  user?: string | null;

  /**
   * CertificateClaim flag.
   */
  flag?: $Values<typeof api$FlagClaim> | null;

  /**
   * CertificateClaim claim.
   */
  claim?: "replid" | "user" | "flag";

  /**
   * Creates a new CertificateClaim instance using the specified properties.
   * @param [properties] Properties to set
   * @returns CertificateClaim instance
   */
  static create(properties?: api$ICertificateClaim): api$CertificateClaim;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CertificateClaim message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$CertificateClaim,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message CertificateClaim message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$CertificateClaim,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a CertificateClaim message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns CertificateClaim
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$CertificateClaim;

  /**
   * Decodes a CertificateClaim message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns CertificateClaim
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): api$CertificateClaim;

  /**
   * Verifies a CertificateClaim message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a CertificateClaim message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns CertificateClaim
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$CertificateClaim;

  /**
   * Creates a plain object from a CertificateClaim message. Also converts values to other types if specified.
   * @param message CertificateClaim
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$CertificateClaim,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this CertificateClaim to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a GovalCert.
 */
declare type api$IGovalCert = {|
  /**
   * GovalCert iat
   */
  iat?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,

  /**
   * GovalCert exp
   */
  exp?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,

  /**
   * GovalCert claims
   */
  claims?: (api$CertificateClaim | api$ICertificateClaim)[] | null,

  /**
   * GovalCert publicKey
   */
  publicKey?: string | null,
|};

/**
 * Represents a GovalCert.
 */
declare class api$GovalCert {
  /**
   * Constructs a new GovalCert.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IGovalCert): this;

  /**
   * GovalCert iat.
   */
  iat?: google$protobuf$Timestamp | null;

  /**
   * GovalCert exp.
   */
  exp?: google$protobuf$Timestamp | null;

  /**
   * GovalCert claims.
   */
  claims: api$CertificateClaim[];

  /**
   * GovalCert publicKey.
   */
  publicKey: string;

  /**
   * Creates a new GovalCert instance using the specified properties.
   * @param [properties] Properties to set
   * @returns GovalCert instance
   */
  static create(properties?: api$IGovalCert): api$GovalCert;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalCert message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$GovalCert,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalCert message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$GovalCert,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a GovalCert message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns GovalCert
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$GovalCert;

  /**
   * Decodes a GovalCert message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns GovalCert
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$GovalCert;

  /**
   * Verifies a GovalCert message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a GovalCert message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns GovalCert
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$GovalCert;

  /**
   * Creates a plain object from a GovalCert message. Also converts values to other types if specified.
   * @param message GovalCert
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$GovalCert,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this GovalCert to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}

/**
 * Properties of a GovalToken.
 */
declare type api$IGovalToken = {|
  /**
   * GovalToken iat
   */
  iat?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,

  /**
   * GovalToken exp
   */
  exp?: google$protobuf$Timestamp | google$protobuf$ITimestamp | null,

  /**
   * GovalToken replid
   */
  replid?: string | null,

  /**
   * GovalToken replToken
   */
  replToken?: api$ReplToken | api$IReplToken | null,
|};

/**
 * Represents a GovalToken.
 */
declare class api$GovalToken {
  /**
   * Constructs a new GovalToken.
   * @param [properties] Properties to set
   */
  constructor(properties?: api$IGovalToken): this;

  /**
   * GovalToken iat.
   */
  iat?: google$protobuf$Timestamp | null;

  /**
   * GovalToken exp.
   */
  exp?: google$protobuf$Timestamp | null;

  /**
   * GovalToken replid.
   */
  replid: string;

  /**
   * GovalToken replToken.
   */
  replToken?: api$ReplToken | null;

  /**
   * GovalToken Token.
   */
  Token?: "replToken";

  /**
   * Creates a new GovalToken instance using the specified properties.
   * @param [properties] Properties to set
   * @returns GovalToken instance
   */
  static create(properties?: api$IGovalToken): api$GovalToken;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalToken message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: api$GovalToken,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message GovalToken message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: api$GovalToken,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a GovalToken message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns GovalToken
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): api$GovalToken;

  /**
   * Decodes a GovalToken message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns GovalToken
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): api$GovalToken;

  /**
   * Verifies a GovalToken message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a GovalToken message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns GovalToken
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): api$GovalToken;

  /**
   * Creates a plain object from a GovalToken message. Also converts values to other types if specified.
   * @param message GovalToken
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: api$GovalToken,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this GovalToken to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}
declare var google: typeof npm$namespace$google;

declare var npm$namespace$google: {|
  protobuf: typeof npm$namespace$google$protobuf,
|};

declare var npm$namespace$google$protobuf: {|
  ITimestamp: Class<google$protobuf$ITimestamp>,
  Timestamp: typeof google$protobuf$Timestamp,
|};

/**
 * Properties of a Timestamp.
 */
declare type google$protobuf$ITimestamp = {|
  /**
   * Timestamp seconds
   */
  seconds?: number | null,

  /**
   * Timestamp nanos
   */
  nanos?: number | null,
|};

/**
 * Represents a Timestamp.
 */
declare class google$protobuf$Timestamp {
  /**
   * Constructs a new Timestamp.
   * @param [properties] Properties to set
   */
  constructor(properties?: google$protobuf$ITimestamp): this;

  /**
   * Timestamp seconds.
   */
  seconds: number;

  /**
   * Timestamp nanos.
   */
  nanos: number;

  /**
   * Creates a new Timestamp instance using the specified properties.
   * @param [properties] Properties to set
   * @returns Timestamp instance
   */
  static create(
    properties?: google$protobuf$ITimestamp
  ): google$protobuf$Timestamp;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Timestamp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encode(
    message: google$protobuf$Timestamp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * [object Object],[object Object],[object Object]
   * @param message Timestamp message or plain object to encode
   * @param [writer] Writer to encode to
   * @returns Writer
   */
  static encodeDelimited(
    message: google$protobuf$Timestamp,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;

  /**
   * Decodes a Timestamp message from the specified reader or buffer.
   * @param reader Reader or buffer to decode from
   * @param [length] Message length if known beforehand
   * @returns Timestamp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$Timestamp;

  /**
   * Decodes a Timestamp message from the specified reader or buffer, length delimited.
   * @param reader Reader or buffer to decode from
   * @returns Timestamp
   * @throws {Error} If the payload is not a reader or valid buffer
   * @throws {$protobuf.util.ProtocolError} If required fields are missing
   */
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$Timestamp;

  /**
   * Verifies a Timestamp message.
   * @param message Plain object to verify
   * @returns `null` if valid, otherwise the reason why it is not
   */
  static verify(message: {|
    [k: string]: any,
  |}): string | null;

  /**
   * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
   * @param object Plain object
   * @returns Timestamp
   */
  static fromObject(object: {|
    [k: string]: any,
  |}): google$protobuf$Timestamp;

  /**
   * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
   * @param message Timestamp
   * @param [options] Conversion options
   * @returns Plain object
   */
  static toObject(
    message: google$protobuf$Timestamp,
    options?: $protobuf.IConversionOptions
  ): {|
    [k: string]: any,
  |};

  /**
   * Converts this Timestamp to JSON.
   * @returns JSON object
   */
  toJSON(): {|
    [k: string]: any,
  |};
}
